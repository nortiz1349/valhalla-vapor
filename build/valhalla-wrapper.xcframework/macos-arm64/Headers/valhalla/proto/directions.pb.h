// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: directions.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_directions_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_directions_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_util.h"
#include "common.pb.h"
#include "sign.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_directions_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_directions_2eproto {
  static const ::uint32_t offsets[];
};
namespace valhalla {
class Directions;
struct DirectionsDefaultTypeInternal;
extern DirectionsDefaultTypeInternal _Directions_default_instance_;
class DirectionsLeg;
struct DirectionsLegDefaultTypeInternal;
extern DirectionsLegDefaultTypeInternal _DirectionsLeg_default_instance_;
class DirectionsLeg_GuidanceView;
struct DirectionsLeg_GuidanceViewDefaultTypeInternal;
extern DirectionsLeg_GuidanceViewDefaultTypeInternal _DirectionsLeg_GuidanceView_default_instance_;
class DirectionsLeg_Maneuver;
struct DirectionsLeg_ManeuverDefaultTypeInternal;
extern DirectionsLeg_ManeuverDefaultTypeInternal _DirectionsLeg_Maneuver_default_instance_;
class DirectionsRoute;
struct DirectionsRouteDefaultTypeInternal;
extern DirectionsRouteDefaultTypeInternal _DirectionsRoute_default_instance_;
}  // namespace valhalla
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace valhalla {
enum DirectionsLeg_GuidanceView_Type : int {
  DirectionsLeg_GuidanceView_Type_kJunction = 0,
  DirectionsLeg_GuidanceView_Type_kSapa = 1,
  DirectionsLeg_GuidanceView_Type_kTollbranch = 2,
  DirectionsLeg_GuidanceView_Type_kAftertoll = 3,
  DirectionsLeg_GuidanceView_Type_kEnt = 4,
  DirectionsLeg_GuidanceView_Type_kExit = 5,
  DirectionsLeg_GuidanceView_Type_kCityreal = 6,
  DirectionsLeg_GuidanceView_Type_kDirectionboard = 7,
  DirectionsLeg_GuidanceView_Type_kSignboard = 8,
  DirectionsLeg_GuidanceView_Type_DirectionsLeg_GuidanceView_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DirectionsLeg_GuidanceView_Type_DirectionsLeg_GuidanceView_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DirectionsLeg_GuidanceView_Type_IsValid(int value);
extern const uint32_t DirectionsLeg_GuidanceView_Type_internal_data_[];
constexpr DirectionsLeg_GuidanceView_Type DirectionsLeg_GuidanceView_Type_Type_MIN = static_cast<DirectionsLeg_GuidanceView_Type>(0);
constexpr DirectionsLeg_GuidanceView_Type DirectionsLeg_GuidanceView_Type_Type_MAX = static_cast<DirectionsLeg_GuidanceView_Type>(8);
constexpr int DirectionsLeg_GuidanceView_Type_Type_ARRAYSIZE = 8 + 1;
const std::string& DirectionsLeg_GuidanceView_Type_Name(DirectionsLeg_GuidanceView_Type value);
template <typename T>
const std::string& DirectionsLeg_GuidanceView_Type_Name(T value) {
  static_assert(std::is_same<T, DirectionsLeg_GuidanceView_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return DirectionsLeg_GuidanceView_Type_Name(static_cast<DirectionsLeg_GuidanceView_Type>(value));
}
const std::string& DirectionsLeg_GuidanceView_Type_Name(DirectionsLeg_GuidanceView_Type value);
bool DirectionsLeg_GuidanceView_Type_Parse(absl::string_view name, DirectionsLeg_GuidanceView_Type* value);
enum DirectionsLeg_Maneuver_CardinalDirection : int {
  DirectionsLeg_Maneuver_CardinalDirection_kNorth = 0,
  DirectionsLeg_Maneuver_CardinalDirection_kNorthEast = 1,
  DirectionsLeg_Maneuver_CardinalDirection_kEast = 2,
  DirectionsLeg_Maneuver_CardinalDirection_kSouthEast = 3,
  DirectionsLeg_Maneuver_CardinalDirection_kSouth = 4,
  DirectionsLeg_Maneuver_CardinalDirection_kSouthWest = 5,
  DirectionsLeg_Maneuver_CardinalDirection_kWest = 6,
  DirectionsLeg_Maneuver_CardinalDirection_kNorthWest = 7,
  DirectionsLeg_Maneuver_CardinalDirection_DirectionsLeg_Maneuver_CardinalDirection_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DirectionsLeg_Maneuver_CardinalDirection_DirectionsLeg_Maneuver_CardinalDirection_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DirectionsLeg_Maneuver_CardinalDirection_IsValid(int value);
extern const uint32_t DirectionsLeg_Maneuver_CardinalDirection_internal_data_[];
constexpr DirectionsLeg_Maneuver_CardinalDirection DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_MIN = static_cast<DirectionsLeg_Maneuver_CardinalDirection>(0);
constexpr DirectionsLeg_Maneuver_CardinalDirection DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_MAX = static_cast<DirectionsLeg_Maneuver_CardinalDirection>(7);
constexpr int DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_ARRAYSIZE = 7 + 1;
const std::string& DirectionsLeg_Maneuver_CardinalDirection_Name(DirectionsLeg_Maneuver_CardinalDirection value);
template <typename T>
const std::string& DirectionsLeg_Maneuver_CardinalDirection_Name(T value) {
  static_assert(std::is_same<T, DirectionsLeg_Maneuver_CardinalDirection>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CardinalDirection_Name().");
  return DirectionsLeg_Maneuver_CardinalDirection_Name(static_cast<DirectionsLeg_Maneuver_CardinalDirection>(value));
}
const std::string& DirectionsLeg_Maneuver_CardinalDirection_Name(DirectionsLeg_Maneuver_CardinalDirection value);
bool DirectionsLeg_Maneuver_CardinalDirection_Parse(absl::string_view name, DirectionsLeg_Maneuver_CardinalDirection* value);
enum DirectionsLeg_Maneuver_Type : int {
  DirectionsLeg_Maneuver_Type_kNone = 0,
  DirectionsLeg_Maneuver_Type_kStart = 1,
  DirectionsLeg_Maneuver_Type_kStartRight = 2,
  DirectionsLeg_Maneuver_Type_kStartLeft = 3,
  DirectionsLeg_Maneuver_Type_kDestination = 4,
  DirectionsLeg_Maneuver_Type_kDestinationRight = 5,
  DirectionsLeg_Maneuver_Type_kDestinationLeft = 6,
  DirectionsLeg_Maneuver_Type_kBecomes = 7,
  DirectionsLeg_Maneuver_Type_kContinue = 8,
  DirectionsLeg_Maneuver_Type_kSlightRight = 9,
  DirectionsLeg_Maneuver_Type_kRight = 10,
  DirectionsLeg_Maneuver_Type_kSharpRight = 11,
  DirectionsLeg_Maneuver_Type_kUturnRight = 12,
  DirectionsLeg_Maneuver_Type_kUturnLeft = 13,
  DirectionsLeg_Maneuver_Type_kSharpLeft = 14,
  DirectionsLeg_Maneuver_Type_kLeft = 15,
  DirectionsLeg_Maneuver_Type_kSlightLeft = 16,
  DirectionsLeg_Maneuver_Type_kRampStraight = 17,
  DirectionsLeg_Maneuver_Type_kRampRight = 18,
  DirectionsLeg_Maneuver_Type_kRampLeft = 19,
  DirectionsLeg_Maneuver_Type_kExitRight = 20,
  DirectionsLeg_Maneuver_Type_kExitLeft = 21,
  DirectionsLeg_Maneuver_Type_kStayStraight = 22,
  DirectionsLeg_Maneuver_Type_kStayRight = 23,
  DirectionsLeg_Maneuver_Type_kStayLeft = 24,
  DirectionsLeg_Maneuver_Type_kMerge = 25,
  DirectionsLeg_Maneuver_Type_kRoundaboutEnter = 26,
  DirectionsLeg_Maneuver_Type_kRoundaboutExit = 27,
  DirectionsLeg_Maneuver_Type_kFerryEnter = 28,
  DirectionsLeg_Maneuver_Type_kFerryExit = 29,
  DirectionsLeg_Maneuver_Type_kTransit = 30,
  DirectionsLeg_Maneuver_Type_kTransitTransfer = 31,
  DirectionsLeg_Maneuver_Type_kTransitRemainOn = 32,
  DirectionsLeg_Maneuver_Type_kTransitConnectionStart = 33,
  DirectionsLeg_Maneuver_Type_kTransitConnectionTransfer = 34,
  DirectionsLeg_Maneuver_Type_kTransitConnectionDestination = 35,
  DirectionsLeg_Maneuver_Type_kPostTransitConnectionDestination = 36,
  DirectionsLeg_Maneuver_Type_kMergeRight = 37,
  DirectionsLeg_Maneuver_Type_kMergeLeft = 38,
  DirectionsLeg_Maneuver_Type_kElevatorEnter = 39,
  DirectionsLeg_Maneuver_Type_kStepsEnter = 40,
  DirectionsLeg_Maneuver_Type_kEscalatorEnter = 41,
  DirectionsLeg_Maneuver_Type_kBuildingEnter = 42,
  DirectionsLeg_Maneuver_Type_kBuildingExit = 43,
  DirectionsLeg_Maneuver_Type_DirectionsLeg_Maneuver_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DirectionsLeg_Maneuver_Type_DirectionsLeg_Maneuver_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DirectionsLeg_Maneuver_Type_IsValid(int value);
extern const uint32_t DirectionsLeg_Maneuver_Type_internal_data_[];
constexpr DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver_Type_Type_MIN = static_cast<DirectionsLeg_Maneuver_Type>(0);
constexpr DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver_Type_Type_MAX = static_cast<DirectionsLeg_Maneuver_Type>(43);
constexpr int DirectionsLeg_Maneuver_Type_Type_ARRAYSIZE = 43 + 1;
const std::string& DirectionsLeg_Maneuver_Type_Name(DirectionsLeg_Maneuver_Type value);
template <typename T>
const std::string& DirectionsLeg_Maneuver_Type_Name(T value) {
  static_assert(std::is_same<T, DirectionsLeg_Maneuver_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return DirectionsLeg_Maneuver_Type_Name(static_cast<DirectionsLeg_Maneuver_Type>(value));
}
const std::string& DirectionsLeg_Maneuver_Type_Name(DirectionsLeg_Maneuver_Type value);
bool DirectionsLeg_Maneuver_Type_Parse(absl::string_view name, DirectionsLeg_Maneuver_Type* value);
enum DirectionsLeg_Maneuver_BssManeuverType : int {
  DirectionsLeg_Maneuver_BssManeuverType_kNoneAction = 0,
  DirectionsLeg_Maneuver_BssManeuverType_kRentBikeAtBikeShare = 1,
  DirectionsLeg_Maneuver_BssManeuverType_kReturnBikeAtBikeShare = 2,
  DirectionsLeg_Maneuver_BssManeuverType_DirectionsLeg_Maneuver_BssManeuverType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DirectionsLeg_Maneuver_BssManeuverType_DirectionsLeg_Maneuver_BssManeuverType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DirectionsLeg_Maneuver_BssManeuverType_IsValid(int value);
extern const uint32_t DirectionsLeg_Maneuver_BssManeuverType_internal_data_[];
constexpr DirectionsLeg_Maneuver_BssManeuverType DirectionsLeg_Maneuver_BssManeuverType_BssManeuverType_MIN = static_cast<DirectionsLeg_Maneuver_BssManeuverType>(0);
constexpr DirectionsLeg_Maneuver_BssManeuverType DirectionsLeg_Maneuver_BssManeuverType_BssManeuverType_MAX = static_cast<DirectionsLeg_Maneuver_BssManeuverType>(2);
constexpr int DirectionsLeg_Maneuver_BssManeuverType_BssManeuverType_ARRAYSIZE = 2 + 1;
const std::string& DirectionsLeg_Maneuver_BssManeuverType_Name(DirectionsLeg_Maneuver_BssManeuverType value);
template <typename T>
const std::string& DirectionsLeg_Maneuver_BssManeuverType_Name(T value) {
  static_assert(std::is_same<T, DirectionsLeg_Maneuver_BssManeuverType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to BssManeuverType_Name().");
  return DirectionsLeg_Maneuver_BssManeuverType_Name(static_cast<DirectionsLeg_Maneuver_BssManeuverType>(value));
}
const std::string& DirectionsLeg_Maneuver_BssManeuverType_Name(DirectionsLeg_Maneuver_BssManeuverType value);
bool DirectionsLeg_Maneuver_BssManeuverType_Parse(absl::string_view name, DirectionsLeg_Maneuver_BssManeuverType* value);

// ===================================================================


// -------------------------------------------------------------------

class DirectionsLeg_GuidanceView final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.DirectionsLeg.GuidanceView) */ {
 public:
  inline DirectionsLeg_GuidanceView() : DirectionsLeg_GuidanceView(nullptr) {}
  ~DirectionsLeg_GuidanceView() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DirectionsLeg_GuidanceView(::google::protobuf::internal::ConstantInitialized);

  inline DirectionsLeg_GuidanceView(const DirectionsLeg_GuidanceView& from)
      : DirectionsLeg_GuidanceView(nullptr, from) {}
  DirectionsLeg_GuidanceView(DirectionsLeg_GuidanceView&& from) noexcept
    : DirectionsLeg_GuidanceView() {
    *this = ::std::move(from);
  }

  inline DirectionsLeg_GuidanceView& operator=(const DirectionsLeg_GuidanceView& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectionsLeg_GuidanceView& operator=(DirectionsLeg_GuidanceView&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DirectionsLeg_GuidanceView& default_instance() {
    return *internal_default_instance();
  }
  static inline const DirectionsLeg_GuidanceView* internal_default_instance() {
    return reinterpret_cast<const DirectionsLeg_GuidanceView*>(
               &_DirectionsLeg_GuidanceView_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DirectionsLeg_GuidanceView& a, DirectionsLeg_GuidanceView& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectionsLeg_GuidanceView* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectionsLeg_GuidanceView* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DirectionsLeg_GuidanceView* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DirectionsLeg_GuidanceView>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const DirectionsLeg_GuidanceView& from);
  void MergeFrom(const DirectionsLeg_GuidanceView& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DirectionsLeg_GuidanceView* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.DirectionsLeg.GuidanceView";
  }
  protected:
  explicit DirectionsLeg_GuidanceView(::google::protobuf::Arena* arena);
  DirectionsLeg_GuidanceView(::google::protobuf::Arena* arena, const DirectionsLeg_GuidanceView& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using Type = DirectionsLeg_GuidanceView_Type;
  static constexpr Type kJunction = DirectionsLeg_GuidanceView_Type_kJunction;
  static constexpr Type kSapa = DirectionsLeg_GuidanceView_Type_kSapa;
  static constexpr Type kTollbranch = DirectionsLeg_GuidanceView_Type_kTollbranch;
  static constexpr Type kAftertoll = DirectionsLeg_GuidanceView_Type_kAftertoll;
  static constexpr Type kEnt = DirectionsLeg_GuidanceView_Type_kEnt;
  static constexpr Type kExit = DirectionsLeg_GuidanceView_Type_kExit;
  static constexpr Type kCityreal = DirectionsLeg_GuidanceView_Type_kCityreal;
  static constexpr Type kDirectionboard = DirectionsLeg_GuidanceView_Type_kDirectionboard;
  static constexpr Type kSignboard = DirectionsLeg_GuidanceView_Type_kSignboard;
  static inline bool Type_IsValid(int value) {
    return DirectionsLeg_GuidanceView_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = DirectionsLeg_GuidanceView_Type_Type_MIN;
  static constexpr Type Type_MAX = DirectionsLeg_GuidanceView_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = DirectionsLeg_GuidanceView_Type_Type_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return DirectionsLeg_GuidanceView_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return DirectionsLeg_GuidanceView_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kOverlayIdsFieldNumber = 4,
    kDataIdFieldNumber = 1,
    kBaseIdFieldNumber = 3,
    kTypeFieldNumber = 2,
  };
  // repeated string overlay_ids = 4;
  int overlay_ids_size() const;
  private:
  int _internal_overlay_ids_size() const;

  public:
  void clear_overlay_ids() ;
  const std::string& overlay_ids(int index) const;
  std::string* mutable_overlay_ids(int index);
  void set_overlay_ids(int index, const std::string& value);
  void set_overlay_ids(int index, std::string&& value);
  void set_overlay_ids(int index, const char* value);
  void set_overlay_ids(int index, const char* value, std::size_t size);
  void set_overlay_ids(int index, absl::string_view value);
  std::string* add_overlay_ids();
  void add_overlay_ids(const std::string& value);
  void add_overlay_ids(std::string&& value);
  void add_overlay_ids(const char* value);
  void add_overlay_ids(const char* value, std::size_t size);
  void add_overlay_ids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& overlay_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_overlay_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_overlay_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_overlay_ids();

  public:
  // string data_id = 1;
  void clear_data_id() ;
  const std::string& data_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data_id(Arg_&& arg, Args_... args);
  std::string* mutable_data_id();
  PROTOBUF_NODISCARD std::string* release_data_id();
  void set_allocated_data_id(std::string* value);

  private:
  const std::string& _internal_data_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_id(
      const std::string& value);
  std::string* _internal_mutable_data_id();

  public:
  // string base_id = 3;
  void clear_base_id() ;
  const std::string& base_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_base_id(Arg_&& arg, Args_... args);
  std::string* mutable_base_id();
  PROTOBUF_NODISCARD std::string* release_base_id();
  void set_allocated_base_id(std::string* value);

  private:
  const std::string& _internal_base_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base_id(
      const std::string& value);
  std::string* _internal_mutable_base_id();

  public:
  // .valhalla.DirectionsLeg.GuidanceView.Type type = 2;
  void clear_type() ;
  ::valhalla::DirectionsLeg_GuidanceView_Type type() const;
  void set_type(::valhalla::DirectionsLeg_GuidanceView_Type value);

  private:
  ::valhalla::DirectionsLeg_GuidanceView_Type _internal_type() const;
  void _internal_set_type(::valhalla::DirectionsLeg_GuidanceView_Type value);

  public:
  // @@protoc_insertion_point(class_scope:valhalla.DirectionsLeg.GuidanceView)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      69, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> overlay_ids_;
    ::google::protobuf::internal::ArenaStringPtr data_id_;
    ::google::protobuf::internal::ArenaStringPtr base_id_;
    int type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_directions_2eproto;
};// -------------------------------------------------------------------

class DirectionsLeg_Maneuver final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.DirectionsLeg.Maneuver) */ {
 public:
  inline DirectionsLeg_Maneuver() : DirectionsLeg_Maneuver(nullptr) {}
  ~DirectionsLeg_Maneuver() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DirectionsLeg_Maneuver(::google::protobuf::internal::ConstantInitialized);

  inline DirectionsLeg_Maneuver(const DirectionsLeg_Maneuver& from)
      : DirectionsLeg_Maneuver(nullptr, from) {}
  DirectionsLeg_Maneuver(DirectionsLeg_Maneuver&& from) noexcept
    : DirectionsLeg_Maneuver() {
    *this = ::std::move(from);
  }

  inline DirectionsLeg_Maneuver& operator=(const DirectionsLeg_Maneuver& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectionsLeg_Maneuver& operator=(DirectionsLeg_Maneuver&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DirectionsLeg_Maneuver& default_instance() {
    return *internal_default_instance();
  }
  static inline const DirectionsLeg_Maneuver* internal_default_instance() {
    return reinterpret_cast<const DirectionsLeg_Maneuver*>(
               &_DirectionsLeg_Maneuver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DirectionsLeg_Maneuver& a, DirectionsLeg_Maneuver& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectionsLeg_Maneuver* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectionsLeg_Maneuver* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DirectionsLeg_Maneuver* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DirectionsLeg_Maneuver>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const DirectionsLeg_Maneuver& from);
  void MergeFrom(const DirectionsLeg_Maneuver& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DirectionsLeg_Maneuver* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.DirectionsLeg.Maneuver";
  }
  protected:
  explicit DirectionsLeg_Maneuver(::google::protobuf::Arena* arena);
  DirectionsLeg_Maneuver(::google::protobuf::Arena* arena, const DirectionsLeg_Maneuver& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using CardinalDirection = DirectionsLeg_Maneuver_CardinalDirection;
  static constexpr CardinalDirection kNorth = DirectionsLeg_Maneuver_CardinalDirection_kNorth;
  static constexpr CardinalDirection kNorthEast = DirectionsLeg_Maneuver_CardinalDirection_kNorthEast;
  static constexpr CardinalDirection kEast = DirectionsLeg_Maneuver_CardinalDirection_kEast;
  static constexpr CardinalDirection kSouthEast = DirectionsLeg_Maneuver_CardinalDirection_kSouthEast;
  static constexpr CardinalDirection kSouth = DirectionsLeg_Maneuver_CardinalDirection_kSouth;
  static constexpr CardinalDirection kSouthWest = DirectionsLeg_Maneuver_CardinalDirection_kSouthWest;
  static constexpr CardinalDirection kWest = DirectionsLeg_Maneuver_CardinalDirection_kWest;
  static constexpr CardinalDirection kNorthWest = DirectionsLeg_Maneuver_CardinalDirection_kNorthWest;
  static inline bool CardinalDirection_IsValid(int value) {
    return DirectionsLeg_Maneuver_CardinalDirection_IsValid(value);
  }
  static constexpr CardinalDirection CardinalDirection_MIN = DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_MIN;
  static constexpr CardinalDirection CardinalDirection_MAX = DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_MAX;
  static constexpr int CardinalDirection_ARRAYSIZE = DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_ARRAYSIZE;
  template <typename T>
  static inline const std::string& CardinalDirection_Name(T value) {
    return DirectionsLeg_Maneuver_CardinalDirection_Name(value);
  }
  static inline bool CardinalDirection_Parse(absl::string_view name, CardinalDirection* value) {
    return DirectionsLeg_Maneuver_CardinalDirection_Parse(name, value);
  }

  using Type = DirectionsLeg_Maneuver_Type;
  static constexpr Type kNone = DirectionsLeg_Maneuver_Type_kNone;
  static constexpr Type kStart = DirectionsLeg_Maneuver_Type_kStart;
  static constexpr Type kStartRight = DirectionsLeg_Maneuver_Type_kStartRight;
  static constexpr Type kStartLeft = DirectionsLeg_Maneuver_Type_kStartLeft;
  static constexpr Type kDestination = DirectionsLeg_Maneuver_Type_kDestination;
  static constexpr Type kDestinationRight = DirectionsLeg_Maneuver_Type_kDestinationRight;
  static constexpr Type kDestinationLeft = DirectionsLeg_Maneuver_Type_kDestinationLeft;
  static constexpr Type kBecomes = DirectionsLeg_Maneuver_Type_kBecomes;
  static constexpr Type kContinue = DirectionsLeg_Maneuver_Type_kContinue;
  static constexpr Type kSlightRight = DirectionsLeg_Maneuver_Type_kSlightRight;
  static constexpr Type kRight = DirectionsLeg_Maneuver_Type_kRight;
  static constexpr Type kSharpRight = DirectionsLeg_Maneuver_Type_kSharpRight;
  static constexpr Type kUturnRight = DirectionsLeg_Maneuver_Type_kUturnRight;
  static constexpr Type kUturnLeft = DirectionsLeg_Maneuver_Type_kUturnLeft;
  static constexpr Type kSharpLeft = DirectionsLeg_Maneuver_Type_kSharpLeft;
  static constexpr Type kLeft = DirectionsLeg_Maneuver_Type_kLeft;
  static constexpr Type kSlightLeft = DirectionsLeg_Maneuver_Type_kSlightLeft;
  static constexpr Type kRampStraight = DirectionsLeg_Maneuver_Type_kRampStraight;
  static constexpr Type kRampRight = DirectionsLeg_Maneuver_Type_kRampRight;
  static constexpr Type kRampLeft = DirectionsLeg_Maneuver_Type_kRampLeft;
  static constexpr Type kExitRight = DirectionsLeg_Maneuver_Type_kExitRight;
  static constexpr Type kExitLeft = DirectionsLeg_Maneuver_Type_kExitLeft;
  static constexpr Type kStayStraight = DirectionsLeg_Maneuver_Type_kStayStraight;
  static constexpr Type kStayRight = DirectionsLeg_Maneuver_Type_kStayRight;
  static constexpr Type kStayLeft = DirectionsLeg_Maneuver_Type_kStayLeft;
  static constexpr Type kMerge = DirectionsLeg_Maneuver_Type_kMerge;
  static constexpr Type kRoundaboutEnter = DirectionsLeg_Maneuver_Type_kRoundaboutEnter;
  static constexpr Type kRoundaboutExit = DirectionsLeg_Maneuver_Type_kRoundaboutExit;
  static constexpr Type kFerryEnter = DirectionsLeg_Maneuver_Type_kFerryEnter;
  static constexpr Type kFerryExit = DirectionsLeg_Maneuver_Type_kFerryExit;
  static constexpr Type kTransit = DirectionsLeg_Maneuver_Type_kTransit;
  static constexpr Type kTransitTransfer = DirectionsLeg_Maneuver_Type_kTransitTransfer;
  static constexpr Type kTransitRemainOn = DirectionsLeg_Maneuver_Type_kTransitRemainOn;
  static constexpr Type kTransitConnectionStart = DirectionsLeg_Maneuver_Type_kTransitConnectionStart;
  static constexpr Type kTransitConnectionTransfer = DirectionsLeg_Maneuver_Type_kTransitConnectionTransfer;
  static constexpr Type kTransitConnectionDestination = DirectionsLeg_Maneuver_Type_kTransitConnectionDestination;
  static constexpr Type kPostTransitConnectionDestination = DirectionsLeg_Maneuver_Type_kPostTransitConnectionDestination;
  static constexpr Type kMergeRight = DirectionsLeg_Maneuver_Type_kMergeRight;
  static constexpr Type kMergeLeft = DirectionsLeg_Maneuver_Type_kMergeLeft;
  static constexpr Type kElevatorEnter = DirectionsLeg_Maneuver_Type_kElevatorEnter;
  static constexpr Type kStepsEnter = DirectionsLeg_Maneuver_Type_kStepsEnter;
  static constexpr Type kEscalatorEnter = DirectionsLeg_Maneuver_Type_kEscalatorEnter;
  static constexpr Type kBuildingEnter = DirectionsLeg_Maneuver_Type_kBuildingEnter;
  static constexpr Type kBuildingExit = DirectionsLeg_Maneuver_Type_kBuildingExit;
  static inline bool Type_IsValid(int value) {
    return DirectionsLeg_Maneuver_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = DirectionsLeg_Maneuver_Type_Type_MIN;
  static constexpr Type Type_MAX = DirectionsLeg_Maneuver_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = DirectionsLeg_Maneuver_Type_Type_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return DirectionsLeg_Maneuver_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return DirectionsLeg_Maneuver_Type_Parse(name, value);
  }

  using BssManeuverType = DirectionsLeg_Maneuver_BssManeuverType;
  static constexpr BssManeuverType kNoneAction = DirectionsLeg_Maneuver_BssManeuverType_kNoneAction;
  static constexpr BssManeuverType kRentBikeAtBikeShare = DirectionsLeg_Maneuver_BssManeuverType_kRentBikeAtBikeShare;
  static constexpr BssManeuverType kReturnBikeAtBikeShare = DirectionsLeg_Maneuver_BssManeuverType_kReturnBikeAtBikeShare;
  static inline bool BssManeuverType_IsValid(int value) {
    return DirectionsLeg_Maneuver_BssManeuverType_IsValid(value);
  }
  static constexpr BssManeuverType BssManeuverType_MIN = DirectionsLeg_Maneuver_BssManeuverType_BssManeuverType_MIN;
  static constexpr BssManeuverType BssManeuverType_MAX = DirectionsLeg_Maneuver_BssManeuverType_BssManeuverType_MAX;
  static constexpr int BssManeuverType_ARRAYSIZE = DirectionsLeg_Maneuver_BssManeuverType_BssManeuverType_ARRAYSIZE;
  template <typename T>
  static inline const std::string& BssManeuverType_Name(T value) {
    return DirectionsLeg_Maneuver_BssManeuverType_Name(value);
  }
  static inline bool BssManeuverType_Parse(absl::string_view name, BssManeuverType* value) {
    return DirectionsLeg_Maneuver_BssManeuverType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStreetNameFieldNumber = 3,
    kBeginStreetNameFieldNumber = 15,
    kRoundaboutExitStreetNamesFieldNumber = 32,
    kGuidanceViewsFieldNumber = 35,
    kLandmarksFieldNumber = 41,
    kTextInstructionFieldNumber = 2,
    kVerbalTransitionAlertInstructionFieldNumber = 12,
    kVerbalPreTransitionInstructionFieldNumber = 13,
    kVerbalPostTransitionInstructionFieldNumber = 14,
    kDepartInstructionFieldNumber = 18,
    kVerbalDepartInstructionFieldNumber = 19,
    kArriveInstructionFieldNumber = 20,
    kVerbalArriveInstructionFieldNumber = 21,
    kVerbalSuccinctTransitionInstructionFieldNumber = 37,
    kSignFieldNumber = 16,
    kTransitInfoFieldNumber = 22,
    kBssInfoFieldNumber = 38,
    kTypeFieldNumber = 1,
    kLengthFieldNumber = 4,
    kTimeFieldNumber = 5,
    kBeginCardinalDirectionFieldNumber = 6,
    kBeginHeadingFieldNumber = 7,
    kBeginShapeIndexFieldNumber = 8,
    kEndShapeIndexFieldNumber = 9,
    kRoundaboutExitCountFieldNumber = 17,
    kPortionsTollFieldNumber = 10,
    kPortionsUnpavedFieldNumber = 11,
    kVerbalMultiCueFieldNumber = 23,
    kToStayOnFieldNumber = 31,
    kTravelModeFieldNumber = 24,
    kVehicleTypeFieldNumber = 25,
    kPedestrianTypeFieldNumber = 26,
    kBicycleTypeFieldNumber = 27,
    kTransitTypeFieldNumber = 28,
    kBeginPathIndexFieldNumber = 29,
    kEndPathIndexFieldNumber = 30,
    kTurnDegreeFieldNumber = 33,
    kBssManeuverTypeFieldNumber = 36,
    kHasTimeRestrictionsFieldNumber = 34,
    kPortionsHighwayFieldNumber = 39,
    kPortionsFerryFieldNumber = 40,
  };
  // repeated .valhalla.StreetName street_name = 3;
  int street_name_size() const;
  private:
  int _internal_street_name_size() const;

  public:
  void clear_street_name() ;
  ::valhalla::StreetName* mutable_street_name(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >*
      mutable_street_name();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>& _internal_street_name() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>* _internal_mutable_street_name();
  public:
  const ::valhalla::StreetName& street_name(int index) const;
  ::valhalla::StreetName* add_street_name();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >&
      street_name() const;
  // repeated .valhalla.StreetName begin_street_name = 15;
  int begin_street_name_size() const;
  private:
  int _internal_begin_street_name_size() const;

  public:
  void clear_begin_street_name() ;
  ::valhalla::StreetName* mutable_begin_street_name(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >*
      mutable_begin_street_name();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>& _internal_begin_street_name() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>* _internal_mutable_begin_street_name();
  public:
  const ::valhalla::StreetName& begin_street_name(int index) const;
  ::valhalla::StreetName* add_begin_street_name();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >&
      begin_street_name() const;
  // repeated .valhalla.StreetName roundabout_exit_street_names = 32;
  int roundabout_exit_street_names_size() const;
  private:
  int _internal_roundabout_exit_street_names_size() const;

  public:
  void clear_roundabout_exit_street_names() ;
  ::valhalla::StreetName* mutable_roundabout_exit_street_names(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >*
      mutable_roundabout_exit_street_names();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>& _internal_roundabout_exit_street_names() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>* _internal_mutable_roundabout_exit_street_names();
  public:
  const ::valhalla::StreetName& roundabout_exit_street_names(int index) const;
  ::valhalla::StreetName* add_roundabout_exit_street_names();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >&
      roundabout_exit_street_names() const;
  // repeated .valhalla.DirectionsLeg.GuidanceView guidance_views = 35;
  int guidance_views_size() const;
  private:
  int _internal_guidance_views_size() const;

  public:
  void clear_guidance_views() ;
  ::valhalla::DirectionsLeg_GuidanceView* mutable_guidance_views(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_GuidanceView >*
      mutable_guidance_views();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::DirectionsLeg_GuidanceView>& _internal_guidance_views() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::DirectionsLeg_GuidanceView>* _internal_mutable_guidance_views();
  public:
  const ::valhalla::DirectionsLeg_GuidanceView& guidance_views(int index) const;
  ::valhalla::DirectionsLeg_GuidanceView* add_guidance_views();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_GuidanceView >&
      guidance_views() const;
  // repeated .valhalla.RouteLandmark landmarks = 41;
  int landmarks_size() const;
  private:
  int _internal_landmarks_size() const;

  public:
  void clear_landmarks() ;
  ::valhalla::RouteLandmark* mutable_landmarks(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::RouteLandmark >*
      mutable_landmarks();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::RouteLandmark>& _internal_landmarks() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::RouteLandmark>* _internal_mutable_landmarks();
  public:
  const ::valhalla::RouteLandmark& landmarks(int index) const;
  ::valhalla::RouteLandmark* add_landmarks();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::RouteLandmark >&
      landmarks() const;
  // string text_instruction = 2;
  void clear_text_instruction() ;
  const std::string& text_instruction() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text_instruction(Arg_&& arg, Args_... args);
  std::string* mutable_text_instruction();
  PROTOBUF_NODISCARD std::string* release_text_instruction();
  void set_allocated_text_instruction(std::string* value);

  private:
  const std::string& _internal_text_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text_instruction(
      const std::string& value);
  std::string* _internal_mutable_text_instruction();

  public:
  // string verbal_transition_alert_instruction = 12;
  void clear_verbal_transition_alert_instruction() ;
  const std::string& verbal_transition_alert_instruction() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_verbal_transition_alert_instruction(Arg_&& arg, Args_... args);
  std::string* mutable_verbal_transition_alert_instruction();
  PROTOBUF_NODISCARD std::string* release_verbal_transition_alert_instruction();
  void set_allocated_verbal_transition_alert_instruction(std::string* value);

  private:
  const std::string& _internal_verbal_transition_alert_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verbal_transition_alert_instruction(
      const std::string& value);
  std::string* _internal_mutable_verbal_transition_alert_instruction();

  public:
  // string verbal_pre_transition_instruction = 13;
  void clear_verbal_pre_transition_instruction() ;
  const std::string& verbal_pre_transition_instruction() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_verbal_pre_transition_instruction(Arg_&& arg, Args_... args);
  std::string* mutable_verbal_pre_transition_instruction();
  PROTOBUF_NODISCARD std::string* release_verbal_pre_transition_instruction();
  void set_allocated_verbal_pre_transition_instruction(std::string* value);

  private:
  const std::string& _internal_verbal_pre_transition_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verbal_pre_transition_instruction(
      const std::string& value);
  std::string* _internal_mutable_verbal_pre_transition_instruction();

  public:
  // string verbal_post_transition_instruction = 14;
  void clear_verbal_post_transition_instruction() ;
  const std::string& verbal_post_transition_instruction() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_verbal_post_transition_instruction(Arg_&& arg, Args_... args);
  std::string* mutable_verbal_post_transition_instruction();
  PROTOBUF_NODISCARD std::string* release_verbal_post_transition_instruction();
  void set_allocated_verbal_post_transition_instruction(std::string* value);

  private:
  const std::string& _internal_verbal_post_transition_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verbal_post_transition_instruction(
      const std::string& value);
  std::string* _internal_mutable_verbal_post_transition_instruction();

  public:
  // string depart_instruction = 18;
  void clear_depart_instruction() ;
  const std::string& depart_instruction() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_depart_instruction(Arg_&& arg, Args_... args);
  std::string* mutable_depart_instruction();
  PROTOBUF_NODISCARD std::string* release_depart_instruction();
  void set_allocated_depart_instruction(std::string* value);

  private:
  const std::string& _internal_depart_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_depart_instruction(
      const std::string& value);
  std::string* _internal_mutable_depart_instruction();

  public:
  // string verbal_depart_instruction = 19;
  void clear_verbal_depart_instruction() ;
  const std::string& verbal_depart_instruction() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_verbal_depart_instruction(Arg_&& arg, Args_... args);
  std::string* mutable_verbal_depart_instruction();
  PROTOBUF_NODISCARD std::string* release_verbal_depart_instruction();
  void set_allocated_verbal_depart_instruction(std::string* value);

  private:
  const std::string& _internal_verbal_depart_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verbal_depart_instruction(
      const std::string& value);
  std::string* _internal_mutable_verbal_depart_instruction();

  public:
  // string arrive_instruction = 20;
  void clear_arrive_instruction() ;
  const std::string& arrive_instruction() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_arrive_instruction(Arg_&& arg, Args_... args);
  std::string* mutable_arrive_instruction();
  PROTOBUF_NODISCARD std::string* release_arrive_instruction();
  void set_allocated_arrive_instruction(std::string* value);

  private:
  const std::string& _internal_arrive_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_arrive_instruction(
      const std::string& value);
  std::string* _internal_mutable_arrive_instruction();

  public:
  // string verbal_arrive_instruction = 21;
  void clear_verbal_arrive_instruction() ;
  const std::string& verbal_arrive_instruction() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_verbal_arrive_instruction(Arg_&& arg, Args_... args);
  std::string* mutable_verbal_arrive_instruction();
  PROTOBUF_NODISCARD std::string* release_verbal_arrive_instruction();
  void set_allocated_verbal_arrive_instruction(std::string* value);

  private:
  const std::string& _internal_verbal_arrive_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verbal_arrive_instruction(
      const std::string& value);
  std::string* _internal_mutable_verbal_arrive_instruction();

  public:
  // string verbal_succinct_transition_instruction = 37;
  void clear_verbal_succinct_transition_instruction() ;
  const std::string& verbal_succinct_transition_instruction() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_verbal_succinct_transition_instruction(Arg_&& arg, Args_... args);
  std::string* mutable_verbal_succinct_transition_instruction();
  PROTOBUF_NODISCARD std::string* release_verbal_succinct_transition_instruction();
  void set_allocated_verbal_succinct_transition_instruction(std::string* value);

  private:
  const std::string& _internal_verbal_succinct_transition_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verbal_succinct_transition_instruction(
      const std::string& value);
  std::string* _internal_mutable_verbal_succinct_transition_instruction();

  public:
  // .valhalla.TripSign sign = 16;
  bool has_sign() const;
  void clear_sign() ;
  const ::valhalla::TripSign& sign() const;
  PROTOBUF_NODISCARD ::valhalla::TripSign* release_sign();
  ::valhalla::TripSign* mutable_sign();
  void set_allocated_sign(::valhalla::TripSign* value);
  void unsafe_arena_set_allocated_sign(::valhalla::TripSign* value);
  ::valhalla::TripSign* unsafe_arena_release_sign();

  private:
  const ::valhalla::TripSign& _internal_sign() const;
  ::valhalla::TripSign* _internal_mutable_sign();

  public:
  // .valhalla.TransitRouteInfo transit_info = 22;
  bool has_transit_info() const;
  void clear_transit_info() ;
  const ::valhalla::TransitRouteInfo& transit_info() const;
  PROTOBUF_NODISCARD ::valhalla::TransitRouteInfo* release_transit_info();
  ::valhalla::TransitRouteInfo* mutable_transit_info();
  void set_allocated_transit_info(::valhalla::TransitRouteInfo* value);
  void unsafe_arena_set_allocated_transit_info(::valhalla::TransitRouteInfo* value);
  ::valhalla::TransitRouteInfo* unsafe_arena_release_transit_info();

  private:
  const ::valhalla::TransitRouteInfo& _internal_transit_info() const;
  ::valhalla::TransitRouteInfo* _internal_mutable_transit_info();

  public:
  // .valhalla.BikeShareStationInfo bss_info = 38;
  bool has_bss_info() const;
  void clear_bss_info() ;
  const ::valhalla::BikeShareStationInfo& bss_info() const;
  PROTOBUF_NODISCARD ::valhalla::BikeShareStationInfo* release_bss_info();
  ::valhalla::BikeShareStationInfo* mutable_bss_info();
  void set_allocated_bss_info(::valhalla::BikeShareStationInfo* value);
  void unsafe_arena_set_allocated_bss_info(::valhalla::BikeShareStationInfo* value);
  ::valhalla::BikeShareStationInfo* unsafe_arena_release_bss_info();

  private:
  const ::valhalla::BikeShareStationInfo& _internal_bss_info() const;
  ::valhalla::BikeShareStationInfo* _internal_mutable_bss_info();

  public:
  // .valhalla.DirectionsLeg.Maneuver.Type type = 1;
  void clear_type() ;
  ::valhalla::DirectionsLeg_Maneuver_Type type() const;
  void set_type(::valhalla::DirectionsLeg_Maneuver_Type value);

  private:
  ::valhalla::DirectionsLeg_Maneuver_Type _internal_type() const;
  void _internal_set_type(::valhalla::DirectionsLeg_Maneuver_Type value);

  public:
  // float length = 4;
  void clear_length() ;
  float length() const;
  void set_length(float value);

  private:
  float _internal_length() const;
  void _internal_set_length(float value);

  public:
  // double time = 5;
  void clear_time() ;
  double time() const;
  void set_time(double value);

  private:
  double _internal_time() const;
  void _internal_set_time(double value);

  public:
  // .valhalla.DirectionsLeg.Maneuver.CardinalDirection begin_cardinal_direction = 6;
  void clear_begin_cardinal_direction() ;
  ::valhalla::DirectionsLeg_Maneuver_CardinalDirection begin_cardinal_direction() const;
  void set_begin_cardinal_direction(::valhalla::DirectionsLeg_Maneuver_CardinalDirection value);

  private:
  ::valhalla::DirectionsLeg_Maneuver_CardinalDirection _internal_begin_cardinal_direction() const;
  void _internal_set_begin_cardinal_direction(::valhalla::DirectionsLeg_Maneuver_CardinalDirection value);

  public:
  // uint32 begin_heading = 7;
  void clear_begin_heading() ;
  ::uint32_t begin_heading() const;
  void set_begin_heading(::uint32_t value);

  private:
  ::uint32_t _internal_begin_heading() const;
  void _internal_set_begin_heading(::uint32_t value);

  public:
  // uint32 begin_shape_index = 8;
  void clear_begin_shape_index() ;
  ::uint32_t begin_shape_index() const;
  void set_begin_shape_index(::uint32_t value);

  private:
  ::uint32_t _internal_begin_shape_index() const;
  void _internal_set_begin_shape_index(::uint32_t value);

  public:
  // uint32 end_shape_index = 9;
  void clear_end_shape_index() ;
  ::uint32_t end_shape_index() const;
  void set_end_shape_index(::uint32_t value);

  private:
  ::uint32_t _internal_end_shape_index() const;
  void _internal_set_end_shape_index(::uint32_t value);

  public:
  // uint32 roundabout_exit_count = 17;
  void clear_roundabout_exit_count() ;
  ::uint32_t roundabout_exit_count() const;
  void set_roundabout_exit_count(::uint32_t value);

  private:
  ::uint32_t _internal_roundabout_exit_count() const;
  void _internal_set_roundabout_exit_count(::uint32_t value);

  public:
  // bool portions_toll = 10;
  void clear_portions_toll() ;
  bool portions_toll() const;
  void set_portions_toll(bool value);

  private:
  bool _internal_portions_toll() const;
  void _internal_set_portions_toll(bool value);

  public:
  // bool portions_unpaved = 11;
  void clear_portions_unpaved() ;
  bool portions_unpaved() const;
  void set_portions_unpaved(bool value);

  private:
  bool _internal_portions_unpaved() const;
  void _internal_set_portions_unpaved(bool value);

  public:
  // bool verbal_multi_cue = 23;
  void clear_verbal_multi_cue() ;
  bool verbal_multi_cue() const;
  void set_verbal_multi_cue(bool value);

  private:
  bool _internal_verbal_multi_cue() const;
  void _internal_set_verbal_multi_cue(bool value);

  public:
  // bool to_stay_on = 31;
  void clear_to_stay_on() ;
  bool to_stay_on() const;
  void set_to_stay_on(bool value);

  private:
  bool _internal_to_stay_on() const;
  void _internal_set_to_stay_on(bool value);

  public:
  // .valhalla.TravelMode travel_mode = 24;
  void clear_travel_mode() ;
  ::valhalla::TravelMode travel_mode() const;
  void set_travel_mode(::valhalla::TravelMode value);

  private:
  ::valhalla::TravelMode _internal_travel_mode() const;
  void _internal_set_travel_mode(::valhalla::TravelMode value);

  public:
  // .valhalla.VehicleType vehicle_type = 25;
  void clear_vehicle_type() ;
  ::valhalla::VehicleType vehicle_type() const;
  void set_vehicle_type(::valhalla::VehicleType value);

  private:
  ::valhalla::VehicleType _internal_vehicle_type() const;
  void _internal_set_vehicle_type(::valhalla::VehicleType value);

  public:
  // .valhalla.PedestrianType pedestrian_type = 26;
  void clear_pedestrian_type() ;
  ::valhalla::PedestrianType pedestrian_type() const;
  void set_pedestrian_type(::valhalla::PedestrianType value);

  private:
  ::valhalla::PedestrianType _internal_pedestrian_type() const;
  void _internal_set_pedestrian_type(::valhalla::PedestrianType value);

  public:
  // .valhalla.BicycleType bicycle_type = 27;
  void clear_bicycle_type() ;
  ::valhalla::BicycleType bicycle_type() const;
  void set_bicycle_type(::valhalla::BicycleType value);

  private:
  ::valhalla::BicycleType _internal_bicycle_type() const;
  void _internal_set_bicycle_type(::valhalla::BicycleType value);

  public:
  // .valhalla.TransitType transit_type = 28;
  void clear_transit_type() ;
  ::valhalla::TransitType transit_type() const;
  void set_transit_type(::valhalla::TransitType value);

  private:
  ::valhalla::TransitType _internal_transit_type() const;
  void _internal_set_transit_type(::valhalla::TransitType value);

  public:
  // uint32 begin_path_index = 29;
  void clear_begin_path_index() ;
  ::uint32_t begin_path_index() const;
  void set_begin_path_index(::uint32_t value);

  private:
  ::uint32_t _internal_begin_path_index() const;
  void _internal_set_begin_path_index(::uint32_t value);

  public:
  // uint32 end_path_index = 30;
  void clear_end_path_index() ;
  ::uint32_t end_path_index() const;
  void set_end_path_index(::uint32_t value);

  private:
  ::uint32_t _internal_end_path_index() const;
  void _internal_set_end_path_index(::uint32_t value);

  public:
  // uint32 turn_degree = 33;
  void clear_turn_degree() ;
  ::uint32_t turn_degree() const;
  void set_turn_degree(::uint32_t value);

  private:
  ::uint32_t _internal_turn_degree() const;
  void _internal_set_turn_degree(::uint32_t value);

  public:
  // .valhalla.DirectionsLeg.Maneuver.BssManeuverType bss_maneuver_type = 36;
  void clear_bss_maneuver_type() ;
  ::valhalla::DirectionsLeg_Maneuver_BssManeuverType bss_maneuver_type() const;
  void set_bss_maneuver_type(::valhalla::DirectionsLeg_Maneuver_BssManeuverType value);

  private:
  ::valhalla::DirectionsLeg_Maneuver_BssManeuverType _internal_bss_maneuver_type() const;
  void _internal_set_bss_maneuver_type(::valhalla::DirectionsLeg_Maneuver_BssManeuverType value);

  public:
  // bool has_time_restrictions = 34;
  void clear_has_time_restrictions() ;
  bool has_time_restrictions() const;
  void set_has_time_restrictions(bool value);

  private:
  bool _internal_has_time_restrictions() const;
  void _internal_set_has_time_restrictions(bool value);

  public:
  // bool portions_highway = 39;
  void clear_portions_highway() ;
  bool portions_highway() const;
  void set_portions_highway(bool value);

  private:
  bool _internal_portions_highway() const;
  void _internal_set_portions_highway(bool value);

  public:
  // bool portions_ferry = 40;
  void clear_portions_ferry() ;
  bool portions_ferry() const;
  void set_portions_ferry(bool value);

  private:
  bool _internal_portions_ferry() const;
  void _internal_set_portions_ferry(bool value);

  public:
  // @@protoc_insertion_point(class_scope:valhalla.DirectionsLeg.Maneuver)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 41, 8,
      322, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName > street_name_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName > begin_street_name_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName > roundabout_exit_street_names_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_GuidanceView > guidance_views_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::RouteLandmark > landmarks_;
    ::google::protobuf::internal::ArenaStringPtr text_instruction_;
    ::google::protobuf::internal::ArenaStringPtr verbal_transition_alert_instruction_;
    ::google::protobuf::internal::ArenaStringPtr verbal_pre_transition_instruction_;
    ::google::protobuf::internal::ArenaStringPtr verbal_post_transition_instruction_;
    ::google::protobuf::internal::ArenaStringPtr depart_instruction_;
    ::google::protobuf::internal::ArenaStringPtr verbal_depart_instruction_;
    ::google::protobuf::internal::ArenaStringPtr arrive_instruction_;
    ::google::protobuf::internal::ArenaStringPtr verbal_arrive_instruction_;
    ::google::protobuf::internal::ArenaStringPtr verbal_succinct_transition_instruction_;
    ::valhalla::TripSign* sign_;
    ::valhalla::TransitRouteInfo* transit_info_;
    ::valhalla::BikeShareStationInfo* bss_info_;
    int type_;
    float length_;
    double time_;
    int begin_cardinal_direction_;
    ::uint32_t begin_heading_;
    ::uint32_t begin_shape_index_;
    ::uint32_t end_shape_index_;
    ::uint32_t roundabout_exit_count_;
    bool portions_toll_;
    bool portions_unpaved_;
    bool verbal_multi_cue_;
    bool to_stay_on_;
    int travel_mode_;
    int vehicle_type_;
    int pedestrian_type_;
    int bicycle_type_;
    int transit_type_;
    ::uint32_t begin_path_index_;
    ::uint32_t end_path_index_;
    ::uint32_t turn_degree_;
    int bss_maneuver_type_;
    bool has_time_restrictions_;
    bool portions_highway_;
    bool portions_ferry_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_directions_2eproto;
};// -------------------------------------------------------------------

class DirectionsLeg final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.DirectionsLeg) */ {
 public:
  inline DirectionsLeg() : DirectionsLeg(nullptr) {}
  ~DirectionsLeg() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DirectionsLeg(::google::protobuf::internal::ConstantInitialized);

  inline DirectionsLeg(const DirectionsLeg& from)
      : DirectionsLeg(nullptr, from) {}
  DirectionsLeg(DirectionsLeg&& from) noexcept
    : DirectionsLeg() {
    *this = ::std::move(from);
  }

  inline DirectionsLeg& operator=(const DirectionsLeg& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectionsLeg& operator=(DirectionsLeg&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DirectionsLeg& default_instance() {
    return *internal_default_instance();
  }
  static inline const DirectionsLeg* internal_default_instance() {
    return reinterpret_cast<const DirectionsLeg*>(
               &_DirectionsLeg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DirectionsLeg& a, DirectionsLeg& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectionsLeg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectionsLeg* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DirectionsLeg* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DirectionsLeg>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const DirectionsLeg& from);
  void MergeFrom(const DirectionsLeg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DirectionsLeg* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.DirectionsLeg";
  }
  protected:
  explicit DirectionsLeg(::google::protobuf::Arena* arena);
  DirectionsLeg(::google::protobuf::Arena* arena, const DirectionsLeg& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using GuidanceView = DirectionsLeg_GuidanceView;
  using Maneuver = DirectionsLeg_Maneuver;

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 4,
    kManeuverFieldNumber = 6,
    kShapeFieldNumber = 7,
    kSummaryFieldNumber = 5,
    kTripIdFieldNumber = 1,
    kLegIdFieldNumber = 2,
    kLegCountFieldNumber = 3,
  };
  // repeated .valhalla.Location location = 4;
  int location_size() const;
  private:
  int _internal_location_size() const;

  public:
  void clear_location() ;
  ::valhalla::Location* mutable_location(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
      mutable_location();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::Location>& _internal_location() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::Location>* _internal_mutable_location();
  public:
  const ::valhalla::Location& location(int index) const;
  ::valhalla::Location* add_location();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
      location() const;
  // repeated .valhalla.DirectionsLeg.Maneuver maneuver = 6;
  int maneuver_size() const;
  private:
  int _internal_maneuver_size() const;

  public:
  void clear_maneuver() ;
  ::valhalla::DirectionsLeg_Maneuver* mutable_maneuver(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver >*
      mutable_maneuver();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::DirectionsLeg_Maneuver>& _internal_maneuver() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::DirectionsLeg_Maneuver>* _internal_mutable_maneuver();
  public:
  const ::valhalla::DirectionsLeg_Maneuver& maneuver(int index) const;
  ::valhalla::DirectionsLeg_Maneuver* add_maneuver();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver >&
      maneuver() const;
  // string shape = 7;
  void clear_shape() ;
  const std::string& shape() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_shape(Arg_&& arg, Args_... args);
  std::string* mutable_shape();
  PROTOBUF_NODISCARD std::string* release_shape();
  void set_allocated_shape(std::string* value);

  private:
  const std::string& _internal_shape() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shape(
      const std::string& value);
  std::string* _internal_mutable_shape();

  public:
  // .valhalla.Summary summary = 5;
  bool has_summary() const;
  void clear_summary() ;
  const ::valhalla::Summary& summary() const;
  PROTOBUF_NODISCARD ::valhalla::Summary* release_summary();
  ::valhalla::Summary* mutable_summary();
  void set_allocated_summary(::valhalla::Summary* value);
  void unsafe_arena_set_allocated_summary(::valhalla::Summary* value);
  ::valhalla::Summary* unsafe_arena_release_summary();

  private:
  const ::valhalla::Summary& _internal_summary() const;
  ::valhalla::Summary* _internal_mutable_summary();

  public:
  // uint64 trip_id = 1;
  void clear_trip_id() ;
  ::uint64_t trip_id() const;
  void set_trip_id(::uint64_t value);

  private:
  ::uint64_t _internal_trip_id() const;
  void _internal_set_trip_id(::uint64_t value);

  public:
  // uint32 leg_id = 2;
  void clear_leg_id() ;
  ::uint32_t leg_id() const;
  void set_leg_id(::uint32_t value);

  private:
  ::uint32_t _internal_leg_id() const;
  void _internal_set_leg_id(::uint32_t value);

  public:
  // uint32 leg_count = 3;
  void clear_leg_count() ;
  ::uint32_t leg_count() const;
  void set_leg_count(::uint32_t value);

  private:
  ::uint32_t _internal_leg_count() const;
  void _internal_set_leg_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:valhalla.DirectionsLeg)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 3,
      36, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::Location > location_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver > maneuver_;
    ::google::protobuf::internal::ArenaStringPtr shape_;
    ::valhalla::Summary* summary_;
    ::uint64_t trip_id_;
    ::uint32_t leg_id_;
    ::uint32_t leg_count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_directions_2eproto;
};// -------------------------------------------------------------------

class DirectionsRoute final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.DirectionsRoute) */ {
 public:
  inline DirectionsRoute() : DirectionsRoute(nullptr) {}
  ~DirectionsRoute() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DirectionsRoute(::google::protobuf::internal::ConstantInitialized);

  inline DirectionsRoute(const DirectionsRoute& from)
      : DirectionsRoute(nullptr, from) {}
  DirectionsRoute(DirectionsRoute&& from) noexcept
    : DirectionsRoute() {
    *this = ::std::move(from);
  }

  inline DirectionsRoute& operator=(const DirectionsRoute& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectionsRoute& operator=(DirectionsRoute&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DirectionsRoute& default_instance() {
    return *internal_default_instance();
  }
  static inline const DirectionsRoute* internal_default_instance() {
    return reinterpret_cast<const DirectionsRoute*>(
               &_DirectionsRoute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DirectionsRoute& a, DirectionsRoute& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectionsRoute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectionsRoute* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DirectionsRoute* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DirectionsRoute>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const DirectionsRoute& from);
  void MergeFrom(const DirectionsRoute& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DirectionsRoute* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.DirectionsRoute";
  }
  protected:
  explicit DirectionsRoute(::google::protobuf::Arena* arena);
  DirectionsRoute(::google::protobuf::Arena* arena, const DirectionsRoute& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLegsFieldNumber = 1,
  };
  // repeated .valhalla.DirectionsLeg legs = 1;
  int legs_size() const;
  private:
  int _internal_legs_size() const;

  public:
  void clear_legs() ;
  ::valhalla::DirectionsLeg* mutable_legs(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg >*
      mutable_legs();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::DirectionsLeg>& _internal_legs() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::DirectionsLeg>* _internal_mutable_legs();
  public:
  const ::valhalla::DirectionsLeg& legs(int index) const;
  ::valhalla::DirectionsLeg* add_legs();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg >&
      legs() const;
  // @@protoc_insertion_point(class_scope:valhalla.DirectionsRoute)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg > legs_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_directions_2eproto;
};// -------------------------------------------------------------------

class Directions final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.Directions) */ {
 public:
  inline Directions() : Directions(nullptr) {}
  ~Directions() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Directions(::google::protobuf::internal::ConstantInitialized);

  inline Directions(const Directions& from)
      : Directions(nullptr, from) {}
  Directions(Directions&& from) noexcept
    : Directions() {
    *this = ::std::move(from);
  }

  inline Directions& operator=(const Directions& from) {
    CopyFrom(from);
    return *this;
  }
  inline Directions& operator=(Directions&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Directions& default_instance() {
    return *internal_default_instance();
  }
  static inline const Directions* internal_default_instance() {
    return reinterpret_cast<const Directions*>(
               &_Directions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Directions& a, Directions& b) {
    a.Swap(&b);
  }
  inline void Swap(Directions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Directions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Directions* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Directions>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Directions& from);
  void MergeFrom(const Directions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Directions* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.Directions";
  }
  protected:
  explicit Directions(::google::protobuf::Arena* arena);
  Directions(::google::protobuf::Arena* arena, const Directions& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoutesFieldNumber = 1,
  };
  // repeated .valhalla.DirectionsRoute routes = 1;
  int routes_size() const;
  private:
  int _internal_routes_size() const;

  public:
  void clear_routes() ;
  ::valhalla::DirectionsRoute* mutable_routes(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsRoute >*
      mutable_routes();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::DirectionsRoute>& _internal_routes() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::DirectionsRoute>* _internal_mutable_routes();
  public:
  const ::valhalla::DirectionsRoute& routes(int index) const;
  ::valhalla::DirectionsRoute* add_routes();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsRoute >&
      routes() const;
  // @@protoc_insertion_point(class_scope:valhalla.Directions)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsRoute > routes_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_directions_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// DirectionsLeg_GuidanceView

// string data_id = 1;
inline void DirectionsLeg_GuidanceView::clear_data_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_id_.ClearToEmpty();
}
inline const std::string& DirectionsLeg_GuidanceView::data_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.GuidanceView.data_id)
  return _internal_data_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DirectionsLeg_GuidanceView::set_data_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.data_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.GuidanceView.data_id)
}
inline std::string* DirectionsLeg_GuidanceView::mutable_data_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data_id();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.GuidanceView.data_id)
  return _s;
}
inline const std::string& DirectionsLeg_GuidanceView::_internal_data_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_id_.Get();
}
inline void DirectionsLeg_GuidanceView::_internal_set_data_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.data_id_.Set(value, GetArena());
}
inline std::string* DirectionsLeg_GuidanceView::_internal_mutable_data_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.data_id_.Mutable( GetArena());
}
inline std::string* DirectionsLeg_GuidanceView::release_data_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.GuidanceView.data_id)
  return _impl_.data_id_.Release();
}
inline void DirectionsLeg_GuidanceView::set_allocated_data_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_id_.IsDefault()) {
          _impl_.data_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.GuidanceView.data_id)
}

// .valhalla.DirectionsLeg.GuidanceView.Type type = 2;
inline void DirectionsLeg_GuidanceView::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::valhalla::DirectionsLeg_GuidanceView_Type DirectionsLeg_GuidanceView::type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.GuidanceView.type)
  return _internal_type();
}
inline void DirectionsLeg_GuidanceView::set_type(::valhalla::DirectionsLeg_GuidanceView_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.GuidanceView.type)
}
inline ::valhalla::DirectionsLeg_GuidanceView_Type DirectionsLeg_GuidanceView::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::DirectionsLeg_GuidanceView_Type>(_impl_.type_);
}
inline void DirectionsLeg_GuidanceView::_internal_set_type(::valhalla::DirectionsLeg_GuidanceView_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// string base_id = 3;
inline void DirectionsLeg_GuidanceView::clear_base_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.base_id_.ClearToEmpty();
}
inline const std::string& DirectionsLeg_GuidanceView::base_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.GuidanceView.base_id)
  return _internal_base_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DirectionsLeg_GuidanceView::set_base_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.base_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.GuidanceView.base_id)
}
inline std::string* DirectionsLeg_GuidanceView::mutable_base_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_base_id();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.GuidanceView.base_id)
  return _s;
}
inline const std::string& DirectionsLeg_GuidanceView::_internal_base_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.base_id_.Get();
}
inline void DirectionsLeg_GuidanceView::_internal_set_base_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.base_id_.Set(value, GetArena());
}
inline std::string* DirectionsLeg_GuidanceView::_internal_mutable_base_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.base_id_.Mutable( GetArena());
}
inline std::string* DirectionsLeg_GuidanceView::release_base_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.GuidanceView.base_id)
  return _impl_.base_id_.Release();
}
inline void DirectionsLeg_GuidanceView::set_allocated_base_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.base_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.base_id_.IsDefault()) {
          _impl_.base_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.GuidanceView.base_id)
}

// repeated string overlay_ids = 4;
inline int DirectionsLeg_GuidanceView::_internal_overlay_ids_size() const {
  return _internal_overlay_ids().size();
}
inline int DirectionsLeg_GuidanceView::overlay_ids_size() const {
  return _internal_overlay_ids_size();
}
inline void DirectionsLeg_GuidanceView::clear_overlay_ids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.overlay_ids_.Clear();
}
inline std::string* DirectionsLeg_GuidanceView::add_overlay_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_overlay_ids()->Add();
  // @@protoc_insertion_point(field_add_mutable:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
  return _s;
}
inline const std::string& DirectionsLeg_GuidanceView::overlay_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
  return _internal_overlay_ids().Get(index);
}
inline std::string* DirectionsLeg_GuidanceView::mutable_overlay_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
  return _internal_mutable_overlay_ids()->Mutable(index);
}
inline void DirectionsLeg_GuidanceView::set_overlay_ids(int index, const std::string& value) {
  _internal_mutable_overlay_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline void DirectionsLeg_GuidanceView::set_overlay_ids(int index, std::string&& value) {
  _internal_mutable_overlay_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline void DirectionsLeg_GuidanceView::set_overlay_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_overlay_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline void DirectionsLeg_GuidanceView::set_overlay_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_overlay_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline void DirectionsLeg_GuidanceView::set_overlay_ids(int index, absl::string_view value) {
  _internal_mutable_overlay_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline void DirectionsLeg_GuidanceView::add_overlay_ids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_overlay_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline void DirectionsLeg_GuidanceView::add_overlay_ids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_overlay_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline void DirectionsLeg_GuidanceView::add_overlay_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_overlay_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline void DirectionsLeg_GuidanceView::add_overlay_ids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_overlay_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline void DirectionsLeg_GuidanceView::add_overlay_ids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_overlay_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
DirectionsLeg_GuidanceView::overlay_ids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
  return _internal_overlay_ids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
DirectionsLeg_GuidanceView::mutable_overlay_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_overlay_ids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
DirectionsLeg_GuidanceView::_internal_overlay_ids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.overlay_ids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
DirectionsLeg_GuidanceView::_internal_mutable_overlay_ids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.overlay_ids_;
}

// -------------------------------------------------------------------

// DirectionsLeg_Maneuver

// .valhalla.DirectionsLeg.Maneuver.Type type = 1;
inline void DirectionsLeg_Maneuver::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::valhalla::DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.type)
  return _internal_type();
}
inline void DirectionsLeg_Maneuver::set_type(::valhalla::DirectionsLeg_Maneuver_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.type)
}
inline ::valhalla::DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::DirectionsLeg_Maneuver_Type>(_impl_.type_);
}
inline void DirectionsLeg_Maneuver::_internal_set_type(::valhalla::DirectionsLeg_Maneuver_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// string text_instruction = 2;
inline void DirectionsLeg_Maneuver::clear_text_instruction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_instruction_.ClearToEmpty();
}
inline const std::string& DirectionsLeg_Maneuver::text_instruction() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.text_instruction)
  return _internal_text_instruction();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DirectionsLeg_Maneuver::set_text_instruction(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.text_instruction_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.text_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_text_instruction() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_text_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.text_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_text_instruction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.text_instruction_.Get();
}
inline void DirectionsLeg_Maneuver::_internal_set_text_instruction(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.text_instruction_.Set(value, GetArena());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_text_instruction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.text_instruction_.Mutable( GetArena());
}
inline std::string* DirectionsLeg_Maneuver::release_text_instruction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.text_instruction)
  return _impl_.text_instruction_.Release();
}
inline void DirectionsLeg_Maneuver::set_allocated_text_instruction(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_instruction_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_instruction_.IsDefault()) {
          _impl_.text_instruction_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.text_instruction)
}

// repeated .valhalla.StreetName street_name = 3;
inline int DirectionsLeg_Maneuver::_internal_street_name_size() const {
  return _internal_street_name().size();
}
inline int DirectionsLeg_Maneuver::street_name_size() const {
  return _internal_street_name_size();
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::mutable_street_name(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.street_name)
  return _internal_mutable_street_name()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>* DirectionsLeg_Maneuver::mutable_street_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.Maneuver.street_name)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_street_name();
}
inline const ::valhalla::StreetName& DirectionsLeg_Maneuver::street_name(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.street_name)
  return _internal_street_name().Get(index);
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::add_street_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::StreetName* _add = _internal_mutable_street_name()->Add();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.Maneuver.street_name)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>& DirectionsLeg_Maneuver::street_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.Maneuver.street_name)
  return _internal_street_name();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>&
DirectionsLeg_Maneuver::_internal_street_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.street_name_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>*
DirectionsLeg_Maneuver::_internal_mutable_street_name() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.street_name_;
}

// float length = 4;
inline void DirectionsLeg_Maneuver::clear_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.length_ = 0;
}
inline float DirectionsLeg_Maneuver::length() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.length)
  return _internal_length();
}
inline void DirectionsLeg_Maneuver::set_length(float value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.length)
}
inline float DirectionsLeg_Maneuver::_internal_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.length_;
}
inline void DirectionsLeg_Maneuver::_internal_set_length(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.length_ = value;
}

// double time = 5;
inline void DirectionsLeg_Maneuver::clear_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.time_ = 0;
}
inline double DirectionsLeg_Maneuver::time() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.time)
  return _internal_time();
}
inline void DirectionsLeg_Maneuver::set_time(double value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.time)
}
inline double DirectionsLeg_Maneuver::_internal_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.time_;
}
inline void DirectionsLeg_Maneuver::_internal_set_time(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.time_ = value;
}

// .valhalla.DirectionsLeg.Maneuver.CardinalDirection begin_cardinal_direction = 6;
inline void DirectionsLeg_Maneuver::clear_begin_cardinal_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.begin_cardinal_direction_ = 0;
}
inline ::valhalla::DirectionsLeg_Maneuver_CardinalDirection DirectionsLeg_Maneuver::begin_cardinal_direction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.begin_cardinal_direction)
  return _internal_begin_cardinal_direction();
}
inline void DirectionsLeg_Maneuver::set_begin_cardinal_direction(::valhalla::DirectionsLeg_Maneuver_CardinalDirection value) {
  _internal_set_begin_cardinal_direction(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.begin_cardinal_direction)
}
inline ::valhalla::DirectionsLeg_Maneuver_CardinalDirection DirectionsLeg_Maneuver::_internal_begin_cardinal_direction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::DirectionsLeg_Maneuver_CardinalDirection>(_impl_.begin_cardinal_direction_);
}
inline void DirectionsLeg_Maneuver::_internal_set_begin_cardinal_direction(::valhalla::DirectionsLeg_Maneuver_CardinalDirection value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.begin_cardinal_direction_ = value;
}

// uint32 begin_heading = 7;
inline void DirectionsLeg_Maneuver::clear_begin_heading() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.begin_heading_ = 0u;
}
inline ::uint32_t DirectionsLeg_Maneuver::begin_heading() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.begin_heading)
  return _internal_begin_heading();
}
inline void DirectionsLeg_Maneuver::set_begin_heading(::uint32_t value) {
  _internal_set_begin_heading(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.begin_heading)
}
inline ::uint32_t DirectionsLeg_Maneuver::_internal_begin_heading() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.begin_heading_;
}
inline void DirectionsLeg_Maneuver::_internal_set_begin_heading(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.begin_heading_ = value;
}

// uint32 begin_shape_index = 8;
inline void DirectionsLeg_Maneuver::clear_begin_shape_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.begin_shape_index_ = 0u;
}
inline ::uint32_t DirectionsLeg_Maneuver::begin_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.begin_shape_index)
  return _internal_begin_shape_index();
}
inline void DirectionsLeg_Maneuver::set_begin_shape_index(::uint32_t value) {
  _internal_set_begin_shape_index(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.begin_shape_index)
}
inline ::uint32_t DirectionsLeg_Maneuver::_internal_begin_shape_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.begin_shape_index_;
}
inline void DirectionsLeg_Maneuver::_internal_set_begin_shape_index(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.begin_shape_index_ = value;
}

// uint32 end_shape_index = 9;
inline void DirectionsLeg_Maneuver::clear_end_shape_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_shape_index_ = 0u;
}
inline ::uint32_t DirectionsLeg_Maneuver::end_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.end_shape_index)
  return _internal_end_shape_index();
}
inline void DirectionsLeg_Maneuver::set_end_shape_index(::uint32_t value) {
  _internal_set_end_shape_index(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.end_shape_index)
}
inline ::uint32_t DirectionsLeg_Maneuver::_internal_end_shape_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_shape_index_;
}
inline void DirectionsLeg_Maneuver::_internal_set_end_shape_index(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.end_shape_index_ = value;
}

// bool portions_toll = 10;
inline void DirectionsLeg_Maneuver::clear_portions_toll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.portions_toll_ = false;
}
inline bool DirectionsLeg_Maneuver::portions_toll() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.portions_toll)
  return _internal_portions_toll();
}
inline void DirectionsLeg_Maneuver::set_portions_toll(bool value) {
  _internal_set_portions_toll(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.portions_toll)
}
inline bool DirectionsLeg_Maneuver::_internal_portions_toll() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.portions_toll_;
}
inline void DirectionsLeg_Maneuver::_internal_set_portions_toll(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.portions_toll_ = value;
}

// bool portions_unpaved = 11;
inline void DirectionsLeg_Maneuver::clear_portions_unpaved() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.portions_unpaved_ = false;
}
inline bool DirectionsLeg_Maneuver::portions_unpaved() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.portions_unpaved)
  return _internal_portions_unpaved();
}
inline void DirectionsLeg_Maneuver::set_portions_unpaved(bool value) {
  _internal_set_portions_unpaved(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.portions_unpaved)
}
inline bool DirectionsLeg_Maneuver::_internal_portions_unpaved() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.portions_unpaved_;
}
inline void DirectionsLeg_Maneuver::_internal_set_portions_unpaved(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.portions_unpaved_ = value;
}

// string verbal_transition_alert_instruction = 12;
inline void DirectionsLeg_Maneuver::clear_verbal_transition_alert_instruction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.verbal_transition_alert_instruction_.ClearToEmpty();
}
inline const std::string& DirectionsLeg_Maneuver::verbal_transition_alert_instruction() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.verbal_transition_alert_instruction)
  return _internal_verbal_transition_alert_instruction();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DirectionsLeg_Maneuver::set_verbal_transition_alert_instruction(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.verbal_transition_alert_instruction_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_transition_alert_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_verbal_transition_alert_instruction() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_verbal_transition_alert_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.verbal_transition_alert_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_verbal_transition_alert_instruction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.verbal_transition_alert_instruction_.Get();
}
inline void DirectionsLeg_Maneuver::_internal_set_verbal_transition_alert_instruction(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.verbal_transition_alert_instruction_.Set(value, GetArena());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_verbal_transition_alert_instruction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.verbal_transition_alert_instruction_.Mutable( GetArena());
}
inline std::string* DirectionsLeg_Maneuver::release_verbal_transition_alert_instruction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.verbal_transition_alert_instruction)
  return _impl_.verbal_transition_alert_instruction_.Release();
}
inline void DirectionsLeg_Maneuver::set_allocated_verbal_transition_alert_instruction(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.verbal_transition_alert_instruction_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.verbal_transition_alert_instruction_.IsDefault()) {
          _impl_.verbal_transition_alert_instruction_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.verbal_transition_alert_instruction)
}

// string verbal_pre_transition_instruction = 13;
inline void DirectionsLeg_Maneuver::clear_verbal_pre_transition_instruction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.verbal_pre_transition_instruction_.ClearToEmpty();
}
inline const std::string& DirectionsLeg_Maneuver::verbal_pre_transition_instruction() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.verbal_pre_transition_instruction)
  return _internal_verbal_pre_transition_instruction();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DirectionsLeg_Maneuver::set_verbal_pre_transition_instruction(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.verbal_pre_transition_instruction_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_pre_transition_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_verbal_pre_transition_instruction() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_verbal_pre_transition_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.verbal_pre_transition_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_verbal_pre_transition_instruction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.verbal_pre_transition_instruction_.Get();
}
inline void DirectionsLeg_Maneuver::_internal_set_verbal_pre_transition_instruction(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.verbal_pre_transition_instruction_.Set(value, GetArena());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_verbal_pre_transition_instruction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.verbal_pre_transition_instruction_.Mutable( GetArena());
}
inline std::string* DirectionsLeg_Maneuver::release_verbal_pre_transition_instruction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.verbal_pre_transition_instruction)
  return _impl_.verbal_pre_transition_instruction_.Release();
}
inline void DirectionsLeg_Maneuver::set_allocated_verbal_pre_transition_instruction(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.verbal_pre_transition_instruction_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.verbal_pre_transition_instruction_.IsDefault()) {
          _impl_.verbal_pre_transition_instruction_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.verbal_pre_transition_instruction)
}

// string verbal_post_transition_instruction = 14;
inline void DirectionsLeg_Maneuver::clear_verbal_post_transition_instruction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.verbal_post_transition_instruction_.ClearToEmpty();
}
inline const std::string& DirectionsLeg_Maneuver::verbal_post_transition_instruction() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.verbal_post_transition_instruction)
  return _internal_verbal_post_transition_instruction();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DirectionsLeg_Maneuver::set_verbal_post_transition_instruction(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.verbal_post_transition_instruction_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_post_transition_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_verbal_post_transition_instruction() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_verbal_post_transition_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.verbal_post_transition_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_verbal_post_transition_instruction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.verbal_post_transition_instruction_.Get();
}
inline void DirectionsLeg_Maneuver::_internal_set_verbal_post_transition_instruction(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.verbal_post_transition_instruction_.Set(value, GetArena());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_verbal_post_transition_instruction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.verbal_post_transition_instruction_.Mutable( GetArena());
}
inline std::string* DirectionsLeg_Maneuver::release_verbal_post_transition_instruction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.verbal_post_transition_instruction)
  return _impl_.verbal_post_transition_instruction_.Release();
}
inline void DirectionsLeg_Maneuver::set_allocated_verbal_post_transition_instruction(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.verbal_post_transition_instruction_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.verbal_post_transition_instruction_.IsDefault()) {
          _impl_.verbal_post_transition_instruction_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.verbal_post_transition_instruction)
}

// repeated .valhalla.StreetName begin_street_name = 15;
inline int DirectionsLeg_Maneuver::_internal_begin_street_name_size() const {
  return _internal_begin_street_name().size();
}
inline int DirectionsLeg_Maneuver::begin_street_name_size() const {
  return _internal_begin_street_name_size();
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::mutable_begin_street_name(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.begin_street_name)
  return _internal_mutable_begin_street_name()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>* DirectionsLeg_Maneuver::mutable_begin_street_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.Maneuver.begin_street_name)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_begin_street_name();
}
inline const ::valhalla::StreetName& DirectionsLeg_Maneuver::begin_street_name(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.begin_street_name)
  return _internal_begin_street_name().Get(index);
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::add_begin_street_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::StreetName* _add = _internal_mutable_begin_street_name()->Add();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.Maneuver.begin_street_name)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>& DirectionsLeg_Maneuver::begin_street_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.Maneuver.begin_street_name)
  return _internal_begin_street_name();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>&
DirectionsLeg_Maneuver::_internal_begin_street_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.begin_street_name_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>*
DirectionsLeg_Maneuver::_internal_mutable_begin_street_name() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.begin_street_name_;
}

// .valhalla.TripSign sign = 16;
inline bool DirectionsLeg_Maneuver::has_sign() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sign_ != nullptr);
  return value;
}
inline const ::valhalla::TripSign& DirectionsLeg_Maneuver::_internal_sign() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::TripSign* p = _impl_.sign_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TripSign&>(::valhalla::_TripSign_default_instance_);
}
inline const ::valhalla::TripSign& DirectionsLeg_Maneuver::sign() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.sign)
  return _internal_sign();
}
inline void DirectionsLeg_Maneuver::unsafe_arena_set_allocated_sign(::valhalla::TripSign* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sign_);
  }
  _impl_.sign_ = reinterpret_cast<::valhalla::TripSign*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.DirectionsLeg.Maneuver.sign)
}
inline ::valhalla::TripSign* DirectionsLeg_Maneuver::release_sign() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::TripSign* released = _impl_.sign_;
  _impl_.sign_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::TripSign* DirectionsLeg_Maneuver::unsafe_arena_release_sign() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.sign)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::TripSign* temp = _impl_.sign_;
  _impl_.sign_ = nullptr;
  return temp;
}
inline ::valhalla::TripSign* DirectionsLeg_Maneuver::_internal_mutable_sign() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.sign_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TripSign>(GetArena());
    _impl_.sign_ = reinterpret_cast<::valhalla::TripSign*>(p);
  }
  return _impl_.sign_;
}
inline ::valhalla::TripSign* DirectionsLeg_Maneuver::mutable_sign() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::TripSign* _msg = _internal_mutable_sign();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.sign)
  return _msg;
}
inline void DirectionsLeg_Maneuver::set_allocated_sign(::valhalla::TripSign* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sign_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.sign_ = reinterpret_cast<::valhalla::TripSign*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.sign)
}

// uint32 roundabout_exit_count = 17;
inline void DirectionsLeg_Maneuver::clear_roundabout_exit_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.roundabout_exit_count_ = 0u;
}
inline ::uint32_t DirectionsLeg_Maneuver::roundabout_exit_count() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.roundabout_exit_count)
  return _internal_roundabout_exit_count();
}
inline void DirectionsLeg_Maneuver::set_roundabout_exit_count(::uint32_t value) {
  _internal_set_roundabout_exit_count(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.roundabout_exit_count)
}
inline ::uint32_t DirectionsLeg_Maneuver::_internal_roundabout_exit_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.roundabout_exit_count_;
}
inline void DirectionsLeg_Maneuver::_internal_set_roundabout_exit_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.roundabout_exit_count_ = value;
}

// string depart_instruction = 18;
inline void DirectionsLeg_Maneuver::clear_depart_instruction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.depart_instruction_.ClearToEmpty();
}
inline const std::string& DirectionsLeg_Maneuver::depart_instruction() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.depart_instruction)
  return _internal_depart_instruction();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DirectionsLeg_Maneuver::set_depart_instruction(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.depart_instruction_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.depart_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_depart_instruction() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_depart_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.depart_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_depart_instruction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.depart_instruction_.Get();
}
inline void DirectionsLeg_Maneuver::_internal_set_depart_instruction(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.depart_instruction_.Set(value, GetArena());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_depart_instruction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.depart_instruction_.Mutable( GetArena());
}
inline std::string* DirectionsLeg_Maneuver::release_depart_instruction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.depart_instruction)
  return _impl_.depart_instruction_.Release();
}
inline void DirectionsLeg_Maneuver::set_allocated_depart_instruction(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.depart_instruction_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.depart_instruction_.IsDefault()) {
          _impl_.depart_instruction_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.depart_instruction)
}

// string verbal_depart_instruction = 19;
inline void DirectionsLeg_Maneuver::clear_verbal_depart_instruction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.verbal_depart_instruction_.ClearToEmpty();
}
inline const std::string& DirectionsLeg_Maneuver::verbal_depart_instruction() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.verbal_depart_instruction)
  return _internal_verbal_depart_instruction();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DirectionsLeg_Maneuver::set_verbal_depart_instruction(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.verbal_depart_instruction_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_depart_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_verbal_depart_instruction() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_verbal_depart_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.verbal_depart_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_verbal_depart_instruction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.verbal_depart_instruction_.Get();
}
inline void DirectionsLeg_Maneuver::_internal_set_verbal_depart_instruction(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.verbal_depart_instruction_.Set(value, GetArena());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_verbal_depart_instruction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.verbal_depart_instruction_.Mutable( GetArena());
}
inline std::string* DirectionsLeg_Maneuver::release_verbal_depart_instruction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.verbal_depart_instruction)
  return _impl_.verbal_depart_instruction_.Release();
}
inline void DirectionsLeg_Maneuver::set_allocated_verbal_depart_instruction(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.verbal_depart_instruction_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.verbal_depart_instruction_.IsDefault()) {
          _impl_.verbal_depart_instruction_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.verbal_depart_instruction)
}

// string arrive_instruction = 20;
inline void DirectionsLeg_Maneuver::clear_arrive_instruction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.arrive_instruction_.ClearToEmpty();
}
inline const std::string& DirectionsLeg_Maneuver::arrive_instruction() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.arrive_instruction)
  return _internal_arrive_instruction();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DirectionsLeg_Maneuver::set_arrive_instruction(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.arrive_instruction_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.arrive_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_arrive_instruction() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_arrive_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.arrive_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_arrive_instruction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.arrive_instruction_.Get();
}
inline void DirectionsLeg_Maneuver::_internal_set_arrive_instruction(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.arrive_instruction_.Set(value, GetArena());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_arrive_instruction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.arrive_instruction_.Mutable( GetArena());
}
inline std::string* DirectionsLeg_Maneuver::release_arrive_instruction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.arrive_instruction)
  return _impl_.arrive_instruction_.Release();
}
inline void DirectionsLeg_Maneuver::set_allocated_arrive_instruction(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.arrive_instruction_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.arrive_instruction_.IsDefault()) {
          _impl_.arrive_instruction_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.arrive_instruction)
}

// string verbal_arrive_instruction = 21;
inline void DirectionsLeg_Maneuver::clear_verbal_arrive_instruction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.verbal_arrive_instruction_.ClearToEmpty();
}
inline const std::string& DirectionsLeg_Maneuver::verbal_arrive_instruction() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.verbal_arrive_instruction)
  return _internal_verbal_arrive_instruction();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DirectionsLeg_Maneuver::set_verbal_arrive_instruction(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.verbal_arrive_instruction_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_arrive_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_verbal_arrive_instruction() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_verbal_arrive_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.verbal_arrive_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_verbal_arrive_instruction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.verbal_arrive_instruction_.Get();
}
inline void DirectionsLeg_Maneuver::_internal_set_verbal_arrive_instruction(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.verbal_arrive_instruction_.Set(value, GetArena());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_verbal_arrive_instruction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.verbal_arrive_instruction_.Mutable( GetArena());
}
inline std::string* DirectionsLeg_Maneuver::release_verbal_arrive_instruction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.verbal_arrive_instruction)
  return _impl_.verbal_arrive_instruction_.Release();
}
inline void DirectionsLeg_Maneuver::set_allocated_verbal_arrive_instruction(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.verbal_arrive_instruction_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.verbal_arrive_instruction_.IsDefault()) {
          _impl_.verbal_arrive_instruction_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.verbal_arrive_instruction)
}

// .valhalla.TransitRouteInfo transit_info = 22;
inline bool DirectionsLeg_Maneuver::has_transit_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transit_info_ != nullptr);
  return value;
}
inline const ::valhalla::TransitRouteInfo& DirectionsLeg_Maneuver::_internal_transit_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::TransitRouteInfo* p = _impl_.transit_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TransitRouteInfo&>(::valhalla::_TransitRouteInfo_default_instance_);
}
inline const ::valhalla::TransitRouteInfo& DirectionsLeg_Maneuver::transit_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.transit_info)
  return _internal_transit_info();
}
inline void DirectionsLeg_Maneuver::unsafe_arena_set_allocated_transit_info(::valhalla::TransitRouteInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transit_info_);
  }
  _impl_.transit_info_ = reinterpret_cast<::valhalla::TransitRouteInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.DirectionsLeg.Maneuver.transit_info)
}
inline ::valhalla::TransitRouteInfo* DirectionsLeg_Maneuver::release_transit_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::valhalla::TransitRouteInfo* released = _impl_.transit_info_;
  _impl_.transit_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::TransitRouteInfo* DirectionsLeg_Maneuver::unsafe_arena_release_transit_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.transit_info)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::valhalla::TransitRouteInfo* temp = _impl_.transit_info_;
  _impl_.transit_info_ = nullptr;
  return temp;
}
inline ::valhalla::TransitRouteInfo* DirectionsLeg_Maneuver::_internal_mutable_transit_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.transit_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TransitRouteInfo>(GetArena());
    _impl_.transit_info_ = reinterpret_cast<::valhalla::TransitRouteInfo*>(p);
  }
  return _impl_.transit_info_;
}
inline ::valhalla::TransitRouteInfo* DirectionsLeg_Maneuver::mutable_transit_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::TransitRouteInfo* _msg = _internal_mutable_transit_info();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.transit_info)
  return _msg;
}
inline void DirectionsLeg_Maneuver::set_allocated_transit_info(::valhalla::TransitRouteInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transit_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.transit_info_ = reinterpret_cast<::valhalla::TransitRouteInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.transit_info)
}

// bool verbal_multi_cue = 23;
inline void DirectionsLeg_Maneuver::clear_verbal_multi_cue() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.verbal_multi_cue_ = false;
}
inline bool DirectionsLeg_Maneuver::verbal_multi_cue() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.verbal_multi_cue)
  return _internal_verbal_multi_cue();
}
inline void DirectionsLeg_Maneuver::set_verbal_multi_cue(bool value) {
  _internal_set_verbal_multi_cue(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_multi_cue)
}
inline bool DirectionsLeg_Maneuver::_internal_verbal_multi_cue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.verbal_multi_cue_;
}
inline void DirectionsLeg_Maneuver::_internal_set_verbal_multi_cue(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.verbal_multi_cue_ = value;
}

// .valhalla.TravelMode travel_mode = 24;
inline void DirectionsLeg_Maneuver::clear_travel_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.travel_mode_ = 0;
}
inline ::valhalla::TravelMode DirectionsLeg_Maneuver::travel_mode() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.travel_mode)
  return _internal_travel_mode();
}
inline void DirectionsLeg_Maneuver::set_travel_mode(::valhalla::TravelMode value) {
  _internal_set_travel_mode(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.travel_mode)
}
inline ::valhalla::TravelMode DirectionsLeg_Maneuver::_internal_travel_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::TravelMode>(_impl_.travel_mode_);
}
inline void DirectionsLeg_Maneuver::_internal_set_travel_mode(::valhalla::TravelMode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.travel_mode_ = value;
}

// .valhalla.VehicleType vehicle_type = 25;
inline void DirectionsLeg_Maneuver::clear_vehicle_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vehicle_type_ = 0;
}
inline ::valhalla::VehicleType DirectionsLeg_Maneuver::vehicle_type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.vehicle_type)
  return _internal_vehicle_type();
}
inline void DirectionsLeg_Maneuver::set_vehicle_type(::valhalla::VehicleType value) {
  _internal_set_vehicle_type(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.vehicle_type)
}
inline ::valhalla::VehicleType DirectionsLeg_Maneuver::_internal_vehicle_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::VehicleType>(_impl_.vehicle_type_);
}
inline void DirectionsLeg_Maneuver::_internal_set_vehicle_type(::valhalla::VehicleType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.vehicle_type_ = value;
}

// .valhalla.PedestrianType pedestrian_type = 26;
inline void DirectionsLeg_Maneuver::clear_pedestrian_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pedestrian_type_ = 0;
}
inline ::valhalla::PedestrianType DirectionsLeg_Maneuver::pedestrian_type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.pedestrian_type)
  return _internal_pedestrian_type();
}
inline void DirectionsLeg_Maneuver::set_pedestrian_type(::valhalla::PedestrianType value) {
  _internal_set_pedestrian_type(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.pedestrian_type)
}
inline ::valhalla::PedestrianType DirectionsLeg_Maneuver::_internal_pedestrian_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::PedestrianType>(_impl_.pedestrian_type_);
}
inline void DirectionsLeg_Maneuver::_internal_set_pedestrian_type(::valhalla::PedestrianType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pedestrian_type_ = value;
}

// .valhalla.BicycleType bicycle_type = 27;
inline void DirectionsLeg_Maneuver::clear_bicycle_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bicycle_type_ = 0;
}
inline ::valhalla::BicycleType DirectionsLeg_Maneuver::bicycle_type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.bicycle_type)
  return _internal_bicycle_type();
}
inline void DirectionsLeg_Maneuver::set_bicycle_type(::valhalla::BicycleType value) {
  _internal_set_bicycle_type(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.bicycle_type)
}
inline ::valhalla::BicycleType DirectionsLeg_Maneuver::_internal_bicycle_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::BicycleType>(_impl_.bicycle_type_);
}
inline void DirectionsLeg_Maneuver::_internal_set_bicycle_type(::valhalla::BicycleType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.bicycle_type_ = value;
}

// .valhalla.TransitType transit_type = 28;
inline void DirectionsLeg_Maneuver::clear_transit_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.transit_type_ = 0;
}
inline ::valhalla::TransitType DirectionsLeg_Maneuver::transit_type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.transit_type)
  return _internal_transit_type();
}
inline void DirectionsLeg_Maneuver::set_transit_type(::valhalla::TransitType value) {
  _internal_set_transit_type(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.transit_type)
}
inline ::valhalla::TransitType DirectionsLeg_Maneuver::_internal_transit_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::TransitType>(_impl_.transit_type_);
}
inline void DirectionsLeg_Maneuver::_internal_set_transit_type(::valhalla::TransitType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.transit_type_ = value;
}

// uint32 begin_path_index = 29;
inline void DirectionsLeg_Maneuver::clear_begin_path_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.begin_path_index_ = 0u;
}
inline ::uint32_t DirectionsLeg_Maneuver::begin_path_index() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.begin_path_index)
  return _internal_begin_path_index();
}
inline void DirectionsLeg_Maneuver::set_begin_path_index(::uint32_t value) {
  _internal_set_begin_path_index(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.begin_path_index)
}
inline ::uint32_t DirectionsLeg_Maneuver::_internal_begin_path_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.begin_path_index_;
}
inline void DirectionsLeg_Maneuver::_internal_set_begin_path_index(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.begin_path_index_ = value;
}

// uint32 end_path_index = 30;
inline void DirectionsLeg_Maneuver::clear_end_path_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_path_index_ = 0u;
}
inline ::uint32_t DirectionsLeg_Maneuver::end_path_index() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.end_path_index)
  return _internal_end_path_index();
}
inline void DirectionsLeg_Maneuver::set_end_path_index(::uint32_t value) {
  _internal_set_end_path_index(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.end_path_index)
}
inline ::uint32_t DirectionsLeg_Maneuver::_internal_end_path_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_path_index_;
}
inline void DirectionsLeg_Maneuver::_internal_set_end_path_index(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.end_path_index_ = value;
}

// bool to_stay_on = 31;
inline void DirectionsLeg_Maneuver::clear_to_stay_on() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.to_stay_on_ = false;
}
inline bool DirectionsLeg_Maneuver::to_stay_on() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.to_stay_on)
  return _internal_to_stay_on();
}
inline void DirectionsLeg_Maneuver::set_to_stay_on(bool value) {
  _internal_set_to_stay_on(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.to_stay_on)
}
inline bool DirectionsLeg_Maneuver::_internal_to_stay_on() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.to_stay_on_;
}
inline void DirectionsLeg_Maneuver::_internal_set_to_stay_on(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.to_stay_on_ = value;
}

// repeated .valhalla.StreetName roundabout_exit_street_names = 32;
inline int DirectionsLeg_Maneuver::_internal_roundabout_exit_street_names_size() const {
  return _internal_roundabout_exit_street_names().size();
}
inline int DirectionsLeg_Maneuver::roundabout_exit_street_names_size() const {
  return _internal_roundabout_exit_street_names_size();
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::mutable_roundabout_exit_street_names(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.roundabout_exit_street_names)
  return _internal_mutable_roundabout_exit_street_names()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>* DirectionsLeg_Maneuver::mutable_roundabout_exit_street_names()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.Maneuver.roundabout_exit_street_names)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_roundabout_exit_street_names();
}
inline const ::valhalla::StreetName& DirectionsLeg_Maneuver::roundabout_exit_street_names(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.roundabout_exit_street_names)
  return _internal_roundabout_exit_street_names().Get(index);
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::add_roundabout_exit_street_names() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::StreetName* _add = _internal_mutable_roundabout_exit_street_names()->Add();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.Maneuver.roundabout_exit_street_names)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>& DirectionsLeg_Maneuver::roundabout_exit_street_names() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.Maneuver.roundabout_exit_street_names)
  return _internal_roundabout_exit_street_names();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>&
DirectionsLeg_Maneuver::_internal_roundabout_exit_street_names() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.roundabout_exit_street_names_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>*
DirectionsLeg_Maneuver::_internal_mutable_roundabout_exit_street_names() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.roundabout_exit_street_names_;
}

// uint32 turn_degree = 33;
inline void DirectionsLeg_Maneuver::clear_turn_degree() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.turn_degree_ = 0u;
}
inline ::uint32_t DirectionsLeg_Maneuver::turn_degree() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.turn_degree)
  return _internal_turn_degree();
}
inline void DirectionsLeg_Maneuver::set_turn_degree(::uint32_t value) {
  _internal_set_turn_degree(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.turn_degree)
}
inline ::uint32_t DirectionsLeg_Maneuver::_internal_turn_degree() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.turn_degree_;
}
inline void DirectionsLeg_Maneuver::_internal_set_turn_degree(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.turn_degree_ = value;
}

// bool has_time_restrictions = 34;
inline void DirectionsLeg_Maneuver::clear_has_time_restrictions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.has_time_restrictions_ = false;
}
inline bool DirectionsLeg_Maneuver::has_time_restrictions() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.has_time_restrictions)
  return _internal_has_time_restrictions();
}
inline void DirectionsLeg_Maneuver::set_has_time_restrictions(bool value) {
  _internal_set_has_time_restrictions(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.has_time_restrictions)
}
inline bool DirectionsLeg_Maneuver::_internal_has_time_restrictions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.has_time_restrictions_;
}
inline void DirectionsLeg_Maneuver::_internal_set_has_time_restrictions(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.has_time_restrictions_ = value;
}

// repeated .valhalla.DirectionsLeg.GuidanceView guidance_views = 35;
inline int DirectionsLeg_Maneuver::_internal_guidance_views_size() const {
  return _internal_guidance_views().size();
}
inline int DirectionsLeg_Maneuver::guidance_views_size() const {
  return _internal_guidance_views_size();
}
inline void DirectionsLeg_Maneuver::clear_guidance_views() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guidance_views_.Clear();
}
inline ::valhalla::DirectionsLeg_GuidanceView* DirectionsLeg_Maneuver::mutable_guidance_views(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.guidance_views)
  return _internal_mutable_guidance_views()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::DirectionsLeg_GuidanceView>* DirectionsLeg_Maneuver::mutable_guidance_views()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.Maneuver.guidance_views)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_guidance_views();
}
inline const ::valhalla::DirectionsLeg_GuidanceView& DirectionsLeg_Maneuver::guidance_views(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.guidance_views)
  return _internal_guidance_views().Get(index);
}
inline ::valhalla::DirectionsLeg_GuidanceView* DirectionsLeg_Maneuver::add_guidance_views() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::DirectionsLeg_GuidanceView* _add = _internal_mutable_guidance_views()->Add();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.Maneuver.guidance_views)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::DirectionsLeg_GuidanceView>& DirectionsLeg_Maneuver::guidance_views() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.Maneuver.guidance_views)
  return _internal_guidance_views();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::DirectionsLeg_GuidanceView>&
DirectionsLeg_Maneuver::_internal_guidance_views() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guidance_views_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::DirectionsLeg_GuidanceView>*
DirectionsLeg_Maneuver::_internal_mutable_guidance_views() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.guidance_views_;
}

// .valhalla.DirectionsLeg.Maneuver.BssManeuverType bss_maneuver_type = 36;
inline void DirectionsLeg_Maneuver::clear_bss_maneuver_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bss_maneuver_type_ = 0;
}
inline ::valhalla::DirectionsLeg_Maneuver_BssManeuverType DirectionsLeg_Maneuver::bss_maneuver_type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.bss_maneuver_type)
  return _internal_bss_maneuver_type();
}
inline void DirectionsLeg_Maneuver::set_bss_maneuver_type(::valhalla::DirectionsLeg_Maneuver_BssManeuverType value) {
  _internal_set_bss_maneuver_type(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.bss_maneuver_type)
}
inline ::valhalla::DirectionsLeg_Maneuver_BssManeuverType DirectionsLeg_Maneuver::_internal_bss_maneuver_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::DirectionsLeg_Maneuver_BssManeuverType>(_impl_.bss_maneuver_type_);
}
inline void DirectionsLeg_Maneuver::_internal_set_bss_maneuver_type(::valhalla::DirectionsLeg_Maneuver_BssManeuverType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.bss_maneuver_type_ = value;
}

// string verbal_succinct_transition_instruction = 37;
inline void DirectionsLeg_Maneuver::clear_verbal_succinct_transition_instruction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.verbal_succinct_transition_instruction_.ClearToEmpty();
}
inline const std::string& DirectionsLeg_Maneuver::verbal_succinct_transition_instruction() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.verbal_succinct_transition_instruction)
  return _internal_verbal_succinct_transition_instruction();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DirectionsLeg_Maneuver::set_verbal_succinct_transition_instruction(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.verbal_succinct_transition_instruction_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_succinct_transition_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_verbal_succinct_transition_instruction() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_verbal_succinct_transition_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.verbal_succinct_transition_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_verbal_succinct_transition_instruction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.verbal_succinct_transition_instruction_.Get();
}
inline void DirectionsLeg_Maneuver::_internal_set_verbal_succinct_transition_instruction(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.verbal_succinct_transition_instruction_.Set(value, GetArena());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_verbal_succinct_transition_instruction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.verbal_succinct_transition_instruction_.Mutable( GetArena());
}
inline std::string* DirectionsLeg_Maneuver::release_verbal_succinct_transition_instruction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.verbal_succinct_transition_instruction)
  return _impl_.verbal_succinct_transition_instruction_.Release();
}
inline void DirectionsLeg_Maneuver::set_allocated_verbal_succinct_transition_instruction(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.verbal_succinct_transition_instruction_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.verbal_succinct_transition_instruction_.IsDefault()) {
          _impl_.verbal_succinct_transition_instruction_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.verbal_succinct_transition_instruction)
}

// .valhalla.BikeShareStationInfo bss_info = 38;
inline bool DirectionsLeg_Maneuver::has_bss_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bss_info_ != nullptr);
  return value;
}
inline const ::valhalla::BikeShareStationInfo& DirectionsLeg_Maneuver::_internal_bss_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::BikeShareStationInfo* p = _impl_.bss_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::BikeShareStationInfo&>(::valhalla::_BikeShareStationInfo_default_instance_);
}
inline const ::valhalla::BikeShareStationInfo& DirectionsLeg_Maneuver::bss_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.bss_info)
  return _internal_bss_info();
}
inline void DirectionsLeg_Maneuver::unsafe_arena_set_allocated_bss_info(::valhalla::BikeShareStationInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bss_info_);
  }
  _impl_.bss_info_ = reinterpret_cast<::valhalla::BikeShareStationInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.DirectionsLeg.Maneuver.bss_info)
}
inline ::valhalla::BikeShareStationInfo* DirectionsLeg_Maneuver::release_bss_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::valhalla::BikeShareStationInfo* released = _impl_.bss_info_;
  _impl_.bss_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::BikeShareStationInfo* DirectionsLeg_Maneuver::unsafe_arena_release_bss_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.bss_info)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::valhalla::BikeShareStationInfo* temp = _impl_.bss_info_;
  _impl_.bss_info_ = nullptr;
  return temp;
}
inline ::valhalla::BikeShareStationInfo* DirectionsLeg_Maneuver::_internal_mutable_bss_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.bss_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::BikeShareStationInfo>(GetArena());
    _impl_.bss_info_ = reinterpret_cast<::valhalla::BikeShareStationInfo*>(p);
  }
  return _impl_.bss_info_;
}
inline ::valhalla::BikeShareStationInfo* DirectionsLeg_Maneuver::mutable_bss_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::BikeShareStationInfo* _msg = _internal_mutable_bss_info();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.bss_info)
  return _msg;
}
inline void DirectionsLeg_Maneuver::set_allocated_bss_info(::valhalla::BikeShareStationInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bss_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.bss_info_ = reinterpret_cast<::valhalla::BikeShareStationInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.bss_info)
}

// bool portions_highway = 39;
inline void DirectionsLeg_Maneuver::clear_portions_highway() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.portions_highway_ = false;
}
inline bool DirectionsLeg_Maneuver::portions_highway() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.portions_highway)
  return _internal_portions_highway();
}
inline void DirectionsLeg_Maneuver::set_portions_highway(bool value) {
  _internal_set_portions_highway(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.portions_highway)
}
inline bool DirectionsLeg_Maneuver::_internal_portions_highway() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.portions_highway_;
}
inline void DirectionsLeg_Maneuver::_internal_set_portions_highway(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.portions_highway_ = value;
}

// bool portions_ferry = 40;
inline void DirectionsLeg_Maneuver::clear_portions_ferry() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.portions_ferry_ = false;
}
inline bool DirectionsLeg_Maneuver::portions_ferry() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.portions_ferry)
  return _internal_portions_ferry();
}
inline void DirectionsLeg_Maneuver::set_portions_ferry(bool value) {
  _internal_set_portions_ferry(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.portions_ferry)
}
inline bool DirectionsLeg_Maneuver::_internal_portions_ferry() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.portions_ferry_;
}
inline void DirectionsLeg_Maneuver::_internal_set_portions_ferry(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.portions_ferry_ = value;
}

// repeated .valhalla.RouteLandmark landmarks = 41;
inline int DirectionsLeg_Maneuver::_internal_landmarks_size() const {
  return _internal_landmarks().size();
}
inline int DirectionsLeg_Maneuver::landmarks_size() const {
  return _internal_landmarks_size();
}
inline ::valhalla::RouteLandmark* DirectionsLeg_Maneuver::mutable_landmarks(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.landmarks)
  return _internal_mutable_landmarks()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::RouteLandmark>* DirectionsLeg_Maneuver::mutable_landmarks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.Maneuver.landmarks)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_landmarks();
}
inline const ::valhalla::RouteLandmark& DirectionsLeg_Maneuver::landmarks(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.landmarks)
  return _internal_landmarks().Get(index);
}
inline ::valhalla::RouteLandmark* DirectionsLeg_Maneuver::add_landmarks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::RouteLandmark* _add = _internal_mutable_landmarks()->Add();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.Maneuver.landmarks)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::RouteLandmark>& DirectionsLeg_Maneuver::landmarks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.Maneuver.landmarks)
  return _internal_landmarks();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::RouteLandmark>&
DirectionsLeg_Maneuver::_internal_landmarks() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.landmarks_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::RouteLandmark>*
DirectionsLeg_Maneuver::_internal_mutable_landmarks() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.landmarks_;
}

// -------------------------------------------------------------------

// DirectionsLeg

// uint64 trip_id = 1;
inline void DirectionsLeg::clear_trip_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.trip_id_ = ::uint64_t{0u};
}
inline ::uint64_t DirectionsLeg::trip_id() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.trip_id)
  return _internal_trip_id();
}
inline void DirectionsLeg::set_trip_id(::uint64_t value) {
  _internal_set_trip_id(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.trip_id)
}
inline ::uint64_t DirectionsLeg::_internal_trip_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.trip_id_;
}
inline void DirectionsLeg::_internal_set_trip_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.trip_id_ = value;
}

// uint32 leg_id = 2;
inline void DirectionsLeg::clear_leg_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.leg_id_ = 0u;
}
inline ::uint32_t DirectionsLeg::leg_id() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.leg_id)
  return _internal_leg_id();
}
inline void DirectionsLeg::set_leg_id(::uint32_t value) {
  _internal_set_leg_id(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.leg_id)
}
inline ::uint32_t DirectionsLeg::_internal_leg_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.leg_id_;
}
inline void DirectionsLeg::_internal_set_leg_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.leg_id_ = value;
}

// uint32 leg_count = 3;
inline void DirectionsLeg::clear_leg_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.leg_count_ = 0u;
}
inline ::uint32_t DirectionsLeg::leg_count() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.leg_count)
  return _internal_leg_count();
}
inline void DirectionsLeg::set_leg_count(::uint32_t value) {
  _internal_set_leg_count(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.leg_count)
}
inline ::uint32_t DirectionsLeg::_internal_leg_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.leg_count_;
}
inline void DirectionsLeg::_internal_set_leg_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.leg_count_ = value;
}

// repeated .valhalla.Location location = 4;
inline int DirectionsLeg::_internal_location_size() const {
  return _internal_location().size();
}
inline int DirectionsLeg::location_size() const {
  return _internal_location_size();
}
inline ::valhalla::Location* DirectionsLeg::mutable_location(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.location)
  return _internal_mutable_location()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::Location>* DirectionsLeg::mutable_location()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.location)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_location();
}
inline const ::valhalla::Location& DirectionsLeg::location(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.location)
  return _internal_location().Get(index);
}
inline ::valhalla::Location* DirectionsLeg::add_location() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::Location* _add = _internal_mutable_location()->Add();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.location)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::Location>& DirectionsLeg::location() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.location)
  return _internal_location();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::Location>&
DirectionsLeg::_internal_location() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.location_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::Location>*
DirectionsLeg::_internal_mutable_location() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.location_;
}

// .valhalla.Summary summary = 5;
inline bool DirectionsLeg::has_summary() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.summary_ != nullptr);
  return value;
}
inline const ::valhalla::Summary& DirectionsLeg::_internal_summary() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::Summary* p = _impl_.summary_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::Summary&>(::valhalla::_Summary_default_instance_);
}
inline const ::valhalla::Summary& DirectionsLeg::summary() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.summary)
  return _internal_summary();
}
inline void DirectionsLeg::unsafe_arena_set_allocated_summary(::valhalla::Summary* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.summary_);
  }
  _impl_.summary_ = reinterpret_cast<::valhalla::Summary*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.DirectionsLeg.summary)
}
inline ::valhalla::Summary* DirectionsLeg::release_summary() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::Summary* released = _impl_.summary_;
  _impl_.summary_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::Summary* DirectionsLeg::unsafe_arena_release_summary() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.summary)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::Summary* temp = _impl_.summary_;
  _impl_.summary_ = nullptr;
  return temp;
}
inline ::valhalla::Summary* DirectionsLeg::_internal_mutable_summary() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.summary_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::Summary>(GetArena());
    _impl_.summary_ = reinterpret_cast<::valhalla::Summary*>(p);
  }
  return _impl_.summary_;
}
inline ::valhalla::Summary* DirectionsLeg::mutable_summary() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::Summary* _msg = _internal_mutable_summary();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.summary)
  return _msg;
}
inline void DirectionsLeg::set_allocated_summary(::valhalla::Summary* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.summary_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.summary_ = reinterpret_cast<::valhalla::Summary*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.summary)
}

// repeated .valhalla.DirectionsLeg.Maneuver maneuver = 6;
inline int DirectionsLeg::_internal_maneuver_size() const {
  return _internal_maneuver().size();
}
inline int DirectionsLeg::maneuver_size() const {
  return _internal_maneuver_size();
}
inline void DirectionsLeg::clear_maneuver() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.maneuver_.Clear();
}
inline ::valhalla::DirectionsLeg_Maneuver* DirectionsLeg::mutable_maneuver(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.maneuver)
  return _internal_mutable_maneuver()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::DirectionsLeg_Maneuver>* DirectionsLeg::mutable_maneuver()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.maneuver)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_maneuver();
}
inline const ::valhalla::DirectionsLeg_Maneuver& DirectionsLeg::maneuver(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.maneuver)
  return _internal_maneuver().Get(index);
}
inline ::valhalla::DirectionsLeg_Maneuver* DirectionsLeg::add_maneuver() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::DirectionsLeg_Maneuver* _add = _internal_mutable_maneuver()->Add();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.maneuver)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::DirectionsLeg_Maneuver>& DirectionsLeg::maneuver() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.maneuver)
  return _internal_maneuver();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::DirectionsLeg_Maneuver>&
DirectionsLeg::_internal_maneuver() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.maneuver_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::DirectionsLeg_Maneuver>*
DirectionsLeg::_internal_mutable_maneuver() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.maneuver_;
}

// string shape = 7;
inline void DirectionsLeg::clear_shape() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.shape_.ClearToEmpty();
}
inline const std::string& DirectionsLeg::shape() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.shape)
  return _internal_shape();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DirectionsLeg::set_shape(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.shape_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.shape)
}
inline std::string* DirectionsLeg::mutable_shape() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_shape();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.shape)
  return _s;
}
inline const std::string& DirectionsLeg::_internal_shape() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.shape_.Get();
}
inline void DirectionsLeg::_internal_set_shape(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.shape_.Set(value, GetArena());
}
inline std::string* DirectionsLeg::_internal_mutable_shape() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.shape_.Mutable( GetArena());
}
inline std::string* DirectionsLeg::release_shape() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.shape)
  return _impl_.shape_.Release();
}
inline void DirectionsLeg::set_allocated_shape(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.shape_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.shape_.IsDefault()) {
          _impl_.shape_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.shape)
}

// -------------------------------------------------------------------

// DirectionsRoute

// repeated .valhalla.DirectionsLeg legs = 1;
inline int DirectionsRoute::_internal_legs_size() const {
  return _internal_legs().size();
}
inline int DirectionsRoute::legs_size() const {
  return _internal_legs_size();
}
inline void DirectionsRoute::clear_legs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.legs_.Clear();
}
inline ::valhalla::DirectionsLeg* DirectionsRoute::mutable_legs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsRoute.legs)
  return _internal_mutable_legs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::DirectionsLeg>* DirectionsRoute::mutable_legs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsRoute.legs)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_legs();
}
inline const ::valhalla::DirectionsLeg& DirectionsRoute::legs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsRoute.legs)
  return _internal_legs().Get(index);
}
inline ::valhalla::DirectionsLeg* DirectionsRoute::add_legs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::DirectionsLeg* _add = _internal_mutable_legs()->Add();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsRoute.legs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::DirectionsLeg>& DirectionsRoute::legs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsRoute.legs)
  return _internal_legs();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::DirectionsLeg>&
DirectionsRoute::_internal_legs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.legs_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::DirectionsLeg>*
DirectionsRoute::_internal_mutable_legs() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.legs_;
}

// -------------------------------------------------------------------

// Directions

// repeated .valhalla.DirectionsRoute routes = 1;
inline int Directions::_internal_routes_size() const {
  return _internal_routes().size();
}
inline int Directions::routes_size() const {
  return _internal_routes_size();
}
inline void Directions::clear_routes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.routes_.Clear();
}
inline ::valhalla::DirectionsRoute* Directions::mutable_routes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.Directions.routes)
  return _internal_mutable_routes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::DirectionsRoute>* Directions::mutable_routes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Directions.routes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_routes();
}
inline const ::valhalla::DirectionsRoute& Directions::routes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Directions.routes)
  return _internal_routes().Get(index);
}
inline ::valhalla::DirectionsRoute* Directions::add_routes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::DirectionsRoute* _add = _internal_mutable_routes()->Add();
  // @@protoc_insertion_point(field_add:valhalla.Directions.routes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::DirectionsRoute>& Directions::routes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.Directions.routes)
  return _internal_routes();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::DirectionsRoute>&
Directions::_internal_routes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.routes_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::DirectionsRoute>*
Directions::_internal_mutable_routes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.routes_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace valhalla


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::valhalla::DirectionsLeg_GuidanceView_Type> : std::true_type {};
template <>
struct is_proto_enum<::valhalla::DirectionsLeg_Maneuver_CardinalDirection> : std::true_type {};
template <>
struct is_proto_enum<::valhalla::DirectionsLeg_Maneuver_Type> : std::true_type {};
template <>
struct is_proto_enum<::valhalla::DirectionsLeg_Maneuver_BssManeuverType> : std::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_directions_2eproto_2epb_2eh
