// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: options.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_options_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_options_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_field_lite.h"
#include "google/protobuf/generated_enum_util.h"
#include "common.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_options_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_options_2eproto {
  static const ::uint32_t offsets[];
};
namespace valhalla {
class AvoidEdge;
struct AvoidEdgeDefaultTypeInternal;
extern AvoidEdgeDefaultTypeInternal _AvoidEdge_default_instance_;
class Contour;
struct ContourDefaultTypeInternal;
extern ContourDefaultTypeInternal _Contour_default_instance_;
class Costing;
struct CostingDefaultTypeInternal;
extern CostingDefaultTypeInternal _Costing_default_instance_;
class Costing_Options;
struct Costing_OptionsDefaultTypeInternal;
extern Costing_OptionsDefaultTypeInternal _Costing_Options_default_instance_;
class Options;
struct OptionsDefaultTypeInternal;
extern OptionsDefaultTypeInternal _Options_default_instance_;
class PbfFieldSelector;
struct PbfFieldSelectorDefaultTypeInternal;
extern PbfFieldSelectorDefaultTypeInternal _PbfFieldSelector_default_instance_;
class Ring;
struct RingDefaultTypeInternal;
extern RingDefaultTypeInternal _Ring_default_instance_;
}  // namespace valhalla
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace valhalla {
enum Costing_Type : int {
  Costing_Type_none_ = 0,
  Costing_Type_bicycle = 1,
  Costing_Type_bus = 2,
  Costing_Type_motor_scooter = 3,
  Costing_Type_multimodal = 4,
  Costing_Type_pedestrian = 5,
  Costing_Type_transit = 6,
  Costing_Type_truck = 7,
  Costing_Type_motorcycle = 8,
  Costing_Type_taxi = 9,
  Costing_Type_auto_ = 10,
  Costing_Type_bikeshare = 11,
  Costing_Type_Costing_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Costing_Type_Costing_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Costing_Type_IsValid(int value);
extern const uint32_t Costing_Type_internal_data_[];
constexpr Costing_Type Costing_Type_Type_MIN = static_cast<Costing_Type>(0);
constexpr Costing_Type Costing_Type_Type_MAX = static_cast<Costing_Type>(11);
constexpr int Costing_Type_Type_ARRAYSIZE = 11 + 1;
const std::string& Costing_Type_Name(Costing_Type value);
template <typename T>
const std::string& Costing_Type_Name(T value) {
  static_assert(std::is_same<T, Costing_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return Costing_Type_Name(static_cast<Costing_Type>(value));
}
const std::string& Costing_Type_Name(Costing_Type value);
bool Costing_Type_Parse(absl::string_view name, Costing_Type* value);
enum Options_Units : int {
  Options_Units_kilometers = 0,
  Options_Units_miles = 1,
  Options_Units_Options_Units_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Options_Units_Options_Units_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Options_Units_IsValid(int value);
extern const uint32_t Options_Units_internal_data_[];
constexpr Options_Units Options_Units_Units_MIN = static_cast<Options_Units>(0);
constexpr Options_Units Options_Units_Units_MAX = static_cast<Options_Units>(1);
constexpr int Options_Units_Units_ARRAYSIZE = 1 + 1;
const std::string& Options_Units_Name(Options_Units value);
template <typename T>
const std::string& Options_Units_Name(T value) {
  static_assert(std::is_same<T, Options_Units>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Units_Name().");
  return Options_Units_Name(static_cast<Options_Units>(value));
}
const std::string& Options_Units_Name(Options_Units value);
bool Options_Units_Parse(absl::string_view name, Options_Units* value);
enum Options_Format : int {
  Options_Format_json = 0,
  Options_Format_gpx = 1,
  Options_Format_osrm = 2,
  Options_Format_pbf = 3,
  Options_Format_geotiff = 4,
  Options_Format_Options_Format_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Options_Format_Options_Format_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Options_Format_IsValid(int value);
extern const uint32_t Options_Format_internal_data_[];
constexpr Options_Format Options_Format_Format_MIN = static_cast<Options_Format>(0);
constexpr Options_Format Options_Format_Format_MAX = static_cast<Options_Format>(4);
constexpr int Options_Format_Format_ARRAYSIZE = 4 + 1;
const std::string& Options_Format_Name(Options_Format value);
template <typename T>
const std::string& Options_Format_Name(T value) {
  static_assert(std::is_same<T, Options_Format>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Format_Name().");
  return Options_Format_Name(static_cast<Options_Format>(value));
}
const std::string& Options_Format_Name(Options_Format value);
bool Options_Format_Parse(absl::string_view name, Options_Format* value);
enum Options_Action : int {
  Options_Action_no_action = 0,
  Options_Action_route = 1,
  Options_Action_locate = 2,
  Options_Action_sources_to_targets = 3,
  Options_Action_optimized_route = 4,
  Options_Action_isochrone = 5,
  Options_Action_trace_route = 6,
  Options_Action_trace_attributes = 7,
  Options_Action_height = 8,
  Options_Action_transit_available = 9,
  Options_Action_expansion = 10,
  Options_Action_centroid = 11,
  Options_Action_status = 12,
  Options_Action_Options_Action_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Options_Action_Options_Action_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Options_Action_IsValid(int value);
extern const uint32_t Options_Action_internal_data_[];
constexpr Options_Action Options_Action_Action_MIN = static_cast<Options_Action>(0);
constexpr Options_Action Options_Action_Action_MAX = static_cast<Options_Action>(12);
constexpr int Options_Action_Action_ARRAYSIZE = 12 + 1;
const std::string& Options_Action_Name(Options_Action value);
template <typename T>
const std::string& Options_Action_Name(T value) {
  static_assert(std::is_same<T, Options_Action>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Action_Name().");
  return Options_Action_Name(static_cast<Options_Action>(value));
}
const std::string& Options_Action_Name(Options_Action value);
bool Options_Action_Parse(absl::string_view name, Options_Action* value);
enum Options_DateTimeType : int {
  Options_DateTimeType_no_time = 0,
  Options_DateTimeType_current = 1,
  Options_DateTimeType_depart_at = 2,
  Options_DateTimeType_arrive_by = 3,
  Options_DateTimeType_invariant = 4,
  Options_DateTimeType_Options_DateTimeType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Options_DateTimeType_Options_DateTimeType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Options_DateTimeType_IsValid(int value);
extern const uint32_t Options_DateTimeType_internal_data_[];
constexpr Options_DateTimeType Options_DateTimeType_DateTimeType_MIN = static_cast<Options_DateTimeType>(0);
constexpr Options_DateTimeType Options_DateTimeType_DateTimeType_MAX = static_cast<Options_DateTimeType>(4);
constexpr int Options_DateTimeType_DateTimeType_ARRAYSIZE = 4 + 1;
const std::string& Options_DateTimeType_Name(Options_DateTimeType value);
template <typename T>
const std::string& Options_DateTimeType_Name(T value) {
  static_assert(std::is_same<T, Options_DateTimeType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DateTimeType_Name().");
  return Options_DateTimeType_Name(static_cast<Options_DateTimeType>(value));
}
const std::string& Options_DateTimeType_Name(Options_DateTimeType value);
bool Options_DateTimeType_Parse(absl::string_view name, Options_DateTimeType* value);
enum Options_ExpansionProperties : int {
  Options_ExpansionProperties_cost = 0,
  Options_ExpansionProperties_duration = 1,
  Options_ExpansionProperties_distance = 2,
  Options_ExpansionProperties_edge_status = 3,
  Options_ExpansionProperties_edge_id = 4,
  Options_ExpansionProperties_pred_edge_id = 5,
  Options_ExpansionProperties_expansion_type = 6,
  Options_ExpansionProperties_Options_ExpansionProperties_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Options_ExpansionProperties_Options_ExpansionProperties_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Options_ExpansionProperties_IsValid(int value);
extern const uint32_t Options_ExpansionProperties_internal_data_[];
constexpr Options_ExpansionProperties Options_ExpansionProperties_ExpansionProperties_MIN = static_cast<Options_ExpansionProperties>(0);
constexpr Options_ExpansionProperties Options_ExpansionProperties_ExpansionProperties_MAX = static_cast<Options_ExpansionProperties>(6);
constexpr int Options_ExpansionProperties_ExpansionProperties_ARRAYSIZE = 6 + 1;
const std::string& Options_ExpansionProperties_Name(Options_ExpansionProperties value);
template <typename T>
const std::string& Options_ExpansionProperties_Name(T value) {
  static_assert(std::is_same<T, Options_ExpansionProperties>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ExpansionProperties_Name().");
  return Options_ExpansionProperties_Name(static_cast<Options_ExpansionProperties>(value));
}
const std::string& Options_ExpansionProperties_Name(Options_ExpansionProperties value);
bool Options_ExpansionProperties_Parse(absl::string_view name, Options_ExpansionProperties* value);
enum ShapeMatch : int {
  walk_or_snap = 0,
  edge_walk = 1,
  map_snap = 2,
  ShapeMatch_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ShapeMatch_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ShapeMatch_IsValid(int value);
extern const uint32_t ShapeMatch_internal_data_[];
constexpr ShapeMatch ShapeMatch_MIN = static_cast<ShapeMatch>(0);
constexpr ShapeMatch ShapeMatch_MAX = static_cast<ShapeMatch>(2);
constexpr int ShapeMatch_ARRAYSIZE = 2 + 1;
const std::string& ShapeMatch_Name(ShapeMatch value);
template <typename T>
const std::string& ShapeMatch_Name(T value) {
  static_assert(std::is_same<T, ShapeMatch>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ShapeMatch_Name().");
  return ShapeMatch_Name(static_cast<ShapeMatch>(value));
}
const std::string& ShapeMatch_Name(ShapeMatch value);
bool ShapeMatch_Parse(absl::string_view name, ShapeMatch* value);
enum FilterAction : int {
  no_action = 0,
  exclude = 1,
  include = 2,
  FilterAction_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  FilterAction_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool FilterAction_IsValid(int value);
extern const uint32_t FilterAction_internal_data_[];
constexpr FilterAction FilterAction_MIN = static_cast<FilterAction>(0);
constexpr FilterAction FilterAction_MAX = static_cast<FilterAction>(2);
constexpr int FilterAction_ARRAYSIZE = 2 + 1;
const std::string& FilterAction_Name(FilterAction value);
template <typename T>
const std::string& FilterAction_Name(T value) {
  static_assert(std::is_same<T, FilterAction>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FilterAction_Name().");
  return FilterAction_Name(static_cast<FilterAction>(value));
}
const std::string& FilterAction_Name(FilterAction value);
bool FilterAction_Parse(absl::string_view name, FilterAction* value);
enum DirectionsType : int {
  instructions = 0,
  none = 1,
  maneuvers = 2,
  DirectionsType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DirectionsType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DirectionsType_IsValid(int value);
extern const uint32_t DirectionsType_internal_data_[];
constexpr DirectionsType DirectionsType_MIN = static_cast<DirectionsType>(0);
constexpr DirectionsType DirectionsType_MAX = static_cast<DirectionsType>(2);
constexpr int DirectionsType_ARRAYSIZE = 2 + 1;
const std::string& DirectionsType_Name(DirectionsType value);
template <typename T>
const std::string& DirectionsType_Name(T value) {
  static_assert(std::is_same<T, DirectionsType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DirectionsType_Name().");
  return DirectionsType_Name(static_cast<DirectionsType>(value));
}
const std::string& DirectionsType_Name(DirectionsType value);
bool DirectionsType_Parse(absl::string_view name, DirectionsType* value);
enum ShapeFormat : int {
  polyline6 = 0,
  polyline5 = 1,
  geojson = 2,
  no_shape = 3,
  ShapeFormat_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ShapeFormat_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ShapeFormat_IsValid(int value);
extern const uint32_t ShapeFormat_internal_data_[];
constexpr ShapeFormat ShapeFormat_MIN = static_cast<ShapeFormat>(0);
constexpr ShapeFormat ShapeFormat_MAX = static_cast<ShapeFormat>(3);
constexpr int ShapeFormat_ARRAYSIZE = 3 + 1;
const std::string& ShapeFormat_Name(ShapeFormat value);
template <typename T>
const std::string& ShapeFormat_Name(T value) {
  static_assert(std::is_same<T, ShapeFormat>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ShapeFormat_Name().");
  return ShapeFormat_Name(static_cast<ShapeFormat>(value));
}
const std::string& ShapeFormat_Name(ShapeFormat value);
bool ShapeFormat_Parse(absl::string_view name, ShapeFormat* value);

// ===================================================================


// -------------------------------------------------------------------

class PbfFieldSelector final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.PbfFieldSelector) */ {
 public:
  inline PbfFieldSelector() : PbfFieldSelector(nullptr) {}
  ~PbfFieldSelector() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PbfFieldSelector(::google::protobuf::internal::ConstantInitialized);

  inline PbfFieldSelector(const PbfFieldSelector& from)
      : PbfFieldSelector(nullptr, from) {}
  PbfFieldSelector(PbfFieldSelector&& from) noexcept
    : PbfFieldSelector() {
    *this = ::std::move(from);
  }

  inline PbfFieldSelector& operator=(const PbfFieldSelector& from) {
    CopyFrom(from);
    return *this;
  }
  inline PbfFieldSelector& operator=(PbfFieldSelector&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PbfFieldSelector& default_instance() {
    return *internal_default_instance();
  }
  static inline const PbfFieldSelector* internal_default_instance() {
    return reinterpret_cast<const PbfFieldSelector*>(
               &_PbfFieldSelector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PbfFieldSelector& a, PbfFieldSelector& b) {
    a.Swap(&b);
  }
  inline void Swap(PbfFieldSelector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PbfFieldSelector* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PbfFieldSelector* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PbfFieldSelector>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const PbfFieldSelector& from);
  void MergeFrom(const PbfFieldSelector& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PbfFieldSelector* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.PbfFieldSelector";
  }
  protected:
  explicit PbfFieldSelector(::google::protobuf::Arena* arena);
  PbfFieldSelector(::google::protobuf::Arena* arena, const PbfFieldSelector& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 1,
    kTripFieldNumber = 2,
    kDirectionsFieldNumber = 3,
    kStatusFieldNumber = 4,
    kMatrixFieldNumber = 5,
    kIsochroneFieldNumber = 6,
    kExpansionFieldNumber = 9,
  };
  // bool options = 1;
  void clear_options() ;
  bool options() const;
  void set_options(bool value);

  private:
  bool _internal_options() const;
  void _internal_set_options(bool value);

  public:
  // bool trip = 2;
  void clear_trip() ;
  bool trip() const;
  void set_trip(bool value);

  private:
  bool _internal_trip() const;
  void _internal_set_trip(bool value);

  public:
  // bool directions = 3;
  void clear_directions() ;
  bool directions() const;
  void set_directions(bool value);

  private:
  bool _internal_directions() const;
  void _internal_set_directions(bool value);

  public:
  // bool status = 4;
  void clear_status() ;
  bool status() const;
  void set_status(bool value);

  private:
  bool _internal_status() const;
  void _internal_set_status(bool value);

  public:
  // bool matrix = 5;
  void clear_matrix() ;
  bool matrix() const;
  void set_matrix(bool value);

  private:
  bool _internal_matrix() const;
  void _internal_set_matrix(bool value);

  public:
  // bool isochrone = 6;
  void clear_isochrone() ;
  bool isochrone() const;
  void set_isochrone(bool value);

  private:
  bool _internal_isochrone() const;
  void _internal_set_isochrone(bool value);

  public:
  // bool expansion = 9;
  void clear_expansion() ;
  bool expansion() const;
  void set_expansion(bool value);

  private:
  bool _internal_expansion() const;
  void _internal_set_expansion(bool value);

  public:
  // @@protoc_insertion_point(class_scope:valhalla.PbfFieldSelector)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    bool options_;
    bool trip_;
    bool directions_;
    bool status_;
    bool matrix_;
    bool isochrone_;
    bool expansion_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_options_2eproto;
};// -------------------------------------------------------------------

class Contour final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.Contour) */ {
 public:
  inline Contour() : Contour(nullptr) {}
  ~Contour() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Contour(::google::protobuf::internal::ConstantInitialized);

  inline Contour(const Contour& from)
      : Contour(nullptr, from) {}
  Contour(Contour&& from) noexcept
    : Contour() {
    *this = ::std::move(from);
  }

  inline Contour& operator=(const Contour& from) {
    CopyFrom(from);
    return *this;
  }
  inline Contour& operator=(Contour&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Contour& default_instance() {
    return *internal_default_instance();
  }
  enum HasTimeCase {
    kTime = 1,
    HAS_TIME_NOT_SET = 0,
  };

  enum HasColorCase {
    kColor = 2,
    HAS_COLOR_NOT_SET = 0,
  };

  enum HasDistanceCase {
    kDistance = 3,
    HAS_DISTANCE_NOT_SET = 0,
  };

  static inline const Contour* internal_default_instance() {
    return reinterpret_cast<const Contour*>(
               &_Contour_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Contour& a, Contour& b) {
    a.Swap(&b);
  }
  inline void Swap(Contour* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Contour* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Contour* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Contour>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Contour& from);
  void MergeFrom(const Contour& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Contour* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.Contour";
  }
  protected:
  explicit Contour(::google::protobuf::Arena* arena);
  Contour(::google::protobuf::Arena* arena, const Contour& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeFieldNumber = 1,
    kColorFieldNumber = 2,
    kDistanceFieldNumber = 3,
  };
  // float time = 1;
  bool has_time() const;
  void clear_time() ;
  float time() const;
  void set_time(float value);

  private:
  float _internal_time() const;
  void _internal_set_time(float value);

  public:
  // string color = 2;
  bool has_color() const;
  void clear_color() ;
  const std::string& color() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_color(Arg_&& arg, Args_... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* value);

  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(
      const std::string& value);
  std::string* _internal_mutable_color();

  public:
  // float distance = 3;
  bool has_distance() const;
  void clear_distance() ;
  float distance() const;
  void set_distance(float value);

  private:
  float _internal_distance() const;
  void _internal_set_distance(float value);

  public:
  void clear_has_time();
  HasTimeCase has_time_case() const;
  void clear_has_color();
  HasColorCase has_color_case() const;
  void clear_has_distance();
  HasDistanceCase has_distance_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.Contour)
 private:
  class _Internal;
  void set_has_time();
  void set_has_color();
  void set_has_distance();

  inline bool has_has_time() const;
  inline void clear_has_has_time();

  inline bool has_has_color() const;
  inline void clear_has_has_color();

  inline bool has_has_distance() const;
  inline void clear_has_has_distance();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 0,
      30, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union HasTimeUnion {
      constexpr HasTimeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float time_;
    } has_time_;
    union HasColorUnion {
      constexpr HasColorUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr color_;
    } has_color_;
    union HasDistanceUnion {
      constexpr HasDistanceUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float distance_;
    } has_distance_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[3];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_options_2eproto;
};// -------------------------------------------------------------------

class AvoidEdge final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.AvoidEdge) */ {
 public:
  inline AvoidEdge() : AvoidEdge(nullptr) {}
  ~AvoidEdge() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AvoidEdge(::google::protobuf::internal::ConstantInitialized);

  inline AvoidEdge(const AvoidEdge& from)
      : AvoidEdge(nullptr, from) {}
  AvoidEdge(AvoidEdge&& from) noexcept
    : AvoidEdge() {
    *this = ::std::move(from);
  }

  inline AvoidEdge& operator=(const AvoidEdge& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvoidEdge& operator=(AvoidEdge&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AvoidEdge& default_instance() {
    return *internal_default_instance();
  }
  enum HasIdCase {
    kId = 1,
    HAS_ID_NOT_SET = 0,
  };

  enum HasPercentAlongCase {
    kPercentAlong = 2,
    HAS_PERCENT_ALONG_NOT_SET = 0,
  };

  static inline const AvoidEdge* internal_default_instance() {
    return reinterpret_cast<const AvoidEdge*>(
               &_AvoidEdge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AvoidEdge& a, AvoidEdge& b) {
    a.Swap(&b);
  }
  inline void Swap(AvoidEdge* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvoidEdge* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvoidEdge* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AvoidEdge>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const AvoidEdge& from);
  void MergeFrom(const AvoidEdge& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AvoidEdge* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.AvoidEdge";
  }
  protected:
  explicit AvoidEdge(::google::protobuf::Arena* arena);
  AvoidEdge(::google::protobuf::Arena* arena, const AvoidEdge& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPercentAlongFieldNumber = 2,
  };
  // uint64 id = 1;
  bool has_id() const;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // float percent_along = 2;
  bool has_percent_along() const;
  void clear_percent_along() ;
  float percent_along() const;
  void set_percent_along(float value);

  private:
  float _internal_percent_along() const;
  void _internal_set_percent_along(float value);

  public:
  void clear_has_id();
  HasIdCase has_id_case() const;
  void clear_has_percent_along();
  HasPercentAlongCase has_percent_along_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.AvoidEdge)
 private:
  class _Internal;
  void set_has_id();
  void set_has_percent_along();

  inline bool has_has_id() const;
  inline void clear_has_has_id();

  inline bool has_has_percent_along() const;
  inline void clear_has_has_percent_along();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union HasIdUnion {
      constexpr HasIdUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint64_t id_;
    } has_id_;
    union HasPercentAlongUnion {
      constexpr HasPercentAlongUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float percent_along_;
    } has_percent_along_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[2];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_options_2eproto;
};// -------------------------------------------------------------------

class Ring final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.Ring) */ {
 public:
  inline Ring() : Ring(nullptr) {}
  ~Ring() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Ring(::google::protobuf::internal::ConstantInitialized);

  inline Ring(const Ring& from)
      : Ring(nullptr, from) {}
  Ring(Ring&& from) noexcept
    : Ring() {
    *this = ::std::move(from);
  }

  inline Ring& operator=(const Ring& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ring& operator=(Ring&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Ring& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ring* internal_default_instance() {
    return reinterpret_cast<const Ring*>(
               &_Ring_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Ring& a, Ring& b) {
    a.Swap(&b);
  }
  inline void Swap(Ring* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ring* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ring* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ring>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Ring& from);
  void MergeFrom(const Ring& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Ring* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.Ring";
  }
  protected:
  explicit Ring(::google::protobuf::Arena* arena);
  Ring(::google::protobuf::Arena* arena, const Ring& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCoordsFieldNumber = 1,
  };
  // repeated .valhalla.LatLng coords = 1;
  int coords_size() const;
  private:
  int _internal_coords_size() const;

  public:
  void clear_coords() ;
  ::valhalla::LatLng* mutable_coords(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::LatLng >*
      mutable_coords();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::LatLng>& _internal_coords() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::LatLng>* _internal_mutable_coords();
  public:
  const ::valhalla::LatLng& coords(int index) const;
  ::valhalla::LatLng* add_coords();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::LatLng >&
      coords() const;
  // @@protoc_insertion_point(class_scope:valhalla.Ring)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::valhalla::LatLng > coords_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_options_2eproto;
};// -------------------------------------------------------------------

class Costing_Options final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.Costing.Options) */ {
 public:
  inline Costing_Options() : Costing_Options(nullptr) {}
  ~Costing_Options() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Costing_Options(::google::protobuf::internal::ConstantInitialized);

  inline Costing_Options(const Costing_Options& from)
      : Costing_Options(nullptr, from) {}
  Costing_Options(Costing_Options&& from) noexcept
    : Costing_Options() {
    *this = ::std::move(from);
  }

  inline Costing_Options& operator=(const Costing_Options& from) {
    CopyFrom(from);
    return *this;
  }
  inline Costing_Options& operator=(Costing_Options&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Costing_Options& default_instance() {
    return *internal_default_instance();
  }
  enum HasManeuverPenaltyCase {
    kManeuverPenalty = 1,
    HAS_MANEUVER_PENALTY_NOT_SET = 0,
  };

  enum HasDestinationOnlyPenaltyCase {
    kDestinationOnlyPenalty = 2,
    HAS_DESTINATION_ONLY_PENALTY_NOT_SET = 0,
  };

  enum HasGateCostCase {
    kGateCost = 3,
    HAS_GATE_COST_NOT_SET = 0,
  };

  enum HasGatePenaltyCase {
    kGatePenalty = 4,
    HAS_GATE_PENALTY_NOT_SET = 0,
  };

  enum HasTollBoothCostCase {
    kTollBoothCost = 5,
    HAS_TOLL_BOOTH_COST_NOT_SET = 0,
  };

  enum HasTollBoothPenaltyCase {
    kTollBoothPenalty = 6,
    HAS_TOLL_BOOTH_PENALTY_NOT_SET = 0,
  };

  enum HasAlleyPenaltyCase {
    kAlleyPenalty = 7,
    HAS_ALLEY_PENALTY_NOT_SET = 0,
  };

  enum HasCountryCrossingCostCase {
    kCountryCrossingCost = 8,
    HAS_COUNTRY_CROSSING_COST_NOT_SET = 0,
  };

  enum HasCountryCrossingPenaltyCase {
    kCountryCrossingPenalty = 9,
    HAS_COUNTRY_CROSSING_PENALTY_NOT_SET = 0,
  };

  enum HasFerryCostCase {
    kFerryCost = 10,
    HAS_FERRY_COST_NOT_SET = 0,
  };

  enum HasAvoidBadSurfacesCase {
    kAvoidBadSurfaces = 11,
    HAS_AVOID_BAD_SURFACES_NOT_SET = 0,
  };

  enum HasUseFerryCase {
    kUseFerry = 12,
    HAS_USE_FERRY_NOT_SET = 0,
  };

  enum HasUseHighwaysCase {
    kUseHighways = 13,
    HAS_USE_HIGHWAYS_NOT_SET = 0,
  };

  enum HasUseTollsCase {
    kUseTolls = 14,
    HAS_USE_TOLLS_NOT_SET = 0,
  };

  enum HasUseRoadsCase {
    kUseRoads = 15,
    HAS_USE_ROADS_NOT_SET = 0,
  };

  enum HasMaxDistanceCase {
    kMaxDistance = 16,
    HAS_MAX_DISTANCE_NOT_SET = 0,
  };

  enum HasWalkingSpeedCase {
    kWalkingSpeed = 17,
    HAS_WALKING_SPEED_NOT_SET = 0,
  };

  enum HasStepPenaltyCase {
    kStepPenalty = 18,
    HAS_STEP_PENALTY_NOT_SET = 0,
  };

  enum HasMaxGradeCase {
    kMaxGrade = 19,
    HAS_MAX_GRADE_NOT_SET = 0,
  };

  enum HasMaxHikingDifficultyCase {
    kMaxHikingDifficulty = 20,
    HAS_MAX_HIKING_DIFFICULTY_NOT_SET = 0,
  };

  enum HasModeFactorCase {
    kModeFactor = 21,
    HAS_MODE_FACTOR_NOT_SET = 0,
  };

  enum HasWalkwayFactorCase {
    kWalkwayFactor = 22,
    HAS_WALKWAY_FACTOR_NOT_SET = 0,
  };

  enum HasSidewalkFactorCase {
    kSidewalkFactor = 23,
    HAS_SIDEWALK_FACTOR_NOT_SET = 0,
  };

  enum HasAlleyFactorCase {
    kAlleyFactor = 24,
    HAS_ALLEY_FACTOR_NOT_SET = 0,
  };

  enum HasDrivewayFactorCase {
    kDrivewayFactor = 25,
    HAS_DRIVEWAY_FACTOR_NOT_SET = 0,
  };

  enum HasDrivewayPenaltyCase {
    kDrivewayPenalty = 26,
    HAS_DRIVEWAY_PENALTY_NOT_SET = 0,
  };

  enum HasTransitStartEndMaxDistanceCase {
    kTransitStartEndMaxDistance = 27,
    HAS_TRANSIT_START_END_MAX_DISTANCE_NOT_SET = 0,
  };

  enum HasTransitTransferMaxDistanceCase {
    kTransitTransferMaxDistance = 28,
    HAS_TRANSIT_TRANSFER_MAX_DISTANCE_NOT_SET = 0,
  };

  enum HasTransportTypeCase {
    kTransportType = 29,
    HAS_TRANSPORT_TYPE_NOT_SET = 0,
  };

  enum HasTopSpeedCase {
    kTopSpeed = 30,
    HAS_TOP_SPEED_NOT_SET = 0,
  };

  enum HasUseHillsCase {
    kUseHills = 31,
    HAS_USE_HILLS_NOT_SET = 0,
  };

  enum HasUsePrimaryCase {
    kUsePrimary = 32,
    HAS_USE_PRIMARY_NOT_SET = 0,
  };

  enum HasUseTrailsCase {
    kUseTrails = 33,
    HAS_USE_TRAILS_NOT_SET = 0,
  };

  enum HasLowClassPenaltyCase {
    kLowClassPenalty = 34,
    HAS_LOW_CLASS_PENALTY_NOT_SET = 0,
  };

  enum HasHazmatCase {
    kHazmat = 35,
    HAS_HAZMAT_NOT_SET = 0,
  };

  enum HasWeightCase {
    kWeight = 36,
    HAS_WEIGHT_NOT_SET = 0,
  };

  enum HasAxleLoadCase {
    kAxleLoad = 37,
    HAS_AXLE_LOAD_NOT_SET = 0,
  };

  enum HasHeightCase {
    kHeight = 38,
    HAS_HEIGHT_NOT_SET = 0,
  };

  enum HasWidthCase {
    kWidth = 39,
    HAS_WIDTH_NOT_SET = 0,
  };

  enum HasLengthCase {
    kLength = 40,
    HAS_LENGTH_NOT_SET = 0,
  };

  enum HasCyclingSpeedCase {
    kCyclingSpeed = 41,
    HAS_CYCLING_SPEED_NOT_SET = 0,
  };

  enum HasWheelchairCase {
    kWheelchair = 42,
    HAS_WHEELCHAIR_NOT_SET = 0,
  };

  enum HasBicycleCase {
    kBicycle = 43,
    HAS_BICYCLE_NOT_SET = 0,
  };

  enum HasUseBusCase {
    kUseBus = 44,
    HAS_USE_BUS_NOT_SET = 0,
  };

  enum HasUseRailCase {
    kUseRail = 45,
    HAS_USE_RAIL_NOT_SET = 0,
  };

  enum HasUseTransfersCase {
    kUseTransfers = 46,
    HAS_USE_TRANSFERS_NOT_SET = 0,
  };

  enum HasTransferCostCase {
    kTransferCost = 47,
    HAS_TRANSFER_COST_NOT_SET = 0,
  };

  enum HasTransferPenaltyCase {
    kTransferPenalty = 48,
    HAS_TRANSFER_PENALTY_NOT_SET = 0,
  };

  enum HasFlowMaskCase {
    kFlowMask = 55,
    HAS_FLOW_MASK_NOT_SET = 0,
  };

  enum HasBikeShareCostCase {
    kBikeShareCost = 56,
    HAS_BIKE_SHARE_COST_NOT_SET = 0,
  };

  enum HasBikeSharePenaltyCase {
    kBikeSharePenalty = 57,
    HAS_BIKE_SHARE_PENALTY_NOT_SET = 0,
  };

  enum HasRailFerryCostCase {
    kRailFerryCost = 58,
    HAS_RAIL_FERRY_COST_NOT_SET = 0,
  };

  enum HasUseRailFerryCase {
    kUseRailFerry = 59,
    HAS_USE_RAIL_FERRY_NOT_SET = 0,
  };

  enum HasIgnoreRestrictionsCase {
    kIgnoreRestrictions = 60,
    HAS_IGNORE_RESTRICTIONS_NOT_SET = 0,
  };

  enum HasIgnoreOnewaysCase {
    kIgnoreOneways = 61,
    HAS_IGNORE_ONEWAYS_NOT_SET = 0,
  };

  enum HasIgnoreAccessCase {
    kIgnoreAccess = 62,
    HAS_IGNORE_ACCESS_NOT_SET = 0,
  };

  enum HasIgnoreClosuresCase {
    kIgnoreClosures = 63,
    HAS_IGNORE_CLOSURES_NOT_SET = 0,
  };

  enum HasShortestCase {
    kShortest = 64,
    HAS_SHORTEST_NOT_SET = 0,
  };

  enum HasServicePenaltyCase {
    kServicePenalty = 65,
    HAS_SERVICE_PENALTY_NOT_SET = 0,
  };

  enum HasUseTracksCase {
    kUseTracks = 66,
    HAS_USE_TRACKS_NOT_SET = 0,
  };

  enum HasUseDistanceCase {
    kUseDistance = 67,
    HAS_USE_DISTANCE_NOT_SET = 0,
  };

  enum HasUseLivingStreetsCase {
    kUseLivingStreets = 68,
    HAS_USE_LIVING_STREETS_NOT_SET = 0,
  };

  enum HasServiceFactorCase {
    kServiceFactor = 69,
    HAS_SERVICE_FACTOR_NOT_SET = 0,
  };

  enum HasClosureFactorCase {
    kClosureFactor = 70,
    HAS_CLOSURE_FACTOR_NOT_SET = 0,
  };

  enum HasPrivateAccessPenaltyCase {
    kPrivateAccessPenalty = 71,
    HAS_PRIVATE_ACCESS_PENALTY_NOT_SET = 0,
  };

  enum HasExcludeUnpavedCase {
    kExcludeUnpaved = 72,
    HAS_EXCLUDE_UNPAVED_NOT_SET = 0,
  };

  enum HasIncludeHotCase {
    kIncludeHot = 73,
    HAS_INCLUDE_HOT_NOT_SET = 0,
  };

  enum HasIncludeHov2Case {
    kIncludeHov2 = 74,
    HAS_INCLUDE_HOV2_NOT_SET = 0,
  };

  enum HasIncludeHov3Case {
    kIncludeHov3 = 75,
    HAS_INCLUDE_HOV3_NOT_SET = 0,
  };

  enum HasExcludeCashOnlyTollsCase {
    kExcludeCashOnlyTolls = 76,
    HAS_EXCLUDE_CASH_ONLY_TOLLS_NOT_SET = 0,
  };

  enum HasRestrictionProbabilityCase {
    kRestrictionProbability = 77,
    HAS_RESTRICTION_PROBABILITY_NOT_SET = 0,
  };

  enum HasElevatorPenaltyCase {
    kElevatorPenalty = 79,
    HAS_ELEVATOR_PENALTY_NOT_SET = 0,
  };

  enum HasHgvNoAccessPenaltyCase {
    kHgvNoAccessPenalty = 85,
    HAS_HGV_NO_ACCESS_PENALTY_NOT_SET = 0,
  };

  static inline const Costing_Options* internal_default_instance() {
    return reinterpret_cast<const Costing_Options*>(
               &_Costing_Options_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Costing_Options& a, Costing_Options& b) {
    a.Swap(&b);
  }
  inline void Swap(Costing_Options* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Costing_Options* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Costing_Options* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Costing_Options>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Costing_Options& from);
  void MergeFrom(const Costing_Options& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Costing_Options* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.Costing.Options";
  }
  protected:
  explicit Costing_Options(::google::protobuf::Arena* arena);
  Costing_Options(::google::protobuf::Arena* arena, const Costing_Options& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterStopIdsFieldNumber = 50,
    kFilterOperatorIdsFieldNumber = 52,
    kFilterRouteIdsFieldNumber = 54,
    kExcludeEdgesFieldNumber = 78,
    kFilterStopActionFieldNumber = 49,
    kFilterOperatorActionFieldNumber = 51,
    kFilterRouteActionFieldNumber = 53,
    kFixedSpeedFieldNumber = 80,
    kAxleCountFieldNumber = 81,
    kUseLitFieldNumber = 82,
    kDisableHierarchyPruningFieldNumber = 83,
    kIgnoreNonVehicularRestrictionsFieldNumber = 84,
    kUseTruckRouteFieldNumber = 86,
    kManeuverPenaltyFieldNumber = 1,
    kDestinationOnlyPenaltyFieldNumber = 2,
    kGateCostFieldNumber = 3,
    kGatePenaltyFieldNumber = 4,
    kTollBoothCostFieldNumber = 5,
    kTollBoothPenaltyFieldNumber = 6,
    kAlleyPenaltyFieldNumber = 7,
    kCountryCrossingCostFieldNumber = 8,
    kCountryCrossingPenaltyFieldNumber = 9,
    kFerryCostFieldNumber = 10,
    kAvoidBadSurfacesFieldNumber = 11,
    kUseFerryFieldNumber = 12,
    kUseHighwaysFieldNumber = 13,
    kUseTollsFieldNumber = 14,
    kUseRoadsFieldNumber = 15,
    kMaxDistanceFieldNumber = 16,
    kWalkingSpeedFieldNumber = 17,
    kStepPenaltyFieldNumber = 18,
    kMaxGradeFieldNumber = 19,
    kMaxHikingDifficultyFieldNumber = 20,
    kModeFactorFieldNumber = 21,
    kWalkwayFactorFieldNumber = 22,
    kSidewalkFactorFieldNumber = 23,
    kAlleyFactorFieldNumber = 24,
    kDrivewayFactorFieldNumber = 25,
    kDrivewayPenaltyFieldNumber = 26,
    kTransitStartEndMaxDistanceFieldNumber = 27,
    kTransitTransferMaxDistanceFieldNumber = 28,
    kTransportTypeFieldNumber = 29,
    kTopSpeedFieldNumber = 30,
    kUseHillsFieldNumber = 31,
    kUsePrimaryFieldNumber = 32,
    kUseTrailsFieldNumber = 33,
    kLowClassPenaltyFieldNumber = 34,
    kHazmatFieldNumber = 35,
    kWeightFieldNumber = 36,
    kAxleLoadFieldNumber = 37,
    kHeightFieldNumber = 38,
    kWidthFieldNumber = 39,
    kLengthFieldNumber = 40,
    kCyclingSpeedFieldNumber = 41,
    kWheelchairFieldNumber = 42,
    kBicycleFieldNumber = 43,
    kUseBusFieldNumber = 44,
    kUseRailFieldNumber = 45,
    kUseTransfersFieldNumber = 46,
    kTransferCostFieldNumber = 47,
    kTransferPenaltyFieldNumber = 48,
    kFlowMaskFieldNumber = 55,
    kBikeShareCostFieldNumber = 56,
    kBikeSharePenaltyFieldNumber = 57,
    kRailFerryCostFieldNumber = 58,
    kUseRailFerryFieldNumber = 59,
    kIgnoreRestrictionsFieldNumber = 60,
    kIgnoreOnewaysFieldNumber = 61,
    kIgnoreAccessFieldNumber = 62,
    kIgnoreClosuresFieldNumber = 63,
    kShortestFieldNumber = 64,
    kServicePenaltyFieldNumber = 65,
    kUseTracksFieldNumber = 66,
    kUseDistanceFieldNumber = 67,
    kUseLivingStreetsFieldNumber = 68,
    kServiceFactorFieldNumber = 69,
    kClosureFactorFieldNumber = 70,
    kPrivateAccessPenaltyFieldNumber = 71,
    kExcludeUnpavedFieldNumber = 72,
    kIncludeHotFieldNumber = 73,
    kIncludeHov2FieldNumber = 74,
    kIncludeHov3FieldNumber = 75,
    kExcludeCashOnlyTollsFieldNumber = 76,
    kRestrictionProbabilityFieldNumber = 77,
    kElevatorPenaltyFieldNumber = 79,
    kHgvNoAccessPenaltyFieldNumber = 85,
  };
  // repeated string filter_stop_ids = 50;
  int filter_stop_ids_size() const;
  private:
  int _internal_filter_stop_ids_size() const;

  public:
  void clear_filter_stop_ids() ;
  const std::string& filter_stop_ids(int index) const;
  std::string* mutable_filter_stop_ids(int index);
  void set_filter_stop_ids(int index, const std::string& value);
  void set_filter_stop_ids(int index, std::string&& value);
  void set_filter_stop_ids(int index, const char* value);
  void set_filter_stop_ids(int index, const char* value, std::size_t size);
  void set_filter_stop_ids(int index, absl::string_view value);
  std::string* add_filter_stop_ids();
  void add_filter_stop_ids(const std::string& value);
  void add_filter_stop_ids(std::string&& value);
  void add_filter_stop_ids(const char* value);
  void add_filter_stop_ids(const char* value, std::size_t size);
  void add_filter_stop_ids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& filter_stop_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_filter_stop_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_filter_stop_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_filter_stop_ids();

  public:
  // repeated string filter_operator_ids = 52;
  int filter_operator_ids_size() const;
  private:
  int _internal_filter_operator_ids_size() const;

  public:
  void clear_filter_operator_ids() ;
  const std::string& filter_operator_ids(int index) const;
  std::string* mutable_filter_operator_ids(int index);
  void set_filter_operator_ids(int index, const std::string& value);
  void set_filter_operator_ids(int index, std::string&& value);
  void set_filter_operator_ids(int index, const char* value);
  void set_filter_operator_ids(int index, const char* value, std::size_t size);
  void set_filter_operator_ids(int index, absl::string_view value);
  std::string* add_filter_operator_ids();
  void add_filter_operator_ids(const std::string& value);
  void add_filter_operator_ids(std::string&& value);
  void add_filter_operator_ids(const char* value);
  void add_filter_operator_ids(const char* value, std::size_t size);
  void add_filter_operator_ids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& filter_operator_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_filter_operator_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_filter_operator_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_filter_operator_ids();

  public:
  // repeated string filter_route_ids = 54;
  int filter_route_ids_size() const;
  private:
  int _internal_filter_route_ids_size() const;

  public:
  void clear_filter_route_ids() ;
  const std::string& filter_route_ids(int index) const;
  std::string* mutable_filter_route_ids(int index);
  void set_filter_route_ids(int index, const std::string& value);
  void set_filter_route_ids(int index, std::string&& value);
  void set_filter_route_ids(int index, const char* value);
  void set_filter_route_ids(int index, const char* value, std::size_t size);
  void set_filter_route_ids(int index, absl::string_view value);
  std::string* add_filter_route_ids();
  void add_filter_route_ids(const std::string& value);
  void add_filter_route_ids(std::string&& value);
  void add_filter_route_ids(const char* value);
  void add_filter_route_ids(const char* value, std::size_t size);
  void add_filter_route_ids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& filter_route_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_filter_route_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_filter_route_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_filter_route_ids();

  public:
  // repeated .valhalla.AvoidEdge exclude_edges = 78;
  int exclude_edges_size() const;
  private:
  int _internal_exclude_edges_size() const;

  public:
  void clear_exclude_edges() ;
  ::valhalla::AvoidEdge* mutable_exclude_edges(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::AvoidEdge >*
      mutable_exclude_edges();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::AvoidEdge>& _internal_exclude_edges() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::AvoidEdge>* _internal_mutable_exclude_edges();
  public:
  const ::valhalla::AvoidEdge& exclude_edges(int index) const;
  ::valhalla::AvoidEdge* add_exclude_edges();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::AvoidEdge >&
      exclude_edges() const;
  // .valhalla.FilterAction filter_stop_action = 49;
  void clear_filter_stop_action() ;
  ::valhalla::FilterAction filter_stop_action() const;
  void set_filter_stop_action(::valhalla::FilterAction value);

  private:
  ::valhalla::FilterAction _internal_filter_stop_action() const;
  void _internal_set_filter_stop_action(::valhalla::FilterAction value);

  public:
  // .valhalla.FilterAction filter_operator_action = 51;
  void clear_filter_operator_action() ;
  ::valhalla::FilterAction filter_operator_action() const;
  void set_filter_operator_action(::valhalla::FilterAction value);

  private:
  ::valhalla::FilterAction _internal_filter_operator_action() const;
  void _internal_set_filter_operator_action(::valhalla::FilterAction value);

  public:
  // .valhalla.FilterAction filter_route_action = 53;
  void clear_filter_route_action() ;
  ::valhalla::FilterAction filter_route_action() const;
  void set_filter_route_action(::valhalla::FilterAction value);

  private:
  ::valhalla::FilterAction _internal_filter_route_action() const;
  void _internal_set_filter_route_action(::valhalla::FilterAction value);

  public:
  // uint32 fixed_speed = 80;
  void clear_fixed_speed() ;
  ::uint32_t fixed_speed() const;
  void set_fixed_speed(::uint32_t value);

  private:
  ::uint32_t _internal_fixed_speed() const;
  void _internal_set_fixed_speed(::uint32_t value);

  public:
  // uint32 axle_count = 81;
  void clear_axle_count() ;
  ::uint32_t axle_count() const;
  void set_axle_count(::uint32_t value);

  private:
  ::uint32_t _internal_axle_count() const;
  void _internal_set_axle_count(::uint32_t value);

  public:
  // float use_lit = 82;
  void clear_use_lit() ;
  float use_lit() const;
  void set_use_lit(float value);

  private:
  float _internal_use_lit() const;
  void _internal_set_use_lit(float value);

  public:
  // bool disable_hierarchy_pruning = 83;
  void clear_disable_hierarchy_pruning() ;
  bool disable_hierarchy_pruning() const;
  void set_disable_hierarchy_pruning(bool value);

  private:
  bool _internal_disable_hierarchy_pruning() const;
  void _internal_set_disable_hierarchy_pruning(bool value);

  public:
  // bool ignore_non_vehicular_restrictions = 84;
  void clear_ignore_non_vehicular_restrictions() ;
  bool ignore_non_vehicular_restrictions() const;
  void set_ignore_non_vehicular_restrictions(bool value);

  private:
  bool _internal_ignore_non_vehicular_restrictions() const;
  void _internal_set_ignore_non_vehicular_restrictions(bool value);

  public:
  // float use_truck_route = 86;
  void clear_use_truck_route() ;
  float use_truck_route() const;
  void set_use_truck_route(float value);

  private:
  float _internal_use_truck_route() const;
  void _internal_set_use_truck_route(float value);

  public:
  // float maneuver_penalty = 1;
  bool has_maneuver_penalty() const;
  void clear_maneuver_penalty() ;
  float maneuver_penalty() const;
  void set_maneuver_penalty(float value);

  private:
  float _internal_maneuver_penalty() const;
  void _internal_set_maneuver_penalty(float value);

  public:
  // float destination_only_penalty = 2;
  bool has_destination_only_penalty() const;
  void clear_destination_only_penalty() ;
  float destination_only_penalty() const;
  void set_destination_only_penalty(float value);

  private:
  float _internal_destination_only_penalty() const;
  void _internal_set_destination_only_penalty(float value);

  public:
  // float gate_cost = 3;
  bool has_gate_cost() const;
  void clear_gate_cost() ;
  float gate_cost() const;
  void set_gate_cost(float value);

  private:
  float _internal_gate_cost() const;
  void _internal_set_gate_cost(float value);

  public:
  // float gate_penalty = 4;
  bool has_gate_penalty() const;
  void clear_gate_penalty() ;
  float gate_penalty() const;
  void set_gate_penalty(float value);

  private:
  float _internal_gate_penalty() const;
  void _internal_set_gate_penalty(float value);

  public:
  // float toll_booth_cost = 5;
  bool has_toll_booth_cost() const;
  void clear_toll_booth_cost() ;
  float toll_booth_cost() const;
  void set_toll_booth_cost(float value);

  private:
  float _internal_toll_booth_cost() const;
  void _internal_set_toll_booth_cost(float value);

  public:
  // float toll_booth_penalty = 6;
  bool has_toll_booth_penalty() const;
  void clear_toll_booth_penalty() ;
  float toll_booth_penalty() const;
  void set_toll_booth_penalty(float value);

  private:
  float _internal_toll_booth_penalty() const;
  void _internal_set_toll_booth_penalty(float value);

  public:
  // float alley_penalty = 7;
  bool has_alley_penalty() const;
  void clear_alley_penalty() ;
  float alley_penalty() const;
  void set_alley_penalty(float value);

  private:
  float _internal_alley_penalty() const;
  void _internal_set_alley_penalty(float value);

  public:
  // float country_crossing_cost = 8;
  bool has_country_crossing_cost() const;
  void clear_country_crossing_cost() ;
  float country_crossing_cost() const;
  void set_country_crossing_cost(float value);

  private:
  float _internal_country_crossing_cost() const;
  void _internal_set_country_crossing_cost(float value);

  public:
  // float country_crossing_penalty = 9;
  bool has_country_crossing_penalty() const;
  void clear_country_crossing_penalty() ;
  float country_crossing_penalty() const;
  void set_country_crossing_penalty(float value);

  private:
  float _internal_country_crossing_penalty() const;
  void _internal_set_country_crossing_penalty(float value);

  public:
  // float ferry_cost = 10;
  bool has_ferry_cost() const;
  void clear_ferry_cost() ;
  float ferry_cost() const;
  void set_ferry_cost(float value);

  private:
  float _internal_ferry_cost() const;
  void _internal_set_ferry_cost(float value);

  public:
  // float avoid_bad_surfaces = 11;
  bool has_avoid_bad_surfaces() const;
  void clear_avoid_bad_surfaces() ;
  float avoid_bad_surfaces() const;
  void set_avoid_bad_surfaces(float value);

  private:
  float _internal_avoid_bad_surfaces() const;
  void _internal_set_avoid_bad_surfaces(float value);

  public:
  // float use_ferry = 12;
  bool has_use_ferry() const;
  void clear_use_ferry() ;
  float use_ferry() const;
  void set_use_ferry(float value);

  private:
  float _internal_use_ferry() const;
  void _internal_set_use_ferry(float value);

  public:
  // float use_highways = 13;
  bool has_use_highways() const;
  void clear_use_highways() ;
  float use_highways() const;
  void set_use_highways(float value);

  private:
  float _internal_use_highways() const;
  void _internal_set_use_highways(float value);

  public:
  // float use_tolls = 14;
  bool has_use_tolls() const;
  void clear_use_tolls() ;
  float use_tolls() const;
  void set_use_tolls(float value);

  private:
  float _internal_use_tolls() const;
  void _internal_set_use_tolls(float value);

  public:
  // float use_roads = 15;
  bool has_use_roads() const;
  void clear_use_roads() ;
  float use_roads() const;
  void set_use_roads(float value);

  private:
  float _internal_use_roads() const;
  void _internal_set_use_roads(float value);

  public:
  // uint32 max_distance = 16;
  bool has_max_distance() const;
  void clear_max_distance() ;
  ::uint32_t max_distance() const;
  void set_max_distance(::uint32_t value);

  private:
  ::uint32_t _internal_max_distance() const;
  void _internal_set_max_distance(::uint32_t value);

  public:
  // float walking_speed = 17;
  bool has_walking_speed() const;
  void clear_walking_speed() ;
  float walking_speed() const;
  void set_walking_speed(float value);

  private:
  float _internal_walking_speed() const;
  void _internal_set_walking_speed(float value);

  public:
  // float step_penalty = 18;
  bool has_step_penalty() const;
  void clear_step_penalty() ;
  float step_penalty() const;
  void set_step_penalty(float value);

  private:
  float _internal_step_penalty() const;
  void _internal_set_step_penalty(float value);

  public:
  // uint32 max_grade = 19;
  bool has_max_grade() const;
  void clear_max_grade() ;
  ::uint32_t max_grade() const;
  void set_max_grade(::uint32_t value);

  private:
  ::uint32_t _internal_max_grade() const;
  void _internal_set_max_grade(::uint32_t value);

  public:
  // uint32 max_hiking_difficulty = 20;
  bool has_max_hiking_difficulty() const;
  void clear_max_hiking_difficulty() ;
  ::uint32_t max_hiking_difficulty() const;
  void set_max_hiking_difficulty(::uint32_t value);

  private:
  ::uint32_t _internal_max_hiking_difficulty() const;
  void _internal_set_max_hiking_difficulty(::uint32_t value);

  public:
  // float mode_factor = 21;
  bool has_mode_factor() const;
  void clear_mode_factor() ;
  float mode_factor() const;
  void set_mode_factor(float value);

  private:
  float _internal_mode_factor() const;
  void _internal_set_mode_factor(float value);

  public:
  // float walkway_factor = 22;
  bool has_walkway_factor() const;
  void clear_walkway_factor() ;
  float walkway_factor() const;
  void set_walkway_factor(float value);

  private:
  float _internal_walkway_factor() const;
  void _internal_set_walkway_factor(float value);

  public:
  // float sidewalk_factor = 23;
  bool has_sidewalk_factor() const;
  void clear_sidewalk_factor() ;
  float sidewalk_factor() const;
  void set_sidewalk_factor(float value);

  private:
  float _internal_sidewalk_factor() const;
  void _internal_set_sidewalk_factor(float value);

  public:
  // float alley_factor = 24;
  bool has_alley_factor() const;
  void clear_alley_factor() ;
  float alley_factor() const;
  void set_alley_factor(float value);

  private:
  float _internal_alley_factor() const;
  void _internal_set_alley_factor(float value);

  public:
  // float driveway_factor = 25;
  bool has_driveway_factor() const;
  void clear_driveway_factor() ;
  float driveway_factor() const;
  void set_driveway_factor(float value);

  private:
  float _internal_driveway_factor() const;
  void _internal_set_driveway_factor(float value);

  public:
  // float driveway_penalty = 26;
  bool has_driveway_penalty() const;
  void clear_driveway_penalty() ;
  float driveway_penalty() const;
  void set_driveway_penalty(float value);

  private:
  float _internal_driveway_penalty() const;
  void _internal_set_driveway_penalty(float value);

  public:
  // uint32 transit_start_end_max_distance = 27;
  bool has_transit_start_end_max_distance() const;
  void clear_transit_start_end_max_distance() ;
  ::uint32_t transit_start_end_max_distance() const;
  void set_transit_start_end_max_distance(::uint32_t value);

  private:
  ::uint32_t _internal_transit_start_end_max_distance() const;
  void _internal_set_transit_start_end_max_distance(::uint32_t value);

  public:
  // uint32 transit_transfer_max_distance = 28;
  bool has_transit_transfer_max_distance() const;
  void clear_transit_transfer_max_distance() ;
  ::uint32_t transit_transfer_max_distance() const;
  void set_transit_transfer_max_distance(::uint32_t value);

  private:
  ::uint32_t _internal_transit_transfer_max_distance() const;
  void _internal_set_transit_transfer_max_distance(::uint32_t value);

  public:
  // string transport_type = 29;
  bool has_transport_type() const;
  void clear_transport_type() ;
  const std::string& transport_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_transport_type(Arg_&& arg, Args_... args);
  std::string* mutable_transport_type();
  PROTOBUF_NODISCARD std::string* release_transport_type();
  void set_allocated_transport_type(std::string* value);

  private:
  const std::string& _internal_transport_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transport_type(
      const std::string& value);
  std::string* _internal_mutable_transport_type();

  public:
  // float top_speed = 30;
  bool has_top_speed() const;
  void clear_top_speed() ;
  float top_speed() const;
  void set_top_speed(float value);

  private:
  float _internal_top_speed() const;
  void _internal_set_top_speed(float value);

  public:
  // float use_hills = 31;
  bool has_use_hills() const;
  void clear_use_hills() ;
  float use_hills() const;
  void set_use_hills(float value);

  private:
  float _internal_use_hills() const;
  void _internal_set_use_hills(float value);

  public:
  // float use_primary = 32;
  bool has_use_primary() const;
  void clear_use_primary() ;
  float use_primary() const;
  void set_use_primary(float value);

  private:
  float _internal_use_primary() const;
  void _internal_set_use_primary(float value);

  public:
  // float use_trails = 33;
  bool has_use_trails() const;
  void clear_use_trails() ;
  float use_trails() const;
  void set_use_trails(float value);

  private:
  float _internal_use_trails() const;
  void _internal_set_use_trails(float value);

  public:
  // float low_class_penalty = 34;
  bool has_low_class_penalty() const;
  void clear_low_class_penalty() ;
  float low_class_penalty() const;
  void set_low_class_penalty(float value);

  private:
  float _internal_low_class_penalty() const;
  void _internal_set_low_class_penalty(float value);

  public:
  // bool hazmat = 35;
  bool has_hazmat() const;
  void clear_hazmat() ;
  bool hazmat() const;
  void set_hazmat(bool value);

  private:
  bool _internal_hazmat() const;
  void _internal_set_hazmat(bool value);

  public:
  // float weight = 36;
  bool has_weight() const;
  void clear_weight() ;
  float weight() const;
  void set_weight(float value);

  private:
  float _internal_weight() const;
  void _internal_set_weight(float value);

  public:
  // float axle_load = 37;
  bool has_axle_load() const;
  void clear_axle_load() ;
  float axle_load() const;
  void set_axle_load(float value);

  private:
  float _internal_axle_load() const;
  void _internal_set_axle_load(float value);

  public:
  // float height = 38;
  bool has_height() const;
  void clear_height() ;
  float height() const;
  void set_height(float value);

  private:
  float _internal_height() const;
  void _internal_set_height(float value);

  public:
  // float width = 39;
  bool has_width() const;
  void clear_width() ;
  float width() const;
  void set_width(float value);

  private:
  float _internal_width() const;
  void _internal_set_width(float value);

  public:
  // float length = 40;
  bool has_length() const;
  void clear_length() ;
  float length() const;
  void set_length(float value);

  private:
  float _internal_length() const;
  void _internal_set_length(float value);

  public:
  // float cycling_speed = 41;
  bool has_cycling_speed() const;
  void clear_cycling_speed() ;
  float cycling_speed() const;
  void set_cycling_speed(float value);

  private:
  float _internal_cycling_speed() const;
  void _internal_set_cycling_speed(float value);

  public:
  // bool wheelchair = 42;
  bool has_wheelchair() const;
  void clear_wheelchair() ;
  bool wheelchair() const;
  void set_wheelchair(bool value);

  private:
  bool _internal_wheelchair() const;
  void _internal_set_wheelchair(bool value);

  public:
  // bool bicycle = 43;
  bool has_bicycle() const;
  void clear_bicycle() ;
  bool bicycle() const;
  void set_bicycle(bool value);

  private:
  bool _internal_bicycle() const;
  void _internal_set_bicycle(bool value);

  public:
  // float use_bus = 44;
  bool has_use_bus() const;
  void clear_use_bus() ;
  float use_bus() const;
  void set_use_bus(float value);

  private:
  float _internal_use_bus() const;
  void _internal_set_use_bus(float value);

  public:
  // float use_rail = 45;
  bool has_use_rail() const;
  void clear_use_rail() ;
  float use_rail() const;
  void set_use_rail(float value);

  private:
  float _internal_use_rail() const;
  void _internal_set_use_rail(float value);

  public:
  // float use_transfers = 46;
  bool has_use_transfers() const;
  void clear_use_transfers() ;
  float use_transfers() const;
  void set_use_transfers(float value);

  private:
  float _internal_use_transfers() const;
  void _internal_set_use_transfers(float value);

  public:
  // float transfer_cost = 47;
  bool has_transfer_cost() const;
  void clear_transfer_cost() ;
  float transfer_cost() const;
  void set_transfer_cost(float value);

  private:
  float _internal_transfer_cost() const;
  void _internal_set_transfer_cost(float value);

  public:
  // float transfer_penalty = 48;
  bool has_transfer_penalty() const;
  void clear_transfer_penalty() ;
  float transfer_penalty() const;
  void set_transfer_penalty(float value);

  private:
  float _internal_transfer_penalty() const;
  void _internal_set_transfer_penalty(float value);

  public:
  // uint32 flow_mask = 55;
  bool has_flow_mask() const;
  void clear_flow_mask() ;
  ::uint32_t flow_mask() const;
  void set_flow_mask(::uint32_t value);

  private:
  ::uint32_t _internal_flow_mask() const;
  void _internal_set_flow_mask(::uint32_t value);

  public:
  // float bike_share_cost = 56;
  bool has_bike_share_cost() const;
  void clear_bike_share_cost() ;
  float bike_share_cost() const;
  void set_bike_share_cost(float value);

  private:
  float _internal_bike_share_cost() const;
  void _internal_set_bike_share_cost(float value);

  public:
  // float bike_share_penalty = 57;
  bool has_bike_share_penalty() const;
  void clear_bike_share_penalty() ;
  float bike_share_penalty() const;
  void set_bike_share_penalty(float value);

  private:
  float _internal_bike_share_penalty() const;
  void _internal_set_bike_share_penalty(float value);

  public:
  // float rail_ferry_cost = 58;
  bool has_rail_ferry_cost() const;
  void clear_rail_ferry_cost() ;
  float rail_ferry_cost() const;
  void set_rail_ferry_cost(float value);

  private:
  float _internal_rail_ferry_cost() const;
  void _internal_set_rail_ferry_cost(float value);

  public:
  // float use_rail_ferry = 59;
  bool has_use_rail_ferry() const;
  void clear_use_rail_ferry() ;
  float use_rail_ferry() const;
  void set_use_rail_ferry(float value);

  private:
  float _internal_use_rail_ferry() const;
  void _internal_set_use_rail_ferry(float value);

  public:
  // bool ignore_restrictions = 60;
  bool has_ignore_restrictions() const;
  void clear_ignore_restrictions() ;
  bool ignore_restrictions() const;
  void set_ignore_restrictions(bool value);

  private:
  bool _internal_ignore_restrictions() const;
  void _internal_set_ignore_restrictions(bool value);

  public:
  // bool ignore_oneways = 61;
  bool has_ignore_oneways() const;
  void clear_ignore_oneways() ;
  bool ignore_oneways() const;
  void set_ignore_oneways(bool value);

  private:
  bool _internal_ignore_oneways() const;
  void _internal_set_ignore_oneways(bool value);

  public:
  // bool ignore_access = 62;
  bool has_ignore_access() const;
  void clear_ignore_access() ;
  bool ignore_access() const;
  void set_ignore_access(bool value);

  private:
  bool _internal_ignore_access() const;
  void _internal_set_ignore_access(bool value);

  public:
  // bool ignore_closures = 63;
  bool has_ignore_closures() const;
  void clear_ignore_closures() ;
  bool ignore_closures() const;
  void set_ignore_closures(bool value);

  private:
  bool _internal_ignore_closures() const;
  void _internal_set_ignore_closures(bool value);

  public:
  // bool shortest = 64;
  bool has_shortest() const;
  void clear_shortest() ;
  bool shortest() const;
  void set_shortest(bool value);

  private:
  bool _internal_shortest() const;
  void _internal_set_shortest(bool value);

  public:
  // float service_penalty = 65;
  bool has_service_penalty() const;
  void clear_service_penalty() ;
  float service_penalty() const;
  void set_service_penalty(float value);

  private:
  float _internal_service_penalty() const;
  void _internal_set_service_penalty(float value);

  public:
  // float use_tracks = 66;
  bool has_use_tracks() const;
  void clear_use_tracks() ;
  float use_tracks() const;
  void set_use_tracks(float value);

  private:
  float _internal_use_tracks() const;
  void _internal_set_use_tracks(float value);

  public:
  // float use_distance = 67;
  bool has_use_distance() const;
  void clear_use_distance() ;
  float use_distance() const;
  void set_use_distance(float value);

  private:
  float _internal_use_distance() const;
  void _internal_set_use_distance(float value);

  public:
  // float use_living_streets = 68;
  bool has_use_living_streets() const;
  void clear_use_living_streets() ;
  float use_living_streets() const;
  void set_use_living_streets(float value);

  private:
  float _internal_use_living_streets() const;
  void _internal_set_use_living_streets(float value);

  public:
  // float service_factor = 69;
  bool has_service_factor() const;
  void clear_service_factor() ;
  float service_factor() const;
  void set_service_factor(float value);

  private:
  float _internal_service_factor() const;
  void _internal_set_service_factor(float value);

  public:
  // float closure_factor = 70;
  bool has_closure_factor() const;
  void clear_closure_factor() ;
  float closure_factor() const;
  void set_closure_factor(float value);

  private:
  float _internal_closure_factor() const;
  void _internal_set_closure_factor(float value);

  public:
  // float private_access_penalty = 71;
  bool has_private_access_penalty() const;
  void clear_private_access_penalty() ;
  float private_access_penalty() const;
  void set_private_access_penalty(float value);

  private:
  float _internal_private_access_penalty() const;
  void _internal_set_private_access_penalty(float value);

  public:
  // bool exclude_unpaved = 72;
  bool has_exclude_unpaved() const;
  void clear_exclude_unpaved() ;
  bool exclude_unpaved() const;
  void set_exclude_unpaved(bool value);

  private:
  bool _internal_exclude_unpaved() const;
  void _internal_set_exclude_unpaved(bool value);

  public:
  // bool include_hot = 73;
  bool has_include_hot() const;
  void clear_include_hot() ;
  bool include_hot() const;
  void set_include_hot(bool value);

  private:
  bool _internal_include_hot() const;
  void _internal_set_include_hot(bool value);

  public:
  // bool include_hov2 = 74;
  bool has_include_hov2() const;
  void clear_include_hov2() ;
  bool include_hov2() const;
  void set_include_hov2(bool value);

  private:
  bool _internal_include_hov2() const;
  void _internal_set_include_hov2(bool value);

  public:
  // bool include_hov3 = 75;
  bool has_include_hov3() const;
  void clear_include_hov3() ;
  bool include_hov3() const;
  void set_include_hov3(bool value);

  private:
  bool _internal_include_hov3() const;
  void _internal_set_include_hov3(bool value);

  public:
  // bool exclude_cash_only_tolls = 76;
  bool has_exclude_cash_only_tolls() const;
  void clear_exclude_cash_only_tolls() ;
  bool exclude_cash_only_tolls() const;
  void set_exclude_cash_only_tolls(bool value);

  private:
  bool _internal_exclude_cash_only_tolls() const;
  void _internal_set_exclude_cash_only_tolls(bool value);

  public:
  // uint32 restriction_probability = 77;
  bool has_restriction_probability() const;
  void clear_restriction_probability() ;
  ::uint32_t restriction_probability() const;
  void set_restriction_probability(::uint32_t value);

  private:
  ::uint32_t _internal_restriction_probability() const;
  void _internal_set_restriction_probability(::uint32_t value);

  public:
  // float elevator_penalty = 79;
  bool has_elevator_penalty() const;
  void clear_elevator_penalty() ;
  float elevator_penalty() const;
  void set_elevator_penalty(float value);

  private:
  float _internal_elevator_penalty() const;
  void _internal_set_elevator_penalty(float value);

  public:
  // float hgv_no_access_penalty = 85;
  bool has_hgv_no_access_penalty() const;
  void clear_hgv_no_access_penalty() ;
  float hgv_no_access_penalty() const;
  void set_hgv_no_access_penalty(float value);

  private:
  float _internal_hgv_no_access_penalty() const;
  void _internal_set_hgv_no_access_penalty(float value);

  public:
  void clear_has_maneuver_penalty();
  HasManeuverPenaltyCase has_maneuver_penalty_case() const;
  void clear_has_destination_only_penalty();
  HasDestinationOnlyPenaltyCase has_destination_only_penalty_case() const;
  void clear_has_gate_cost();
  HasGateCostCase has_gate_cost_case() const;
  void clear_has_gate_penalty();
  HasGatePenaltyCase has_gate_penalty_case() const;
  void clear_has_toll_booth_cost();
  HasTollBoothCostCase has_toll_booth_cost_case() const;
  void clear_has_toll_booth_penalty();
  HasTollBoothPenaltyCase has_toll_booth_penalty_case() const;
  void clear_has_alley_penalty();
  HasAlleyPenaltyCase has_alley_penalty_case() const;
  void clear_has_country_crossing_cost();
  HasCountryCrossingCostCase has_country_crossing_cost_case() const;
  void clear_has_country_crossing_penalty();
  HasCountryCrossingPenaltyCase has_country_crossing_penalty_case() const;
  void clear_has_ferry_cost();
  HasFerryCostCase has_ferry_cost_case() const;
  void clear_has_avoid_bad_surfaces();
  HasAvoidBadSurfacesCase has_avoid_bad_surfaces_case() const;
  void clear_has_use_ferry();
  HasUseFerryCase has_use_ferry_case() const;
  void clear_has_use_highways();
  HasUseHighwaysCase has_use_highways_case() const;
  void clear_has_use_tolls();
  HasUseTollsCase has_use_tolls_case() const;
  void clear_has_use_roads();
  HasUseRoadsCase has_use_roads_case() const;
  void clear_has_max_distance();
  HasMaxDistanceCase has_max_distance_case() const;
  void clear_has_walking_speed();
  HasWalkingSpeedCase has_walking_speed_case() const;
  void clear_has_step_penalty();
  HasStepPenaltyCase has_step_penalty_case() const;
  void clear_has_max_grade();
  HasMaxGradeCase has_max_grade_case() const;
  void clear_has_max_hiking_difficulty();
  HasMaxHikingDifficultyCase has_max_hiking_difficulty_case() const;
  void clear_has_mode_factor();
  HasModeFactorCase has_mode_factor_case() const;
  void clear_has_walkway_factor();
  HasWalkwayFactorCase has_walkway_factor_case() const;
  void clear_has_sidewalk_factor();
  HasSidewalkFactorCase has_sidewalk_factor_case() const;
  void clear_has_alley_factor();
  HasAlleyFactorCase has_alley_factor_case() const;
  void clear_has_driveway_factor();
  HasDrivewayFactorCase has_driveway_factor_case() const;
  void clear_has_driveway_penalty();
  HasDrivewayPenaltyCase has_driveway_penalty_case() const;
  void clear_has_transit_start_end_max_distance();
  HasTransitStartEndMaxDistanceCase has_transit_start_end_max_distance_case() const;
  void clear_has_transit_transfer_max_distance();
  HasTransitTransferMaxDistanceCase has_transit_transfer_max_distance_case() const;
  void clear_has_transport_type();
  HasTransportTypeCase has_transport_type_case() const;
  void clear_has_top_speed();
  HasTopSpeedCase has_top_speed_case() const;
  void clear_has_use_hills();
  HasUseHillsCase has_use_hills_case() const;
  void clear_has_use_primary();
  HasUsePrimaryCase has_use_primary_case() const;
  void clear_has_use_trails();
  HasUseTrailsCase has_use_trails_case() const;
  void clear_has_low_class_penalty();
  HasLowClassPenaltyCase has_low_class_penalty_case() const;
  void clear_has_hazmat();
  HasHazmatCase has_hazmat_case() const;
  void clear_has_weight();
  HasWeightCase has_weight_case() const;
  void clear_has_axle_load();
  HasAxleLoadCase has_axle_load_case() const;
  void clear_has_height();
  HasHeightCase has_height_case() const;
  void clear_has_width();
  HasWidthCase has_width_case() const;
  void clear_has_length();
  HasLengthCase has_length_case() const;
  void clear_has_cycling_speed();
  HasCyclingSpeedCase has_cycling_speed_case() const;
  void clear_has_wheelchair();
  HasWheelchairCase has_wheelchair_case() const;
  void clear_has_bicycle();
  HasBicycleCase has_bicycle_case() const;
  void clear_has_use_bus();
  HasUseBusCase has_use_bus_case() const;
  void clear_has_use_rail();
  HasUseRailCase has_use_rail_case() const;
  void clear_has_use_transfers();
  HasUseTransfersCase has_use_transfers_case() const;
  void clear_has_transfer_cost();
  HasTransferCostCase has_transfer_cost_case() const;
  void clear_has_transfer_penalty();
  HasTransferPenaltyCase has_transfer_penalty_case() const;
  void clear_has_flow_mask();
  HasFlowMaskCase has_flow_mask_case() const;
  void clear_has_bike_share_cost();
  HasBikeShareCostCase has_bike_share_cost_case() const;
  void clear_has_bike_share_penalty();
  HasBikeSharePenaltyCase has_bike_share_penalty_case() const;
  void clear_has_rail_ferry_cost();
  HasRailFerryCostCase has_rail_ferry_cost_case() const;
  void clear_has_use_rail_ferry();
  HasUseRailFerryCase has_use_rail_ferry_case() const;
  void clear_has_ignore_restrictions();
  HasIgnoreRestrictionsCase has_ignore_restrictions_case() const;
  void clear_has_ignore_oneways();
  HasIgnoreOnewaysCase has_ignore_oneways_case() const;
  void clear_has_ignore_access();
  HasIgnoreAccessCase has_ignore_access_case() const;
  void clear_has_ignore_closures();
  HasIgnoreClosuresCase has_ignore_closures_case() const;
  void clear_has_shortest();
  HasShortestCase has_shortest_case() const;
  void clear_has_service_penalty();
  HasServicePenaltyCase has_service_penalty_case() const;
  void clear_has_use_tracks();
  HasUseTracksCase has_use_tracks_case() const;
  void clear_has_use_distance();
  HasUseDistanceCase has_use_distance_case() const;
  void clear_has_use_living_streets();
  HasUseLivingStreetsCase has_use_living_streets_case() const;
  void clear_has_service_factor();
  HasServiceFactorCase has_service_factor_case() const;
  void clear_has_closure_factor();
  HasClosureFactorCase has_closure_factor_case() const;
  void clear_has_private_access_penalty();
  HasPrivateAccessPenaltyCase has_private_access_penalty_case() const;
  void clear_has_exclude_unpaved();
  HasExcludeUnpavedCase has_exclude_unpaved_case() const;
  void clear_has_include_hot();
  HasIncludeHotCase has_include_hot_case() const;
  void clear_has_include_hov2();
  HasIncludeHov2Case has_include_hov2_case() const;
  void clear_has_include_hov3();
  HasIncludeHov3Case has_include_hov3_case() const;
  void clear_has_exclude_cash_only_tolls();
  HasExcludeCashOnlyTollsCase has_exclude_cash_only_tolls_case() const;
  void clear_has_restriction_probability();
  HasRestrictionProbabilityCase has_restriction_probability_case() const;
  void clear_has_elevator_penalty();
  HasElevatorPenaltyCase has_elevator_penalty_case() const;
  void clear_has_hgv_no_access_penalty();
  HasHgvNoAccessPenaltyCase has_hgv_no_access_penalty_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.Costing.Options)
 private:
  class _Internal;
  void set_has_maneuver_penalty();
  void set_has_destination_only_penalty();
  void set_has_gate_cost();
  void set_has_gate_penalty();
  void set_has_toll_booth_cost();
  void set_has_toll_booth_penalty();
  void set_has_alley_penalty();
  void set_has_country_crossing_cost();
  void set_has_country_crossing_penalty();
  void set_has_ferry_cost();
  void set_has_avoid_bad_surfaces();
  void set_has_use_ferry();
  void set_has_use_highways();
  void set_has_use_tolls();
  void set_has_use_roads();
  void set_has_max_distance();
  void set_has_walking_speed();
  void set_has_step_penalty();
  void set_has_max_grade();
  void set_has_max_hiking_difficulty();
  void set_has_mode_factor();
  void set_has_walkway_factor();
  void set_has_sidewalk_factor();
  void set_has_alley_factor();
  void set_has_driveway_factor();
  void set_has_driveway_penalty();
  void set_has_transit_start_end_max_distance();
  void set_has_transit_transfer_max_distance();
  void set_has_transport_type();
  void set_has_top_speed();
  void set_has_use_hills();
  void set_has_use_primary();
  void set_has_use_trails();
  void set_has_low_class_penalty();
  void set_has_hazmat();
  void set_has_weight();
  void set_has_axle_load();
  void set_has_height();
  void set_has_width();
  void set_has_length();
  void set_has_cycling_speed();
  void set_has_wheelchair();
  void set_has_bicycle();
  void set_has_use_bus();
  void set_has_use_rail();
  void set_has_use_transfers();
  void set_has_transfer_cost();
  void set_has_transfer_penalty();
  void set_has_flow_mask();
  void set_has_bike_share_cost();
  void set_has_bike_share_penalty();
  void set_has_rail_ferry_cost();
  void set_has_use_rail_ferry();
  void set_has_ignore_restrictions();
  void set_has_ignore_oneways();
  void set_has_ignore_access();
  void set_has_ignore_closures();
  void set_has_shortest();
  void set_has_service_penalty();
  void set_has_use_tracks();
  void set_has_use_distance();
  void set_has_use_living_streets();
  void set_has_service_factor();
  void set_has_closure_factor();
  void set_has_private_access_penalty();
  void set_has_exclude_unpaved();
  void set_has_include_hot();
  void set_has_include_hov2();
  void set_has_include_hov3();
  void set_has_exclude_cash_only_tolls();
  void set_has_restriction_probability();
  void set_has_elevator_penalty();
  void set_has_hgv_no_access_penalty();

  inline bool has_has_maneuver_penalty() const;
  inline void clear_has_has_maneuver_penalty();

  inline bool has_has_destination_only_penalty() const;
  inline void clear_has_has_destination_only_penalty();

  inline bool has_has_gate_cost() const;
  inline void clear_has_has_gate_cost();

  inline bool has_has_gate_penalty() const;
  inline void clear_has_has_gate_penalty();

  inline bool has_has_toll_booth_cost() const;
  inline void clear_has_has_toll_booth_cost();

  inline bool has_has_toll_booth_penalty() const;
  inline void clear_has_has_toll_booth_penalty();

  inline bool has_has_alley_penalty() const;
  inline void clear_has_has_alley_penalty();

  inline bool has_has_country_crossing_cost() const;
  inline void clear_has_has_country_crossing_cost();

  inline bool has_has_country_crossing_penalty() const;
  inline void clear_has_has_country_crossing_penalty();

  inline bool has_has_ferry_cost() const;
  inline void clear_has_has_ferry_cost();

  inline bool has_has_avoid_bad_surfaces() const;
  inline void clear_has_has_avoid_bad_surfaces();

  inline bool has_has_use_ferry() const;
  inline void clear_has_has_use_ferry();

  inline bool has_has_use_highways() const;
  inline void clear_has_has_use_highways();

  inline bool has_has_use_tolls() const;
  inline void clear_has_has_use_tolls();

  inline bool has_has_use_roads() const;
  inline void clear_has_has_use_roads();

  inline bool has_has_max_distance() const;
  inline void clear_has_has_max_distance();

  inline bool has_has_walking_speed() const;
  inline void clear_has_has_walking_speed();

  inline bool has_has_step_penalty() const;
  inline void clear_has_has_step_penalty();

  inline bool has_has_max_grade() const;
  inline void clear_has_has_max_grade();

  inline bool has_has_max_hiking_difficulty() const;
  inline void clear_has_has_max_hiking_difficulty();

  inline bool has_has_mode_factor() const;
  inline void clear_has_has_mode_factor();

  inline bool has_has_walkway_factor() const;
  inline void clear_has_has_walkway_factor();

  inline bool has_has_sidewalk_factor() const;
  inline void clear_has_has_sidewalk_factor();

  inline bool has_has_alley_factor() const;
  inline void clear_has_has_alley_factor();

  inline bool has_has_driveway_factor() const;
  inline void clear_has_has_driveway_factor();

  inline bool has_has_driveway_penalty() const;
  inline void clear_has_has_driveway_penalty();

  inline bool has_has_transit_start_end_max_distance() const;
  inline void clear_has_has_transit_start_end_max_distance();

  inline bool has_has_transit_transfer_max_distance() const;
  inline void clear_has_has_transit_transfer_max_distance();

  inline bool has_has_transport_type() const;
  inline void clear_has_has_transport_type();

  inline bool has_has_top_speed() const;
  inline void clear_has_has_top_speed();

  inline bool has_has_use_hills() const;
  inline void clear_has_has_use_hills();

  inline bool has_has_use_primary() const;
  inline void clear_has_has_use_primary();

  inline bool has_has_use_trails() const;
  inline void clear_has_has_use_trails();

  inline bool has_has_low_class_penalty() const;
  inline void clear_has_has_low_class_penalty();

  inline bool has_has_hazmat() const;
  inline void clear_has_has_hazmat();

  inline bool has_has_weight() const;
  inline void clear_has_has_weight();

  inline bool has_has_axle_load() const;
  inline void clear_has_has_axle_load();

  inline bool has_has_height() const;
  inline void clear_has_has_height();

  inline bool has_has_width() const;
  inline void clear_has_has_width();

  inline bool has_has_length() const;
  inline void clear_has_has_length();

  inline bool has_has_cycling_speed() const;
  inline void clear_has_has_cycling_speed();

  inline bool has_has_wheelchair() const;
  inline void clear_has_has_wheelchair();

  inline bool has_has_bicycle() const;
  inline void clear_has_has_bicycle();

  inline bool has_has_use_bus() const;
  inline void clear_has_has_use_bus();

  inline bool has_has_use_rail() const;
  inline void clear_has_has_use_rail();

  inline bool has_has_use_transfers() const;
  inline void clear_has_has_use_transfers();

  inline bool has_has_transfer_cost() const;
  inline void clear_has_has_transfer_cost();

  inline bool has_has_transfer_penalty() const;
  inline void clear_has_has_transfer_penalty();

  inline bool has_has_flow_mask() const;
  inline void clear_has_has_flow_mask();

  inline bool has_has_bike_share_cost() const;
  inline void clear_has_has_bike_share_cost();

  inline bool has_has_bike_share_penalty() const;
  inline void clear_has_has_bike_share_penalty();

  inline bool has_has_rail_ferry_cost() const;
  inline void clear_has_has_rail_ferry_cost();

  inline bool has_has_use_rail_ferry() const;
  inline void clear_has_has_use_rail_ferry();

  inline bool has_has_ignore_restrictions() const;
  inline void clear_has_has_ignore_restrictions();

  inline bool has_has_ignore_oneways() const;
  inline void clear_has_has_ignore_oneways();

  inline bool has_has_ignore_access() const;
  inline void clear_has_has_ignore_access();

  inline bool has_has_ignore_closures() const;
  inline void clear_has_has_ignore_closures();

  inline bool has_has_shortest() const;
  inline void clear_has_has_shortest();

  inline bool has_has_service_penalty() const;
  inline void clear_has_has_service_penalty();

  inline bool has_has_use_tracks() const;
  inline void clear_has_has_use_tracks();

  inline bool has_has_use_distance() const;
  inline void clear_has_has_use_distance();

  inline bool has_has_use_living_streets() const;
  inline void clear_has_has_use_living_streets();

  inline bool has_has_service_factor() const;
  inline void clear_has_has_service_factor();

  inline bool has_has_closure_factor() const;
  inline void clear_has_has_closure_factor();

  inline bool has_has_private_access_penalty() const;
  inline void clear_has_has_private_access_penalty();

  inline bool has_has_exclude_unpaved() const;
  inline void clear_has_has_exclude_unpaved();

  inline bool has_has_include_hot() const;
  inline void clear_has_has_include_hot();

  inline bool has_has_include_hov2() const;
  inline void clear_has_has_include_hov2();

  inline bool has_has_include_hov3() const;
  inline void clear_has_has_include_hov3();

  inline bool has_has_exclude_cash_only_tolls() const;
  inline void clear_has_has_exclude_cash_only_tolls();

  inline bool has_has_restriction_probability() const;
  inline void clear_has_has_restriction_probability();

  inline bool has_has_elevator_penalty() const;
  inline void clear_has_has_elevator_penalty();

  inline bool has_has_hgv_no_access_penalty() const;
  inline void clear_has_has_hgv_no_access_penalty();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 86, 1,
      177, 13>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> filter_stop_ids_;
    ::google::protobuf::RepeatedPtrField<std::string> filter_operator_ids_;
    ::google::protobuf::RepeatedPtrField<std::string> filter_route_ids_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::AvoidEdge > exclude_edges_;
    int filter_stop_action_;
    int filter_operator_action_;
    int filter_route_action_;
    ::uint32_t fixed_speed_;
    ::uint32_t axle_count_;
    float use_lit_;
    bool disable_hierarchy_pruning_;
    bool ignore_non_vehicular_restrictions_;
    float use_truck_route_;
    union HasManeuverPenaltyUnion {
      constexpr HasManeuverPenaltyUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float maneuver_penalty_;
    } has_maneuver_penalty_;
    union HasDestinationOnlyPenaltyUnion {
      constexpr HasDestinationOnlyPenaltyUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float destination_only_penalty_;
    } has_destination_only_penalty_;
    union HasGateCostUnion {
      constexpr HasGateCostUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float gate_cost_;
    } has_gate_cost_;
    union HasGatePenaltyUnion {
      constexpr HasGatePenaltyUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float gate_penalty_;
    } has_gate_penalty_;
    union HasTollBoothCostUnion {
      constexpr HasTollBoothCostUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float toll_booth_cost_;
    } has_toll_booth_cost_;
    union HasTollBoothPenaltyUnion {
      constexpr HasTollBoothPenaltyUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float toll_booth_penalty_;
    } has_toll_booth_penalty_;
    union HasAlleyPenaltyUnion {
      constexpr HasAlleyPenaltyUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float alley_penalty_;
    } has_alley_penalty_;
    union HasCountryCrossingCostUnion {
      constexpr HasCountryCrossingCostUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float country_crossing_cost_;
    } has_country_crossing_cost_;
    union HasCountryCrossingPenaltyUnion {
      constexpr HasCountryCrossingPenaltyUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float country_crossing_penalty_;
    } has_country_crossing_penalty_;
    union HasFerryCostUnion {
      constexpr HasFerryCostUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float ferry_cost_;
    } has_ferry_cost_;
    union HasAvoidBadSurfacesUnion {
      constexpr HasAvoidBadSurfacesUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float avoid_bad_surfaces_;
    } has_avoid_bad_surfaces_;
    union HasUseFerryUnion {
      constexpr HasUseFerryUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float use_ferry_;
    } has_use_ferry_;
    union HasUseHighwaysUnion {
      constexpr HasUseHighwaysUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float use_highways_;
    } has_use_highways_;
    union HasUseTollsUnion {
      constexpr HasUseTollsUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float use_tolls_;
    } has_use_tolls_;
    union HasUseRoadsUnion {
      constexpr HasUseRoadsUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float use_roads_;
    } has_use_roads_;
    union HasMaxDistanceUnion {
      constexpr HasMaxDistanceUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint32_t max_distance_;
    } has_max_distance_;
    union HasWalkingSpeedUnion {
      constexpr HasWalkingSpeedUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float walking_speed_;
    } has_walking_speed_;
    union HasStepPenaltyUnion {
      constexpr HasStepPenaltyUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float step_penalty_;
    } has_step_penalty_;
    union HasMaxGradeUnion {
      constexpr HasMaxGradeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint32_t max_grade_;
    } has_max_grade_;
    union HasMaxHikingDifficultyUnion {
      constexpr HasMaxHikingDifficultyUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint32_t max_hiking_difficulty_;
    } has_max_hiking_difficulty_;
    union HasModeFactorUnion {
      constexpr HasModeFactorUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float mode_factor_;
    } has_mode_factor_;
    union HasWalkwayFactorUnion {
      constexpr HasWalkwayFactorUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float walkway_factor_;
    } has_walkway_factor_;
    union HasSidewalkFactorUnion {
      constexpr HasSidewalkFactorUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float sidewalk_factor_;
    } has_sidewalk_factor_;
    union HasAlleyFactorUnion {
      constexpr HasAlleyFactorUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float alley_factor_;
    } has_alley_factor_;
    union HasDrivewayFactorUnion {
      constexpr HasDrivewayFactorUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float driveway_factor_;
    } has_driveway_factor_;
    union HasDrivewayPenaltyUnion {
      constexpr HasDrivewayPenaltyUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float driveway_penalty_;
    } has_driveway_penalty_;
    union HasTransitStartEndMaxDistanceUnion {
      constexpr HasTransitStartEndMaxDistanceUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint32_t transit_start_end_max_distance_;
    } has_transit_start_end_max_distance_;
    union HasTransitTransferMaxDistanceUnion {
      constexpr HasTransitTransferMaxDistanceUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint32_t transit_transfer_max_distance_;
    } has_transit_transfer_max_distance_;
    union HasTransportTypeUnion {
      constexpr HasTransportTypeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr transport_type_;
    } has_transport_type_;
    union HasTopSpeedUnion {
      constexpr HasTopSpeedUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float top_speed_;
    } has_top_speed_;
    union HasUseHillsUnion {
      constexpr HasUseHillsUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float use_hills_;
    } has_use_hills_;
    union HasUsePrimaryUnion {
      constexpr HasUsePrimaryUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float use_primary_;
    } has_use_primary_;
    union HasUseTrailsUnion {
      constexpr HasUseTrailsUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float use_trails_;
    } has_use_trails_;
    union HasLowClassPenaltyUnion {
      constexpr HasLowClassPenaltyUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float low_class_penalty_;
    } has_low_class_penalty_;
    union HasHazmatUnion {
      constexpr HasHazmatUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool hazmat_;
    } has_hazmat_;
    union HasWeightUnion {
      constexpr HasWeightUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float weight_;
    } has_weight_;
    union HasAxleLoadUnion {
      constexpr HasAxleLoadUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float axle_load_;
    } has_axle_load_;
    union HasHeightUnion {
      constexpr HasHeightUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float height_;
    } has_height_;
    union HasWidthUnion {
      constexpr HasWidthUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float width_;
    } has_width_;
    union HasLengthUnion {
      constexpr HasLengthUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float length_;
    } has_length_;
    union HasCyclingSpeedUnion {
      constexpr HasCyclingSpeedUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float cycling_speed_;
    } has_cycling_speed_;
    union HasWheelchairUnion {
      constexpr HasWheelchairUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool wheelchair_;
    } has_wheelchair_;
    union HasBicycleUnion {
      constexpr HasBicycleUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool bicycle_;
    } has_bicycle_;
    union HasUseBusUnion {
      constexpr HasUseBusUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float use_bus_;
    } has_use_bus_;
    union HasUseRailUnion {
      constexpr HasUseRailUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float use_rail_;
    } has_use_rail_;
    union HasUseTransfersUnion {
      constexpr HasUseTransfersUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float use_transfers_;
    } has_use_transfers_;
    union HasTransferCostUnion {
      constexpr HasTransferCostUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float transfer_cost_;
    } has_transfer_cost_;
    union HasTransferPenaltyUnion {
      constexpr HasTransferPenaltyUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float transfer_penalty_;
    } has_transfer_penalty_;
    union HasFlowMaskUnion {
      constexpr HasFlowMaskUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint32_t flow_mask_;
    } has_flow_mask_;
    union HasBikeShareCostUnion {
      constexpr HasBikeShareCostUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float bike_share_cost_;
    } has_bike_share_cost_;
    union HasBikeSharePenaltyUnion {
      constexpr HasBikeSharePenaltyUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float bike_share_penalty_;
    } has_bike_share_penalty_;
    union HasRailFerryCostUnion {
      constexpr HasRailFerryCostUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float rail_ferry_cost_;
    } has_rail_ferry_cost_;
    union HasUseRailFerryUnion {
      constexpr HasUseRailFerryUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float use_rail_ferry_;
    } has_use_rail_ferry_;
    union HasIgnoreRestrictionsUnion {
      constexpr HasIgnoreRestrictionsUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool ignore_restrictions_;
    } has_ignore_restrictions_;
    union HasIgnoreOnewaysUnion {
      constexpr HasIgnoreOnewaysUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool ignore_oneways_;
    } has_ignore_oneways_;
    union HasIgnoreAccessUnion {
      constexpr HasIgnoreAccessUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool ignore_access_;
    } has_ignore_access_;
    union HasIgnoreClosuresUnion {
      constexpr HasIgnoreClosuresUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool ignore_closures_;
    } has_ignore_closures_;
    union HasShortestUnion {
      constexpr HasShortestUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool shortest_;
    } has_shortest_;
    union HasServicePenaltyUnion {
      constexpr HasServicePenaltyUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float service_penalty_;
    } has_service_penalty_;
    union HasUseTracksUnion {
      constexpr HasUseTracksUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float use_tracks_;
    } has_use_tracks_;
    union HasUseDistanceUnion {
      constexpr HasUseDistanceUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float use_distance_;
    } has_use_distance_;
    union HasUseLivingStreetsUnion {
      constexpr HasUseLivingStreetsUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float use_living_streets_;
    } has_use_living_streets_;
    union HasServiceFactorUnion {
      constexpr HasServiceFactorUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float service_factor_;
    } has_service_factor_;
    union HasClosureFactorUnion {
      constexpr HasClosureFactorUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float closure_factor_;
    } has_closure_factor_;
    union HasPrivateAccessPenaltyUnion {
      constexpr HasPrivateAccessPenaltyUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float private_access_penalty_;
    } has_private_access_penalty_;
    union HasExcludeUnpavedUnion {
      constexpr HasExcludeUnpavedUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool exclude_unpaved_;
    } has_exclude_unpaved_;
    union HasIncludeHotUnion {
      constexpr HasIncludeHotUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool include_hot_;
    } has_include_hot_;
    union HasIncludeHov2Union {
      constexpr HasIncludeHov2Union() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool include_hov2_;
    } has_include_hov2_;
    union HasIncludeHov3Union {
      constexpr HasIncludeHov3Union() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool include_hov3_;
    } has_include_hov3_;
    union HasExcludeCashOnlyTollsUnion {
      constexpr HasExcludeCashOnlyTollsUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool exclude_cash_only_tolls_;
    } has_exclude_cash_only_tolls_;
    union HasRestrictionProbabilityUnion {
      constexpr HasRestrictionProbabilityUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint32_t restriction_probability_;
    } has_restriction_probability_;
    union HasElevatorPenaltyUnion {
      constexpr HasElevatorPenaltyUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float elevator_penalty_;
    } has_elevator_penalty_;
    union HasHgvNoAccessPenaltyUnion {
      constexpr HasHgvNoAccessPenaltyUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float hgv_no_access_penalty_;
    } has_hgv_no_access_penalty_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[73];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_options_2eproto;
};// -------------------------------------------------------------------

class Costing final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.Costing) */ {
 public:
  inline Costing() : Costing(nullptr) {}
  ~Costing() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Costing(::google::protobuf::internal::ConstantInitialized);

  inline Costing(const Costing& from)
      : Costing(nullptr, from) {}
  Costing(Costing&& from) noexcept
    : Costing() {
    *this = ::std::move(from);
  }

  inline Costing& operator=(const Costing& from) {
    CopyFrom(from);
    return *this;
  }
  inline Costing& operator=(Costing&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Costing& default_instance() {
    return *internal_default_instance();
  }
  enum HasOptionsCase {
    kOptions = 1,
    HAS_OPTIONS_NOT_SET = 0,
  };

  enum HasNameCase {
    kName = 3,
    HAS_NAME_NOT_SET = 0,
  };

  enum HasFilterClosuresCase {
    kFilterClosures = 4,
    HAS_FILTER_CLOSURES_NOT_SET = 0,
  };

  static inline const Costing* internal_default_instance() {
    return reinterpret_cast<const Costing*>(
               &_Costing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Costing& a, Costing& b) {
    a.Swap(&b);
  }
  inline void Swap(Costing* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Costing* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Costing* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Costing>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Costing& from);
  void MergeFrom(const Costing& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Costing* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.Costing";
  }
  protected:
  explicit Costing(::google::protobuf::Arena* arena);
  Costing(::google::protobuf::Arena* arena, const Costing& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using Options = Costing_Options;

  using Type = Costing_Type;
  static constexpr Type none_ = Costing_Type_none_;
  static constexpr Type bicycle = Costing_Type_bicycle;
  static constexpr Type bus = Costing_Type_bus;
  static constexpr Type motor_scooter = Costing_Type_motor_scooter;
  static constexpr Type multimodal = Costing_Type_multimodal;
  static constexpr Type pedestrian = Costing_Type_pedestrian;
  static constexpr Type transit = Costing_Type_transit;
  static constexpr Type truck = Costing_Type_truck;
  static constexpr Type motorcycle = Costing_Type_motorcycle;
  static constexpr Type taxi = Costing_Type_taxi;
  static constexpr Type auto_ = Costing_Type_auto_;
  static constexpr Type bikeshare = Costing_Type_bikeshare;
  static inline bool Type_IsValid(int value) {
    return Costing_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = Costing_Type_Type_MIN;
  static constexpr Type Type_MAX = Costing_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = Costing_Type_Type_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return Costing_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return Costing_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 2,
    kOptionsFieldNumber = 1,
    kNameFieldNumber = 3,
    kFilterClosuresFieldNumber = 4,
  };
  // .valhalla.Costing.Type type = 2;
  void clear_type() ;
  ::valhalla::Costing_Type type() const;
  void set_type(::valhalla::Costing_Type value);

  private:
  ::valhalla::Costing_Type _internal_type() const;
  void _internal_set_type(::valhalla::Costing_Type value);

  public:
  // .valhalla.Costing.Options options = 1;
  bool has_options() const;
  private:
  bool _internal_has_options() const;

  public:
  void clear_options() ;
  const ::valhalla::Costing_Options& options() const;
  PROTOBUF_NODISCARD ::valhalla::Costing_Options* release_options();
  ::valhalla::Costing_Options* mutable_options();
  void set_allocated_options(::valhalla::Costing_Options* value);
  void unsafe_arena_set_allocated_options(::valhalla::Costing_Options* value);
  ::valhalla::Costing_Options* unsafe_arena_release_options();

  private:
  const ::valhalla::Costing_Options& _internal_options() const;
  ::valhalla::Costing_Options* _internal_mutable_options();

  public:
  // string name = 3;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // bool filter_closures = 4;
  bool has_filter_closures() const;
  void clear_filter_closures() ;
  bool filter_closures() const;
  void set_filter_closures(bool value);

  private:
  bool _internal_filter_closures() const;
  void _internal_set_filter_closures(bool value);

  public:
  void clear_has_options();
  HasOptionsCase has_options_case() const;
  void clear_has_name();
  HasNameCase has_name_case() const;
  void clear_has_filter_closures();
  HasFilterClosuresCase has_filter_closures_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.Costing)
 private:
  class _Internal;
  void set_has_options();
  void set_has_name();
  void set_has_filter_closures();

  inline bool has_has_options() const;
  inline void clear_has_has_options();

  inline bool has_has_name() const;
  inline void clear_has_has_name();

  inline bool has_has_filter_closures() const;
  inline void clear_has_has_filter_closures();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 4, 1,
      29, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    int type_;
    union HasOptionsUnion {
      constexpr HasOptionsUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::valhalla::Costing_Options* options_;
    } has_options_;
    union HasNameUnion {
      constexpr HasNameUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr name_;
    } has_name_;
    union HasFilterClosuresUnion {
      constexpr HasFilterClosuresUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool filter_closures_;
    } has_filter_closures_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[3];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_options_2eproto;
};// -------------------------------------------------------------------

// -------------------------------------------------------------------

class Options final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.Options) */ {
 public:
  inline Options() : Options(nullptr) {}
  ~Options() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Options(::google::protobuf::internal::ConstantInitialized);

  inline Options(const Options& from)
      : Options(nullptr, from) {}
  Options(Options&& from) noexcept
    : Options() {
    *this = ::std::move(from);
  }

  inline Options& operator=(const Options& from) {
    CopyFrom(from);
    return *this;
  }
  inline Options& operator=(Options&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Options& default_instance() {
    return *internal_default_instance();
  }
  enum HasLanguageCase {
    kLanguage = 2,
    HAS_LANGUAGE_NOT_SET = 0,
  };

  enum HasIdCase {
    kId = 5,
    HAS_ID_NOT_SET = 0,
  };

  enum HasJsonpCase {
    kJsonp = 6,
    HAS_JSONP_NOT_SET = 0,
  };

  enum HasEncodedPolylineCase {
    kEncodedPolyline = 7,
    HAS_ENCODED_POLYLINE_NOT_SET = 0,
  };

  enum HasRangeCase {
    kRange = 10,
    HAS_RANGE_NOT_SET = 0,
  };

  enum HasVerboseCase {
    kVerbose = 11,
    HAS_VERBOSE_NOT_SET = 0,
  };

  enum HasDateTimeCase {
    kDateTime = 19,
    HAS_DATE_TIME_NOT_SET = 0,
  };

  enum HasResampleDistanceCase {
    kResampleDistance = 21,
    HAS_RESAMPLE_DISTANCE_NOT_SET = 0,
  };

  enum HasPolygonsCase {
    kPolygons = 23,
    HAS_POLYGONS_NOT_SET = 0,
  };

  enum HasDenoiseCase {
    kDenoise = 24,
    HAS_DENOISE_NOT_SET = 0,
  };

  enum HasGeneralizeCase {
    kGeneralize = 25,
    HAS_GENERALIZE_NOT_SET = 0,
  };

  enum HasShowLocationsCase {
    kShowLocations = 26,
    HAS_SHOW_LOCATIONS_NOT_SET = 0,
  };

  enum HasGpsAccuracyCase {
    kGpsAccuracy = 30,
    HAS_GPS_ACCURACY_NOT_SET = 0,
  };

  enum HasSearchRadiusCase {
    kSearchRadius = 31,
    HAS_SEARCH_RADIUS_NOT_SET = 0,
  };

  enum HasTurnPenaltyFactorCase {
    kTurnPenaltyFactor = 32,
    HAS_TURN_PENALTY_FACTOR_NOT_SET = 0,
  };

  enum HasBreakageDistanceCase {
    kBreakageDistance = 36,
    HAS_BREAKAGE_DISTANCE_NOT_SET = 0,
  };

  enum HasUseTimestampsCase {
    kUseTimestamps = 37,
    HAS_USE_TIMESTAMPS_NOT_SET = 0,
  };

  enum HasShapeFormatCase {
    kShapeFormat = 38,
    HAS_SHAPE_FORMAT_NOT_SET = 0,
  };

  enum HasAlternatesCase {
    kAlternates = 39,
    HAS_ALTERNATES_NOT_SET = 0,
  };

  enum HasInterpolationDistanceCase {
    kInterpolationDistance = 40,
    HAS_INTERPOLATION_DISTANCE_NOT_SET = 0,
  };

  enum HasGuidanceViewsCase {
    kGuidanceViews = 41,
    HAS_GUIDANCE_VIEWS_NOT_SET = 0,
  };

  enum HasHeightPrecisionCase {
    kHeightPrecision = 43,
    HAS_HEIGHT_PRECISION_NOT_SET = 0,
  };

  enum HasRoundaboutExitsCase {
    kRoundaboutExits = 44,
    HAS_ROUNDABOUT_EXITS_NOT_SET = 0,
  };

  enum HasLinearReferencesCase {
    kLinearReferences = 45,
    HAS_LINEAR_REFERENCES_NOT_SET = 0,
  };

  enum HasPrioritizeBidirectionalCase {
    kPrioritizeBidirectional = 48,
    HAS_PRIORITIZE_BIDIRECTIONAL_NOT_SET = 0,
  };

  enum HasExpansionActionCase {
    kExpansionAction = 49,
    HAS_EXPANSION_ACTION_NOT_SET = 0,
  };

  enum HasSkipOppositesCase {
    kSkipOpposites = 50,
    HAS_SKIP_OPPOSITES_NOT_SET = 0,
  };

  enum HasMatrixLocationsCase {
    kMatrixLocations = 54,
    HAS_MATRIX_LOCATIONS_NOT_SET = 0,
  };

  static inline const Options* internal_default_instance() {
    return reinterpret_cast<const Options*>(
               &_Options_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Options& a, Options& b) {
    a.Swap(&b);
  }
  inline void Swap(Options* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Options* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Options* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Options>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Options& from);
  void MergeFrom(const Options& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Options* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.Options";
  }
  protected:
  explicit Options(::google::protobuf::Arena* arena);
  Options(::google::protobuf::Arena* arena, const Options& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  using Units = Options_Units;
  static constexpr Units kilometers = Options_Units_kilometers;
  static constexpr Units miles = Options_Units_miles;
  static inline bool Units_IsValid(int value) {
    return Options_Units_IsValid(value);
  }
  static constexpr Units Units_MIN = Options_Units_Units_MIN;
  static constexpr Units Units_MAX = Options_Units_Units_MAX;
  static constexpr int Units_ARRAYSIZE = Options_Units_Units_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Units_Name(T value) {
    return Options_Units_Name(value);
  }
  static inline bool Units_Parse(absl::string_view name, Units* value) {
    return Options_Units_Parse(name, value);
  }

  using Format = Options_Format;
  static constexpr Format json = Options_Format_json;
  static constexpr Format gpx = Options_Format_gpx;
  static constexpr Format osrm = Options_Format_osrm;
  static constexpr Format pbf = Options_Format_pbf;
  static constexpr Format geotiff = Options_Format_geotiff;
  static inline bool Format_IsValid(int value) {
    return Options_Format_IsValid(value);
  }
  static constexpr Format Format_MIN = Options_Format_Format_MIN;
  static constexpr Format Format_MAX = Options_Format_Format_MAX;
  static constexpr int Format_ARRAYSIZE = Options_Format_Format_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Format_Name(T value) {
    return Options_Format_Name(value);
  }
  static inline bool Format_Parse(absl::string_view name, Format* value) {
    return Options_Format_Parse(name, value);
  }

  using Action = Options_Action;
  static constexpr Action no_action = Options_Action_no_action;
  static constexpr Action route = Options_Action_route;
  static constexpr Action locate = Options_Action_locate;
  static constexpr Action sources_to_targets = Options_Action_sources_to_targets;
  static constexpr Action optimized_route = Options_Action_optimized_route;
  static constexpr Action isochrone = Options_Action_isochrone;
  static constexpr Action trace_route = Options_Action_trace_route;
  static constexpr Action trace_attributes = Options_Action_trace_attributes;
  static constexpr Action height = Options_Action_height;
  static constexpr Action transit_available = Options_Action_transit_available;
  static constexpr Action expansion = Options_Action_expansion;
  static constexpr Action centroid = Options_Action_centroid;
  static constexpr Action status = Options_Action_status;
  static inline bool Action_IsValid(int value) {
    return Options_Action_IsValid(value);
  }
  static constexpr Action Action_MIN = Options_Action_Action_MIN;
  static constexpr Action Action_MAX = Options_Action_Action_MAX;
  static constexpr int Action_ARRAYSIZE = Options_Action_Action_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Action_Name(T value) {
    return Options_Action_Name(value);
  }
  static inline bool Action_Parse(absl::string_view name, Action* value) {
    return Options_Action_Parse(name, value);
  }

  using DateTimeType = Options_DateTimeType;
  static constexpr DateTimeType no_time = Options_DateTimeType_no_time;
  static constexpr DateTimeType current = Options_DateTimeType_current;
  static constexpr DateTimeType depart_at = Options_DateTimeType_depart_at;
  static constexpr DateTimeType arrive_by = Options_DateTimeType_arrive_by;
  static constexpr DateTimeType invariant = Options_DateTimeType_invariant;
  static inline bool DateTimeType_IsValid(int value) {
    return Options_DateTimeType_IsValid(value);
  }
  static constexpr DateTimeType DateTimeType_MIN = Options_DateTimeType_DateTimeType_MIN;
  static constexpr DateTimeType DateTimeType_MAX = Options_DateTimeType_DateTimeType_MAX;
  static constexpr int DateTimeType_ARRAYSIZE = Options_DateTimeType_DateTimeType_ARRAYSIZE;
  template <typename T>
  static inline const std::string& DateTimeType_Name(T value) {
    return Options_DateTimeType_Name(value);
  }
  static inline bool DateTimeType_Parse(absl::string_view name, DateTimeType* value) {
    return Options_DateTimeType_Parse(name, value);
  }

  using ExpansionProperties = Options_ExpansionProperties;
  static constexpr ExpansionProperties cost = Options_ExpansionProperties_cost;
  static constexpr ExpansionProperties duration = Options_ExpansionProperties_duration;
  static constexpr ExpansionProperties distance = Options_ExpansionProperties_distance;
  static constexpr ExpansionProperties edge_status = Options_ExpansionProperties_edge_status;
  static constexpr ExpansionProperties edge_id = Options_ExpansionProperties_edge_id;
  static constexpr ExpansionProperties pred_edge_id = Options_ExpansionProperties_pred_edge_id;
  static constexpr ExpansionProperties expansion_type = Options_ExpansionProperties_expansion_type;
  static inline bool ExpansionProperties_IsValid(int value) {
    return Options_ExpansionProperties_IsValid(value);
  }
  static constexpr ExpansionProperties ExpansionProperties_MIN = Options_ExpansionProperties_ExpansionProperties_MIN;
  static constexpr ExpansionProperties ExpansionProperties_MAX = Options_ExpansionProperties_ExpansionProperties_MAX;
  static constexpr int ExpansionProperties_ARRAYSIZE = Options_ExpansionProperties_ExpansionProperties_ARRAYSIZE;
  template <typename T>
  static inline const std::string& ExpansionProperties_Name(T value) {
    return Options_ExpansionProperties_Name(value);
  }
  static inline bool ExpansionProperties_Parse(absl::string_view name, ExpansionProperties* value) {
    return Options_ExpansionProperties_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCostingsFieldNumber = 13,
    kLocationsFieldNumber = 14,
    kExcludeLocationsFieldNumber = 15,
    kSourcesFieldNumber = 16,
    kTargetsFieldNumber = 17,
    kShapeFieldNumber = 20,
    kContoursFieldNumber = 22,
    kTraceFieldNumber = 27,
    kFilterAttributesFieldNumber = 34,
    kRecostingsFieldNumber = 46,
    kExcludePolygonsFieldNumber = 47,
    kExpansionPropertiesFieldNumber = 51,
    kPbfFieldSelectorFieldNumber = 52,
    kUnitsFieldNumber = 1,
    kDirectionsTypeFieldNumber = 3,
    kFormatFieldNumber = 4,
    kActionFieldNumber = 8,
    kCostingTypeFieldNumber = 12,
    kDateTimeTypeFieldNumber = 18,
    kShapeMatchFieldNumber = 28,
    kFilterActionFieldNumber = 33,
    kReverseFieldNumber = 53,
    kBannerInstructionsFieldNumber = 55,
    kVoiceInstructionsFieldNumber = 57,
    kDedupeFieldNumber = 58,
    kElevationIntervalFieldNumber = 56,
    kLanguageFieldNumber = 2,
    kIdFieldNumber = 5,
    kJsonpFieldNumber = 6,
    kEncodedPolylineFieldNumber = 7,
    kRangeFieldNumber = 10,
    kVerboseFieldNumber = 11,
    kDateTimeFieldNumber = 19,
    kResampleDistanceFieldNumber = 21,
    kPolygonsFieldNumber = 23,
    kDenoiseFieldNumber = 24,
    kGeneralizeFieldNumber = 25,
    kShowLocationsFieldNumber = 26,
    kGpsAccuracyFieldNumber = 30,
    kSearchRadiusFieldNumber = 31,
    kTurnPenaltyFactorFieldNumber = 32,
    kBreakageDistanceFieldNumber = 36,
    kUseTimestampsFieldNumber = 37,
    kShapeFormatFieldNumber = 38,
    kAlternatesFieldNumber = 39,
    kInterpolationDistanceFieldNumber = 40,
    kGuidanceViewsFieldNumber = 41,
    kHeightPrecisionFieldNumber = 43,
    kRoundaboutExitsFieldNumber = 44,
    kLinearReferencesFieldNumber = 45,
    kPrioritizeBidirectionalFieldNumber = 48,
    kExpansionActionFieldNumber = 49,
    kSkipOppositesFieldNumber = 50,
    kMatrixLocationsFieldNumber = 54,
  };
  // map<int32, .valhalla.Costing> costings = 13;
  int costings_size() const;
  private:
  int _internal_costings_size() const;

  public:
  void clear_costings() ;
  const ::google::protobuf::Map<::int32_t, ::valhalla::Costing>& costings() const;
  ::google::protobuf::Map<::int32_t, ::valhalla::Costing>* mutable_costings();

  private:
  const ::google::protobuf::Map<::int32_t, ::valhalla::Costing>& _internal_costings() const;
  ::google::protobuf::Map<::int32_t, ::valhalla::Costing>* _internal_mutable_costings();

  public:
  // repeated .valhalla.Location locations = 14;
  int locations_size() const;
  private:
  int _internal_locations_size() const;

  public:
  void clear_locations() ;
  ::valhalla::Location* mutable_locations(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
      mutable_locations();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::Location>& _internal_locations() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::Location>* _internal_mutable_locations();
  public:
  const ::valhalla::Location& locations(int index) const;
  ::valhalla::Location* add_locations();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
      locations() const;
  // repeated .valhalla.Location exclude_locations = 15;
  int exclude_locations_size() const;
  private:
  int _internal_exclude_locations_size() const;

  public:
  void clear_exclude_locations() ;
  ::valhalla::Location* mutable_exclude_locations(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
      mutable_exclude_locations();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::Location>& _internal_exclude_locations() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::Location>* _internal_mutable_exclude_locations();
  public:
  const ::valhalla::Location& exclude_locations(int index) const;
  ::valhalla::Location* add_exclude_locations();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
      exclude_locations() const;
  // repeated .valhalla.Location sources = 16;
  int sources_size() const;
  private:
  int _internal_sources_size() const;

  public:
  void clear_sources() ;
  ::valhalla::Location* mutable_sources(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
      mutable_sources();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::Location>& _internal_sources() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::Location>* _internal_mutable_sources();
  public:
  const ::valhalla::Location& sources(int index) const;
  ::valhalla::Location* add_sources();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
      sources() const;
  // repeated .valhalla.Location targets = 17;
  int targets_size() const;
  private:
  int _internal_targets_size() const;

  public:
  void clear_targets() ;
  ::valhalla::Location* mutable_targets(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
      mutable_targets();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::Location>& _internal_targets() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::Location>* _internal_mutable_targets();
  public:
  const ::valhalla::Location& targets(int index) const;
  ::valhalla::Location* add_targets();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
      targets() const;
  // repeated .valhalla.Location shape = 20;
  int shape_size() const;
  private:
  int _internal_shape_size() const;

  public:
  void clear_shape() ;
  ::valhalla::Location* mutable_shape(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
      mutable_shape();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::Location>& _internal_shape() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::Location>* _internal_mutable_shape();
  public:
  const ::valhalla::Location& shape(int index) const;
  ::valhalla::Location* add_shape();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
      shape() const;
  // repeated .valhalla.Contour contours = 22;
  int contours_size() const;
  private:
  int _internal_contours_size() const;

  public:
  void clear_contours() ;
  ::valhalla::Contour* mutable_contours(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::Contour >*
      mutable_contours();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::Contour>& _internal_contours() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::Contour>* _internal_mutable_contours();
  public:
  const ::valhalla::Contour& contours(int index) const;
  ::valhalla::Contour* add_contours();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::Contour >&
      contours() const;
  // repeated .valhalla.Location trace = 27;
  int trace_size() const;
  private:
  int _internal_trace_size() const;

  public:
  void clear_trace() ;
  ::valhalla::Location* mutable_trace(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
      mutable_trace();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::Location>& _internal_trace() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::Location>* _internal_mutable_trace();
  public:
  const ::valhalla::Location& trace(int index) const;
  ::valhalla::Location* add_trace();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
      trace() const;
  // repeated string filter_attributes = 34;
  int filter_attributes_size() const;
  private:
  int _internal_filter_attributes_size() const;

  public:
  void clear_filter_attributes() ;
  const std::string& filter_attributes(int index) const;
  std::string* mutable_filter_attributes(int index);
  void set_filter_attributes(int index, const std::string& value);
  void set_filter_attributes(int index, std::string&& value);
  void set_filter_attributes(int index, const char* value);
  void set_filter_attributes(int index, const char* value, std::size_t size);
  void set_filter_attributes(int index, absl::string_view value);
  std::string* add_filter_attributes();
  void add_filter_attributes(const std::string& value);
  void add_filter_attributes(std::string&& value);
  void add_filter_attributes(const char* value);
  void add_filter_attributes(const char* value, std::size_t size);
  void add_filter_attributes(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& filter_attributes() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_filter_attributes();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_filter_attributes() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_filter_attributes();

  public:
  // repeated .valhalla.Costing recostings = 46;
  int recostings_size() const;
  private:
  int _internal_recostings_size() const;

  public:
  void clear_recostings() ;
  ::valhalla::Costing* mutable_recostings(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::Costing >*
      mutable_recostings();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::Costing>& _internal_recostings() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::Costing>* _internal_mutable_recostings();
  public:
  const ::valhalla::Costing& recostings(int index) const;
  ::valhalla::Costing* add_recostings();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::Costing >&
      recostings() const;
  // repeated .valhalla.Ring exclude_polygons = 47;
  int exclude_polygons_size() const;
  private:
  int _internal_exclude_polygons_size() const;

  public:
  void clear_exclude_polygons() ;
  ::valhalla::Ring* mutable_exclude_polygons(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::Ring >*
      mutable_exclude_polygons();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::Ring>& _internal_exclude_polygons() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::Ring>* _internal_mutable_exclude_polygons();
  public:
  const ::valhalla::Ring& exclude_polygons(int index) const;
  ::valhalla::Ring* add_exclude_polygons();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::Ring >&
      exclude_polygons() const;
  // repeated .valhalla.Options.ExpansionProperties expansion_properties = 51;
  int expansion_properties_size() const;
  private:
  int _internal_expansion_properties_size() const;

  public:
  void clear_expansion_properties() ;
  public:
  ::valhalla::Options_ExpansionProperties expansion_properties(int index) const;
  void set_expansion_properties(int index, ::valhalla::Options_ExpansionProperties value);
  void add_expansion_properties(::valhalla::Options_ExpansionProperties value);
  const ::google::protobuf::RepeatedField<int>& expansion_properties() const;
  ::google::protobuf::RepeatedField<int>* mutable_expansion_properties();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_expansion_properties() const;
  ::google::protobuf::RepeatedField<int>* _internal_mutable_expansion_properties();

  public:
  // .valhalla.PbfFieldSelector pbf_field_selector = 52;
  bool has_pbf_field_selector() const;
  void clear_pbf_field_selector() ;
  const ::valhalla::PbfFieldSelector& pbf_field_selector() const;
  PROTOBUF_NODISCARD ::valhalla::PbfFieldSelector* release_pbf_field_selector();
  ::valhalla::PbfFieldSelector* mutable_pbf_field_selector();
  void set_allocated_pbf_field_selector(::valhalla::PbfFieldSelector* value);
  void unsafe_arena_set_allocated_pbf_field_selector(::valhalla::PbfFieldSelector* value);
  ::valhalla::PbfFieldSelector* unsafe_arena_release_pbf_field_selector();

  private:
  const ::valhalla::PbfFieldSelector& _internal_pbf_field_selector() const;
  ::valhalla::PbfFieldSelector* _internal_mutable_pbf_field_selector();

  public:
  // .valhalla.Options.Units units = 1;
  void clear_units() ;
  ::valhalla::Options_Units units() const;
  void set_units(::valhalla::Options_Units value);

  private:
  ::valhalla::Options_Units _internal_units() const;
  void _internal_set_units(::valhalla::Options_Units value);

  public:
  // .valhalla.DirectionsType directions_type = 3;
  void clear_directions_type() ;
  ::valhalla::DirectionsType directions_type() const;
  void set_directions_type(::valhalla::DirectionsType value);

  private:
  ::valhalla::DirectionsType _internal_directions_type() const;
  void _internal_set_directions_type(::valhalla::DirectionsType value);

  public:
  // .valhalla.Options.Format format = 4;
  void clear_format() ;
  ::valhalla::Options_Format format() const;
  void set_format(::valhalla::Options_Format value);

  private:
  ::valhalla::Options_Format _internal_format() const;
  void _internal_set_format(::valhalla::Options_Format value);

  public:
  // .valhalla.Options.Action action = 8;
  void clear_action() ;
  ::valhalla::Options_Action action() const;
  void set_action(::valhalla::Options_Action value);

  private:
  ::valhalla::Options_Action _internal_action() const;
  void _internal_set_action(::valhalla::Options_Action value);

  public:
  // .valhalla.Costing.Type costing_type = 12;
  void clear_costing_type() ;
  ::valhalla::Costing_Type costing_type() const;
  void set_costing_type(::valhalla::Costing_Type value);

  private:
  ::valhalla::Costing_Type _internal_costing_type() const;
  void _internal_set_costing_type(::valhalla::Costing_Type value);

  public:
  // .valhalla.Options.DateTimeType date_time_type = 18;
  void clear_date_time_type() ;
  ::valhalla::Options_DateTimeType date_time_type() const;
  void set_date_time_type(::valhalla::Options_DateTimeType value);

  private:
  ::valhalla::Options_DateTimeType _internal_date_time_type() const;
  void _internal_set_date_time_type(::valhalla::Options_DateTimeType value);

  public:
  // .valhalla.ShapeMatch shape_match = 28;
  void clear_shape_match() ;
  ::valhalla::ShapeMatch shape_match() const;
  void set_shape_match(::valhalla::ShapeMatch value);

  private:
  ::valhalla::ShapeMatch _internal_shape_match() const;
  void _internal_set_shape_match(::valhalla::ShapeMatch value);

  public:
  // .valhalla.FilterAction filter_action = 33;
  void clear_filter_action() ;
  ::valhalla::FilterAction filter_action() const;
  void set_filter_action(::valhalla::FilterAction value);

  private:
  ::valhalla::FilterAction _internal_filter_action() const;
  void _internal_set_filter_action(::valhalla::FilterAction value);

  public:
  // bool reverse = 53;
  void clear_reverse() ;
  bool reverse() const;
  void set_reverse(bool value);

  private:
  bool _internal_reverse() const;
  void _internal_set_reverse(bool value);

  public:
  // bool banner_instructions = 55;
  void clear_banner_instructions() ;
  bool banner_instructions() const;
  void set_banner_instructions(bool value);

  private:
  bool _internal_banner_instructions() const;
  void _internal_set_banner_instructions(bool value);

  public:
  // bool voice_instructions = 57;
  void clear_voice_instructions() ;
  bool voice_instructions() const;
  void set_voice_instructions(bool value);

  private:
  bool _internal_voice_instructions() const;
  void _internal_set_voice_instructions(bool value);

  public:
  // bool dedupe = 58;
  void clear_dedupe() ;
  bool dedupe() const;
  void set_dedupe(bool value);

  private:
  bool _internal_dedupe() const;
  void _internal_set_dedupe(bool value);

  public:
  // float elevation_interval = 56;
  void clear_elevation_interval() ;
  float elevation_interval() const;
  void set_elevation_interval(float value);

  private:
  float _internal_elevation_interval() const;
  void _internal_set_elevation_interval(float value);

  public:
  // string language = 2;
  bool has_language() const;
  void clear_language() ;
  const std::string& language() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_language(Arg_&& arg, Args_... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* value);

  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(
      const std::string& value);
  std::string* _internal_mutable_language();

  public:
  // string id = 5;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string jsonp = 6;
  bool has_jsonp() const;
  void clear_jsonp() ;
  const std::string& jsonp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_jsonp(Arg_&& arg, Args_... args);
  std::string* mutable_jsonp();
  PROTOBUF_NODISCARD std::string* release_jsonp();
  void set_allocated_jsonp(std::string* value);

  private:
  const std::string& _internal_jsonp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_jsonp(
      const std::string& value);
  std::string* _internal_mutable_jsonp();

  public:
  // string encoded_polyline = 7;
  bool has_encoded_polyline() const;
  void clear_encoded_polyline() ;
  const std::string& encoded_polyline() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_encoded_polyline(Arg_&& arg, Args_... args);
  std::string* mutable_encoded_polyline();
  PROTOBUF_NODISCARD std::string* release_encoded_polyline();
  void set_allocated_encoded_polyline(std::string* value);

  private:
  const std::string& _internal_encoded_polyline() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encoded_polyline(
      const std::string& value);
  std::string* _internal_mutable_encoded_polyline();

  public:
  // bool range = 10;
  bool has_range() const;
  void clear_range() ;
  bool range() const;
  void set_range(bool value);

  private:
  bool _internal_range() const;
  void _internal_set_range(bool value);

  public:
  // bool verbose = 11;
  bool has_verbose() const;
  void clear_verbose() ;
  bool verbose() const;
  void set_verbose(bool value);

  private:
  bool _internal_verbose() const;
  void _internal_set_verbose(bool value);

  public:
  // string date_time = 19;
  bool has_date_time() const;
  void clear_date_time() ;
  const std::string& date_time() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_date_time(Arg_&& arg, Args_... args);
  std::string* mutable_date_time();
  PROTOBUF_NODISCARD std::string* release_date_time();
  void set_allocated_date_time(std::string* value);

  private:
  const std::string& _internal_date_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_date_time(
      const std::string& value);
  std::string* _internal_mutable_date_time();

  public:
  // double resample_distance = 21;
  bool has_resample_distance() const;
  void clear_resample_distance() ;
  double resample_distance() const;
  void set_resample_distance(double value);

  private:
  double _internal_resample_distance() const;
  void _internal_set_resample_distance(double value);

  public:
  // bool polygons = 23;
  bool has_polygons() const;
  void clear_polygons() ;
  bool polygons() const;
  void set_polygons(bool value);

  private:
  bool _internal_polygons() const;
  void _internal_set_polygons(bool value);

  public:
  // float denoise = 24;
  bool has_denoise() const;
  void clear_denoise() ;
  float denoise() const;
  void set_denoise(float value);

  private:
  float _internal_denoise() const;
  void _internal_set_denoise(float value);

  public:
  // float generalize = 25;
  bool has_generalize() const;
  void clear_generalize() ;
  float generalize() const;
  void set_generalize(float value);

  private:
  float _internal_generalize() const;
  void _internal_set_generalize(float value);

  public:
  // bool show_locations = 26;
  bool has_show_locations() const;
  void clear_show_locations() ;
  bool show_locations() const;
  void set_show_locations(bool value);

  private:
  bool _internal_show_locations() const;
  void _internal_set_show_locations(bool value);

  public:
  // float gps_accuracy = 30;
  bool has_gps_accuracy() const;
  void clear_gps_accuracy() ;
  float gps_accuracy() const;
  void set_gps_accuracy(float value);

  private:
  float _internal_gps_accuracy() const;
  void _internal_set_gps_accuracy(float value);

  public:
  // float search_radius = 31;
  bool has_search_radius() const;
  void clear_search_radius() ;
  float search_radius() const;
  void set_search_radius(float value);

  private:
  float _internal_search_radius() const;
  void _internal_set_search_radius(float value);

  public:
  // float turn_penalty_factor = 32;
  bool has_turn_penalty_factor() const;
  void clear_turn_penalty_factor() ;
  float turn_penalty_factor() const;
  void set_turn_penalty_factor(float value);

  private:
  float _internal_turn_penalty_factor() const;
  void _internal_set_turn_penalty_factor(float value);

  public:
  // float breakage_distance = 36;
  bool has_breakage_distance() const;
  void clear_breakage_distance() ;
  float breakage_distance() const;
  void set_breakage_distance(float value);

  private:
  float _internal_breakage_distance() const;
  void _internal_set_breakage_distance(float value);

  public:
  // bool use_timestamps = 37;
  bool has_use_timestamps() const;
  void clear_use_timestamps() ;
  bool use_timestamps() const;
  void set_use_timestamps(bool value);

  private:
  bool _internal_use_timestamps() const;
  void _internal_set_use_timestamps(bool value);

  public:
  // .valhalla.ShapeFormat shape_format = 38;
  bool has_shape_format() const;
  void clear_shape_format() ;
  ::valhalla::ShapeFormat shape_format() const;
  void set_shape_format(::valhalla::ShapeFormat value);

  private:
  ::valhalla::ShapeFormat _internal_shape_format() const;
  void _internal_set_shape_format(::valhalla::ShapeFormat value);

  public:
  // uint32 alternates = 39;
  bool has_alternates() const;
  void clear_alternates() ;
  ::uint32_t alternates() const;
  void set_alternates(::uint32_t value);

  private:
  ::uint32_t _internal_alternates() const;
  void _internal_set_alternates(::uint32_t value);

  public:
  // float interpolation_distance = 40;
  bool has_interpolation_distance() const;
  void clear_interpolation_distance() ;
  float interpolation_distance() const;
  void set_interpolation_distance(float value);

  private:
  float _internal_interpolation_distance() const;
  void _internal_set_interpolation_distance(float value);

  public:
  // bool guidance_views = 41;
  bool has_guidance_views() const;
  void clear_guidance_views() ;
  bool guidance_views() const;
  void set_guidance_views(bool value);

  private:
  bool _internal_guidance_views() const;
  void _internal_set_guidance_views(bool value);

  public:
  // uint32 height_precision = 43;
  bool has_height_precision() const;
  void clear_height_precision() ;
  ::uint32_t height_precision() const;
  void set_height_precision(::uint32_t value);

  private:
  ::uint32_t _internal_height_precision() const;
  void _internal_set_height_precision(::uint32_t value);

  public:
  // bool roundabout_exits = 44;
  bool has_roundabout_exits() const;
  void clear_roundabout_exits() ;
  bool roundabout_exits() const;
  void set_roundabout_exits(bool value);

  private:
  bool _internal_roundabout_exits() const;
  void _internal_set_roundabout_exits(bool value);

  public:
  // bool linear_references = 45;
  bool has_linear_references() const;
  void clear_linear_references() ;
  bool linear_references() const;
  void set_linear_references(bool value);

  private:
  bool _internal_linear_references() const;
  void _internal_set_linear_references(bool value);

  public:
  // bool prioritize_bidirectional = 48;
  bool has_prioritize_bidirectional() const;
  void clear_prioritize_bidirectional() ;
  bool prioritize_bidirectional() const;
  void set_prioritize_bidirectional(bool value);

  private:
  bool _internal_prioritize_bidirectional() const;
  void _internal_set_prioritize_bidirectional(bool value);

  public:
  // .valhalla.Options.Action expansion_action = 49;
  bool has_expansion_action() const;
  void clear_expansion_action() ;
  ::valhalla::Options_Action expansion_action() const;
  void set_expansion_action(::valhalla::Options_Action value);

  private:
  ::valhalla::Options_Action _internal_expansion_action() const;
  void _internal_set_expansion_action(::valhalla::Options_Action value);

  public:
  // bool skip_opposites = 50;
  bool has_skip_opposites() const;
  void clear_skip_opposites() ;
  bool skip_opposites() const;
  void set_skip_opposites(bool value);

  private:
  bool _internal_skip_opposites() const;
  void _internal_set_skip_opposites(bool value);

  public:
  // uint32 matrix_locations = 54;
  bool has_matrix_locations() const;
  void clear_matrix_locations() ;
  ::uint32_t matrix_locations() const;
  void set_matrix_locations(::uint32_t value);

  private:
  ::uint32_t _internal_matrix_locations() const;
  void _internal_set_matrix_locations(::uint32_t value);

  public:
  void clear_has_language();
  HasLanguageCase has_language_case() const;
  void clear_has_id();
  HasIdCase has_id_case() const;
  void clear_has_jsonp();
  HasJsonpCase has_jsonp_case() const;
  void clear_has_encoded_polyline();
  HasEncodedPolylineCase has_encoded_polyline_case() const;
  void clear_has_range();
  HasRangeCase has_range_case() const;
  void clear_has_verbose();
  HasVerboseCase has_verbose_case() const;
  void clear_has_date_time();
  HasDateTimeCase has_date_time_case() const;
  void clear_has_resample_distance();
  HasResampleDistanceCase has_resample_distance_case() const;
  void clear_has_polygons();
  HasPolygonsCase has_polygons_case() const;
  void clear_has_denoise();
  HasDenoiseCase has_denoise_case() const;
  void clear_has_generalize();
  HasGeneralizeCase has_generalize_case() const;
  void clear_has_show_locations();
  HasShowLocationsCase has_show_locations_case() const;
  void clear_has_gps_accuracy();
  HasGpsAccuracyCase has_gps_accuracy_case() const;
  void clear_has_search_radius();
  HasSearchRadiusCase has_search_radius_case() const;
  void clear_has_turn_penalty_factor();
  HasTurnPenaltyFactorCase has_turn_penalty_factor_case() const;
  void clear_has_breakage_distance();
  HasBreakageDistanceCase has_breakage_distance_case() const;
  void clear_has_use_timestamps();
  HasUseTimestampsCase has_use_timestamps_case() const;
  void clear_has_shape_format();
  HasShapeFormatCase has_shape_format_case() const;
  void clear_has_alternates();
  HasAlternatesCase has_alternates_case() const;
  void clear_has_interpolation_distance();
  HasInterpolationDistanceCase has_interpolation_distance_case() const;
  void clear_has_guidance_views();
  HasGuidanceViewsCase has_guidance_views_case() const;
  void clear_has_height_precision();
  HasHeightPrecisionCase has_height_precision_case() const;
  void clear_has_roundabout_exits();
  HasRoundaboutExitsCase has_roundabout_exits_case() const;
  void clear_has_linear_references();
  HasLinearReferencesCase has_linear_references_case() const;
  void clear_has_prioritize_bidirectional();
  HasPrioritizeBidirectionalCase has_prioritize_bidirectional_case() const;
  void clear_has_expansion_action();
  HasExpansionActionCase has_expansion_action_case() const;
  void clear_has_skip_opposites();
  HasSkipOppositesCase has_skip_opposites_case() const;
  void clear_has_matrix_locations();
  HasMatrixLocationsCase has_matrix_locations_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.Options)
 private:
  class _Internal;
  void set_has_language();
  void set_has_id();
  void set_has_jsonp();
  void set_has_encoded_polyline();
  void set_has_range();
  void set_has_verbose();
  void set_has_date_time();
  void set_has_resample_distance();
  void set_has_polygons();
  void set_has_denoise();
  void set_has_generalize();
  void set_has_show_locations();
  void set_has_gps_accuracy();
  void set_has_search_radius();
  void set_has_turn_penalty_factor();
  void set_has_breakage_distance();
  void set_has_use_timestamps();
  void set_has_shape_format();
  void set_has_alternates();
  void set_has_interpolation_distance();
  void set_has_guidance_views();
  void set_has_height_precision();
  void set_has_roundabout_exits();
  void set_has_linear_references();
  void set_has_prioritize_bidirectional();
  void set_has_expansion_action();
  void set_has_skip_opposites();
  void set_has_matrix_locations();

  inline bool has_has_language() const;
  inline void clear_has_has_language();

  inline bool has_has_id() const;
  inline void clear_has_has_id();

  inline bool has_has_jsonp() const;
  inline void clear_has_has_jsonp();

  inline bool has_has_encoded_polyline() const;
  inline void clear_has_has_encoded_polyline();

  inline bool has_has_range() const;
  inline void clear_has_has_range();

  inline bool has_has_verbose() const;
  inline void clear_has_has_verbose();

  inline bool has_has_date_time() const;
  inline void clear_has_has_date_time();

  inline bool has_has_resample_distance() const;
  inline void clear_has_has_resample_distance();

  inline bool has_has_polygons() const;
  inline void clear_has_has_polygons();

  inline bool has_has_denoise() const;
  inline void clear_has_has_denoise();

  inline bool has_has_generalize() const;
  inline void clear_has_has_generalize();

  inline bool has_has_show_locations() const;
  inline void clear_has_has_show_locations();

  inline bool has_has_gps_accuracy() const;
  inline void clear_has_has_gps_accuracy();

  inline bool has_has_search_radius() const;
  inline void clear_has_has_search_radius();

  inline bool has_has_turn_penalty_factor() const;
  inline void clear_has_has_turn_penalty_factor();

  inline bool has_has_breakage_distance() const;
  inline void clear_has_has_breakage_distance();

  inline bool has_has_use_timestamps() const;
  inline void clear_has_has_use_timestamps();

  inline bool has_has_shape_format() const;
  inline void clear_has_has_shape_format();

  inline bool has_has_alternates() const;
  inline void clear_has_has_alternates();

  inline bool has_has_interpolation_distance() const;
  inline void clear_has_has_interpolation_distance();

  inline bool has_has_guidance_views() const;
  inline void clear_has_has_guidance_views();

  inline bool has_has_height_precision() const;
  inline void clear_has_has_height_precision();

  inline bool has_has_roundabout_exits() const;
  inline void clear_has_has_roundabout_exits();

  inline bool has_has_linear_references() const;
  inline void clear_has_has_linear_references();

  inline bool has_has_prioritize_bidirectional() const;
  inline void clear_has_has_prioritize_bidirectional();

  inline bool has_has_expansion_action() const;
  inline void clear_has_has_expansion_action();

  inline bool has_has_skip_opposites() const;
  inline void clear_has_has_skip_opposites();

  inline bool has_has_matrix_locations() const;
  inline void clear_has_has_matrix_locations();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 54, 12,
      130, 9>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapFieldLite<::int32_t, ::valhalla::Costing> costings_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::Location > locations_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::Location > exclude_locations_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::Location > sources_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::Location > targets_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::Location > shape_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::Contour > contours_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::Location > trace_;
    ::google::protobuf::RepeatedPtrField<std::string> filter_attributes_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::Costing > recostings_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::Ring > exclude_polygons_;
    ::google::protobuf::RepeatedField<int> expansion_properties_;
    mutable ::google::protobuf::internal::CachedSize _expansion_properties_cached_byte_size_;
    ::valhalla::PbfFieldSelector* pbf_field_selector_;
    int units_;
    int directions_type_;
    int format_;
    int action_;
    int costing_type_;
    int date_time_type_;
    int shape_match_;
    int filter_action_;
    bool reverse_;
    bool banner_instructions_;
    bool voice_instructions_;
    bool dedupe_;
    float elevation_interval_;
    union HasLanguageUnion {
      constexpr HasLanguageUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr language_;
    } has_language_;
    union HasIdUnion {
      constexpr HasIdUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr id_;
    } has_id_;
    union HasJsonpUnion {
      constexpr HasJsonpUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr jsonp_;
    } has_jsonp_;
    union HasEncodedPolylineUnion {
      constexpr HasEncodedPolylineUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr encoded_polyline_;
    } has_encoded_polyline_;
    union HasRangeUnion {
      constexpr HasRangeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool range_;
    } has_range_;
    union HasVerboseUnion {
      constexpr HasVerboseUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool verbose_;
    } has_verbose_;
    union HasDateTimeUnion {
      constexpr HasDateTimeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr date_time_;
    } has_date_time_;
    union HasResampleDistanceUnion {
      constexpr HasResampleDistanceUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      double resample_distance_;
    } has_resample_distance_;
    union HasPolygonsUnion {
      constexpr HasPolygonsUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool polygons_;
    } has_polygons_;
    union HasDenoiseUnion {
      constexpr HasDenoiseUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float denoise_;
    } has_denoise_;
    union HasGeneralizeUnion {
      constexpr HasGeneralizeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float generalize_;
    } has_generalize_;
    union HasShowLocationsUnion {
      constexpr HasShowLocationsUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool show_locations_;
    } has_show_locations_;
    union HasGpsAccuracyUnion {
      constexpr HasGpsAccuracyUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float gps_accuracy_;
    } has_gps_accuracy_;
    union HasSearchRadiusUnion {
      constexpr HasSearchRadiusUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float search_radius_;
    } has_search_radius_;
    union HasTurnPenaltyFactorUnion {
      constexpr HasTurnPenaltyFactorUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float turn_penalty_factor_;
    } has_turn_penalty_factor_;
    union HasBreakageDistanceUnion {
      constexpr HasBreakageDistanceUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float breakage_distance_;
    } has_breakage_distance_;
    union HasUseTimestampsUnion {
      constexpr HasUseTimestampsUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool use_timestamps_;
    } has_use_timestamps_;
    union HasShapeFormatUnion {
      constexpr HasShapeFormatUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      int shape_format_;
    } has_shape_format_;
    union HasAlternatesUnion {
      constexpr HasAlternatesUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint32_t alternates_;
    } has_alternates_;
    union HasInterpolationDistanceUnion {
      constexpr HasInterpolationDistanceUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float interpolation_distance_;
    } has_interpolation_distance_;
    union HasGuidanceViewsUnion {
      constexpr HasGuidanceViewsUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool guidance_views_;
    } has_guidance_views_;
    union HasHeightPrecisionUnion {
      constexpr HasHeightPrecisionUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint32_t height_precision_;
    } has_height_precision_;
    union HasRoundaboutExitsUnion {
      constexpr HasRoundaboutExitsUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool roundabout_exits_;
    } has_roundabout_exits_;
    union HasLinearReferencesUnion {
      constexpr HasLinearReferencesUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool linear_references_;
    } has_linear_references_;
    union HasPrioritizeBidirectionalUnion {
      constexpr HasPrioritizeBidirectionalUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool prioritize_bidirectional_;
    } has_prioritize_bidirectional_;
    union HasExpansionActionUnion {
      constexpr HasExpansionActionUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      int expansion_action_;
    } has_expansion_action_;
    union HasSkipOppositesUnion {
      constexpr HasSkipOppositesUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool skip_opposites_;
    } has_skip_opposites_;
    union HasMatrixLocationsUnion {
      constexpr HasMatrixLocationsUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint32_t matrix_locations_;
    } has_matrix_locations_;
    ::uint32_t _oneof_case_[28];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_options_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Contour

// float time = 1;
inline bool Contour::has_time() const {
  return has_time_case() == kTime;
}
inline void Contour::set_has_time() {
  _impl_._oneof_case_[0] = kTime;
}
inline void Contour::clear_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_time_case() == kTime) {
    _impl_.has_time_.time_ = 0;
    clear_has_has_time();
  }
}
inline float Contour::time() const {
  // @@protoc_insertion_point(field_get:valhalla.Contour.time)
  return _internal_time();
}
inline void Contour::set_time(float value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:valhalla.Contour.time)
}
inline float Contour::_internal_time() const {
  if (has_time_case() == kTime) {
    return _impl_.has_time_.time_;
  }
  return 0;
}
inline void Contour::_internal_set_time(float value) {
  if (has_time_case() != kTime) {
    clear_has_time();
    set_has_time();
  }
  _impl_.has_time_.time_ = value;
}

// string color = 2;
inline bool Contour::has_color() const {
  return has_color_case() == kColor;
}
inline void Contour::set_has_color() {
  _impl_._oneof_case_[1] = kColor;
}
inline void Contour::clear_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_color_case() == kColor) {
    _impl_.has_color_.color_.Destroy();
    clear_has_has_color();
  }
}
inline const std::string& Contour::color() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Contour.color)
  return _internal_color();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Contour::set_color(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_color_case() != kColor) {
    clear_has_color();

    set_has_color();
    _impl_.has_color_.color_.InitDefault();
  }
  _impl_.has_color_.color_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.Contour.color)
}
inline std::string* Contour::mutable_color() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:valhalla.Contour.color)
  return _s;
}
inline const std::string& Contour::_internal_color() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (has_color_case() != kColor) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.has_color_.color_.Get();
}
inline void Contour::_internal_set_color(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_color_case() != kColor) {
    clear_has_color();

    set_has_color();
    _impl_.has_color_.color_.InitDefault();
  }
  _impl_.has_color_.color_.Set(value, GetArena());
}
inline std::string* Contour::_internal_mutable_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_color_case() != kColor) {
    clear_has_color();

    set_has_color();
    _impl_.has_color_.color_.InitDefault();
  }
  return _impl_.has_color_.color_.Mutable( GetArena());
}
inline std::string* Contour::release_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.Contour.color)
  if (has_color_case() != kColor) {
    return nullptr;
  }
  clear_has_has_color();
  return _impl_.has_color_.color_.Release();
}
inline void Contour::set_allocated_color(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_has_color()) {
    clear_has_color();
  }
  if (value != nullptr) {
    set_has_color();
    _impl_.has_color_.color_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Contour.color)
}

// float distance = 3;
inline bool Contour::has_distance() const {
  return has_distance_case() == kDistance;
}
inline void Contour::set_has_distance() {
  _impl_._oneof_case_[2] = kDistance;
}
inline void Contour::clear_distance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_distance_case() == kDistance) {
    _impl_.has_distance_.distance_ = 0;
    clear_has_has_distance();
  }
}
inline float Contour::distance() const {
  // @@protoc_insertion_point(field_get:valhalla.Contour.distance)
  return _internal_distance();
}
inline void Contour::set_distance(float value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:valhalla.Contour.distance)
}
inline float Contour::_internal_distance() const {
  if (has_distance_case() == kDistance) {
    return _impl_.has_distance_.distance_;
  }
  return 0;
}
inline void Contour::_internal_set_distance(float value) {
  if (has_distance_case() != kDistance) {
    clear_has_distance();
    set_has_distance();
  }
  _impl_.has_distance_.distance_ = value;
}

inline bool Contour::has_has_time() const {
  return has_time_case() != HAS_TIME_NOT_SET;
}
inline void Contour::clear_has_has_time() {
  _impl_._oneof_case_[0] = HAS_TIME_NOT_SET;
}
inline bool Contour::has_has_color() const {
  return has_color_case() != HAS_COLOR_NOT_SET;
}
inline void Contour::clear_has_has_color() {
  _impl_._oneof_case_[1] = HAS_COLOR_NOT_SET;
}
inline bool Contour::has_has_distance() const {
  return has_distance_case() != HAS_DISTANCE_NOT_SET;
}
inline void Contour::clear_has_has_distance() {
  _impl_._oneof_case_[2] = HAS_DISTANCE_NOT_SET;
}
inline Contour::HasTimeCase Contour::has_time_case() const {
  return Contour::HasTimeCase(_impl_._oneof_case_[0]);
}
inline Contour::HasColorCase Contour::has_color_case() const {
  return Contour::HasColorCase(_impl_._oneof_case_[1]);
}
inline Contour::HasDistanceCase Contour::has_distance_case() const {
  return Contour::HasDistanceCase(_impl_._oneof_case_[2]);
}
// -------------------------------------------------------------------

// Ring

// repeated .valhalla.LatLng coords = 1;
inline int Ring::_internal_coords_size() const {
  return _internal_coords().size();
}
inline int Ring::coords_size() const {
  return _internal_coords_size();
}
inline ::valhalla::LatLng* Ring::mutable_coords(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.Ring.coords)
  return _internal_mutable_coords()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::LatLng>* Ring::mutable_coords()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Ring.coords)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_coords();
}
inline const ::valhalla::LatLng& Ring::coords(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Ring.coords)
  return _internal_coords().Get(index);
}
inline ::valhalla::LatLng* Ring::add_coords() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::LatLng* _add = _internal_mutable_coords()->Add();
  // @@protoc_insertion_point(field_add:valhalla.Ring.coords)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::LatLng>& Ring::coords() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.Ring.coords)
  return _internal_coords();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::LatLng>&
Ring::_internal_coords() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.coords_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::LatLng>*
Ring::_internal_mutable_coords() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.coords_;
}

// -------------------------------------------------------------------

// PbfFieldSelector

// bool options = 1;
inline void PbfFieldSelector::clear_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.options_ = false;
}
inline bool PbfFieldSelector::options() const {
  // @@protoc_insertion_point(field_get:valhalla.PbfFieldSelector.options)
  return _internal_options();
}
inline void PbfFieldSelector::set_options(bool value) {
  _internal_set_options(value);
  // @@protoc_insertion_point(field_set:valhalla.PbfFieldSelector.options)
}
inline bool PbfFieldSelector::_internal_options() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.options_;
}
inline void PbfFieldSelector::_internal_set_options(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.options_ = value;
}

// bool trip = 2;
inline void PbfFieldSelector::clear_trip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.trip_ = false;
}
inline bool PbfFieldSelector::trip() const {
  // @@protoc_insertion_point(field_get:valhalla.PbfFieldSelector.trip)
  return _internal_trip();
}
inline void PbfFieldSelector::set_trip(bool value) {
  _internal_set_trip(value);
  // @@protoc_insertion_point(field_set:valhalla.PbfFieldSelector.trip)
}
inline bool PbfFieldSelector::_internal_trip() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.trip_;
}
inline void PbfFieldSelector::_internal_set_trip(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.trip_ = value;
}

// bool directions = 3;
inline void PbfFieldSelector::clear_directions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.directions_ = false;
}
inline bool PbfFieldSelector::directions() const {
  // @@protoc_insertion_point(field_get:valhalla.PbfFieldSelector.directions)
  return _internal_directions();
}
inline void PbfFieldSelector::set_directions(bool value) {
  _internal_set_directions(value);
  // @@protoc_insertion_point(field_set:valhalla.PbfFieldSelector.directions)
}
inline bool PbfFieldSelector::_internal_directions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.directions_;
}
inline void PbfFieldSelector::_internal_set_directions(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.directions_ = value;
}

// bool status = 4;
inline void PbfFieldSelector::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_ = false;
}
inline bool PbfFieldSelector::status() const {
  // @@protoc_insertion_point(field_get:valhalla.PbfFieldSelector.status)
  return _internal_status();
}
inline void PbfFieldSelector::set_status(bool value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:valhalla.PbfFieldSelector.status)
}
inline bool PbfFieldSelector::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.status_;
}
inline void PbfFieldSelector::_internal_set_status(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.status_ = value;
}

// bool matrix = 5;
inline void PbfFieldSelector::clear_matrix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.matrix_ = false;
}
inline bool PbfFieldSelector::matrix() const {
  // @@protoc_insertion_point(field_get:valhalla.PbfFieldSelector.matrix)
  return _internal_matrix();
}
inline void PbfFieldSelector::set_matrix(bool value) {
  _internal_set_matrix(value);
  // @@protoc_insertion_point(field_set:valhalla.PbfFieldSelector.matrix)
}
inline bool PbfFieldSelector::_internal_matrix() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.matrix_;
}
inline void PbfFieldSelector::_internal_set_matrix(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.matrix_ = value;
}

// bool isochrone = 6;
inline void PbfFieldSelector::clear_isochrone() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.isochrone_ = false;
}
inline bool PbfFieldSelector::isochrone() const {
  // @@protoc_insertion_point(field_get:valhalla.PbfFieldSelector.isochrone)
  return _internal_isochrone();
}
inline void PbfFieldSelector::set_isochrone(bool value) {
  _internal_set_isochrone(value);
  // @@protoc_insertion_point(field_set:valhalla.PbfFieldSelector.isochrone)
}
inline bool PbfFieldSelector::_internal_isochrone() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.isochrone_;
}
inline void PbfFieldSelector::_internal_set_isochrone(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.isochrone_ = value;
}

// bool expansion = 9;
inline void PbfFieldSelector::clear_expansion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.expansion_ = false;
}
inline bool PbfFieldSelector::expansion() const {
  // @@protoc_insertion_point(field_get:valhalla.PbfFieldSelector.expansion)
  return _internal_expansion();
}
inline void PbfFieldSelector::set_expansion(bool value) {
  _internal_set_expansion(value);
  // @@protoc_insertion_point(field_set:valhalla.PbfFieldSelector.expansion)
}
inline bool PbfFieldSelector::_internal_expansion() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.expansion_;
}
inline void PbfFieldSelector::_internal_set_expansion(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.expansion_ = value;
}

// -------------------------------------------------------------------

// AvoidEdge

// uint64 id = 1;
inline bool AvoidEdge::has_id() const {
  return has_id_case() == kId;
}
inline void AvoidEdge::set_has_id() {
  _impl_._oneof_case_[0] = kId;
}
inline void AvoidEdge::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_id_case() == kId) {
    _impl_.has_id_.id_ = ::uint64_t{0u};
    clear_has_has_id();
  }
}
inline ::uint64_t AvoidEdge::id() const {
  // @@protoc_insertion_point(field_get:valhalla.AvoidEdge.id)
  return _internal_id();
}
inline void AvoidEdge::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:valhalla.AvoidEdge.id)
}
inline ::uint64_t AvoidEdge::_internal_id() const {
  if (has_id_case() == kId) {
    return _impl_.has_id_.id_;
  }
  return ::uint64_t{0u};
}
inline void AvoidEdge::_internal_set_id(::uint64_t value) {
  if (has_id_case() != kId) {
    clear_has_id();
    set_has_id();
  }
  _impl_.has_id_.id_ = value;
}

// float percent_along = 2;
inline bool AvoidEdge::has_percent_along() const {
  return has_percent_along_case() == kPercentAlong;
}
inline void AvoidEdge::set_has_percent_along() {
  _impl_._oneof_case_[1] = kPercentAlong;
}
inline void AvoidEdge::clear_percent_along() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_percent_along_case() == kPercentAlong) {
    _impl_.has_percent_along_.percent_along_ = 0;
    clear_has_has_percent_along();
  }
}
inline float AvoidEdge::percent_along() const {
  // @@protoc_insertion_point(field_get:valhalla.AvoidEdge.percent_along)
  return _internal_percent_along();
}
inline void AvoidEdge::set_percent_along(float value) {
  _internal_set_percent_along(value);
  // @@protoc_insertion_point(field_set:valhalla.AvoidEdge.percent_along)
}
inline float AvoidEdge::_internal_percent_along() const {
  if (has_percent_along_case() == kPercentAlong) {
    return _impl_.has_percent_along_.percent_along_;
  }
  return 0;
}
inline void AvoidEdge::_internal_set_percent_along(float value) {
  if (has_percent_along_case() != kPercentAlong) {
    clear_has_percent_along();
    set_has_percent_along();
  }
  _impl_.has_percent_along_.percent_along_ = value;
}

inline bool AvoidEdge::has_has_id() const {
  return has_id_case() != HAS_ID_NOT_SET;
}
inline void AvoidEdge::clear_has_has_id() {
  _impl_._oneof_case_[0] = HAS_ID_NOT_SET;
}
inline bool AvoidEdge::has_has_percent_along() const {
  return has_percent_along_case() != HAS_PERCENT_ALONG_NOT_SET;
}
inline void AvoidEdge::clear_has_has_percent_along() {
  _impl_._oneof_case_[1] = HAS_PERCENT_ALONG_NOT_SET;
}
inline AvoidEdge::HasIdCase AvoidEdge::has_id_case() const {
  return AvoidEdge::HasIdCase(_impl_._oneof_case_[0]);
}
inline AvoidEdge::HasPercentAlongCase AvoidEdge::has_percent_along_case() const {
  return AvoidEdge::HasPercentAlongCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// Costing_Options

// float maneuver_penalty = 1;
inline bool Costing_Options::has_maneuver_penalty() const {
  return has_maneuver_penalty_case() == kManeuverPenalty;
}
inline void Costing_Options::set_has_maneuver_penalty() {
  _impl_._oneof_case_[0] = kManeuverPenalty;
}
inline void Costing_Options::clear_maneuver_penalty() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_maneuver_penalty_case() == kManeuverPenalty) {
    _impl_.has_maneuver_penalty_.maneuver_penalty_ = 0;
    clear_has_has_maneuver_penalty();
  }
}
inline float Costing_Options::maneuver_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.maneuver_penalty)
  return _internal_maneuver_penalty();
}
inline void Costing_Options::set_maneuver_penalty(float value) {
  _internal_set_maneuver_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.maneuver_penalty)
}
inline float Costing_Options::_internal_maneuver_penalty() const {
  if (has_maneuver_penalty_case() == kManeuverPenalty) {
    return _impl_.has_maneuver_penalty_.maneuver_penalty_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_maneuver_penalty(float value) {
  if (has_maneuver_penalty_case() != kManeuverPenalty) {
    clear_has_maneuver_penalty();
    set_has_maneuver_penalty();
  }
  _impl_.has_maneuver_penalty_.maneuver_penalty_ = value;
}

// float destination_only_penalty = 2;
inline bool Costing_Options::has_destination_only_penalty() const {
  return has_destination_only_penalty_case() == kDestinationOnlyPenalty;
}
inline void Costing_Options::set_has_destination_only_penalty() {
  _impl_._oneof_case_[1] = kDestinationOnlyPenalty;
}
inline void Costing_Options::clear_destination_only_penalty() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_destination_only_penalty_case() == kDestinationOnlyPenalty) {
    _impl_.has_destination_only_penalty_.destination_only_penalty_ = 0;
    clear_has_has_destination_only_penalty();
  }
}
inline float Costing_Options::destination_only_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.destination_only_penalty)
  return _internal_destination_only_penalty();
}
inline void Costing_Options::set_destination_only_penalty(float value) {
  _internal_set_destination_only_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.destination_only_penalty)
}
inline float Costing_Options::_internal_destination_only_penalty() const {
  if (has_destination_only_penalty_case() == kDestinationOnlyPenalty) {
    return _impl_.has_destination_only_penalty_.destination_only_penalty_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_destination_only_penalty(float value) {
  if (has_destination_only_penalty_case() != kDestinationOnlyPenalty) {
    clear_has_destination_only_penalty();
    set_has_destination_only_penalty();
  }
  _impl_.has_destination_only_penalty_.destination_only_penalty_ = value;
}

// float gate_cost = 3;
inline bool Costing_Options::has_gate_cost() const {
  return has_gate_cost_case() == kGateCost;
}
inline void Costing_Options::set_has_gate_cost() {
  _impl_._oneof_case_[2] = kGateCost;
}
inline void Costing_Options::clear_gate_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_gate_cost_case() == kGateCost) {
    _impl_.has_gate_cost_.gate_cost_ = 0;
    clear_has_has_gate_cost();
  }
}
inline float Costing_Options::gate_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.gate_cost)
  return _internal_gate_cost();
}
inline void Costing_Options::set_gate_cost(float value) {
  _internal_set_gate_cost(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.gate_cost)
}
inline float Costing_Options::_internal_gate_cost() const {
  if (has_gate_cost_case() == kGateCost) {
    return _impl_.has_gate_cost_.gate_cost_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_gate_cost(float value) {
  if (has_gate_cost_case() != kGateCost) {
    clear_has_gate_cost();
    set_has_gate_cost();
  }
  _impl_.has_gate_cost_.gate_cost_ = value;
}

// float gate_penalty = 4;
inline bool Costing_Options::has_gate_penalty() const {
  return has_gate_penalty_case() == kGatePenalty;
}
inline void Costing_Options::set_has_gate_penalty() {
  _impl_._oneof_case_[3] = kGatePenalty;
}
inline void Costing_Options::clear_gate_penalty() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_gate_penalty_case() == kGatePenalty) {
    _impl_.has_gate_penalty_.gate_penalty_ = 0;
    clear_has_has_gate_penalty();
  }
}
inline float Costing_Options::gate_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.gate_penalty)
  return _internal_gate_penalty();
}
inline void Costing_Options::set_gate_penalty(float value) {
  _internal_set_gate_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.gate_penalty)
}
inline float Costing_Options::_internal_gate_penalty() const {
  if (has_gate_penalty_case() == kGatePenalty) {
    return _impl_.has_gate_penalty_.gate_penalty_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_gate_penalty(float value) {
  if (has_gate_penalty_case() != kGatePenalty) {
    clear_has_gate_penalty();
    set_has_gate_penalty();
  }
  _impl_.has_gate_penalty_.gate_penalty_ = value;
}

// float toll_booth_cost = 5;
inline bool Costing_Options::has_toll_booth_cost() const {
  return has_toll_booth_cost_case() == kTollBoothCost;
}
inline void Costing_Options::set_has_toll_booth_cost() {
  _impl_._oneof_case_[4] = kTollBoothCost;
}
inline void Costing_Options::clear_toll_booth_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_toll_booth_cost_case() == kTollBoothCost) {
    _impl_.has_toll_booth_cost_.toll_booth_cost_ = 0;
    clear_has_has_toll_booth_cost();
  }
}
inline float Costing_Options::toll_booth_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.toll_booth_cost)
  return _internal_toll_booth_cost();
}
inline void Costing_Options::set_toll_booth_cost(float value) {
  _internal_set_toll_booth_cost(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.toll_booth_cost)
}
inline float Costing_Options::_internal_toll_booth_cost() const {
  if (has_toll_booth_cost_case() == kTollBoothCost) {
    return _impl_.has_toll_booth_cost_.toll_booth_cost_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_toll_booth_cost(float value) {
  if (has_toll_booth_cost_case() != kTollBoothCost) {
    clear_has_toll_booth_cost();
    set_has_toll_booth_cost();
  }
  _impl_.has_toll_booth_cost_.toll_booth_cost_ = value;
}

// float toll_booth_penalty = 6;
inline bool Costing_Options::has_toll_booth_penalty() const {
  return has_toll_booth_penalty_case() == kTollBoothPenalty;
}
inline void Costing_Options::set_has_toll_booth_penalty() {
  _impl_._oneof_case_[5] = kTollBoothPenalty;
}
inline void Costing_Options::clear_toll_booth_penalty() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_toll_booth_penalty_case() == kTollBoothPenalty) {
    _impl_.has_toll_booth_penalty_.toll_booth_penalty_ = 0;
    clear_has_has_toll_booth_penalty();
  }
}
inline float Costing_Options::toll_booth_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.toll_booth_penalty)
  return _internal_toll_booth_penalty();
}
inline void Costing_Options::set_toll_booth_penalty(float value) {
  _internal_set_toll_booth_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.toll_booth_penalty)
}
inline float Costing_Options::_internal_toll_booth_penalty() const {
  if (has_toll_booth_penalty_case() == kTollBoothPenalty) {
    return _impl_.has_toll_booth_penalty_.toll_booth_penalty_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_toll_booth_penalty(float value) {
  if (has_toll_booth_penalty_case() != kTollBoothPenalty) {
    clear_has_toll_booth_penalty();
    set_has_toll_booth_penalty();
  }
  _impl_.has_toll_booth_penalty_.toll_booth_penalty_ = value;
}

// float alley_penalty = 7;
inline bool Costing_Options::has_alley_penalty() const {
  return has_alley_penalty_case() == kAlleyPenalty;
}
inline void Costing_Options::set_has_alley_penalty() {
  _impl_._oneof_case_[6] = kAlleyPenalty;
}
inline void Costing_Options::clear_alley_penalty() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_alley_penalty_case() == kAlleyPenalty) {
    _impl_.has_alley_penalty_.alley_penalty_ = 0;
    clear_has_has_alley_penalty();
  }
}
inline float Costing_Options::alley_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.alley_penalty)
  return _internal_alley_penalty();
}
inline void Costing_Options::set_alley_penalty(float value) {
  _internal_set_alley_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.alley_penalty)
}
inline float Costing_Options::_internal_alley_penalty() const {
  if (has_alley_penalty_case() == kAlleyPenalty) {
    return _impl_.has_alley_penalty_.alley_penalty_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_alley_penalty(float value) {
  if (has_alley_penalty_case() != kAlleyPenalty) {
    clear_has_alley_penalty();
    set_has_alley_penalty();
  }
  _impl_.has_alley_penalty_.alley_penalty_ = value;
}

// float country_crossing_cost = 8;
inline bool Costing_Options::has_country_crossing_cost() const {
  return has_country_crossing_cost_case() == kCountryCrossingCost;
}
inline void Costing_Options::set_has_country_crossing_cost() {
  _impl_._oneof_case_[7] = kCountryCrossingCost;
}
inline void Costing_Options::clear_country_crossing_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_country_crossing_cost_case() == kCountryCrossingCost) {
    _impl_.has_country_crossing_cost_.country_crossing_cost_ = 0;
    clear_has_has_country_crossing_cost();
  }
}
inline float Costing_Options::country_crossing_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.country_crossing_cost)
  return _internal_country_crossing_cost();
}
inline void Costing_Options::set_country_crossing_cost(float value) {
  _internal_set_country_crossing_cost(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.country_crossing_cost)
}
inline float Costing_Options::_internal_country_crossing_cost() const {
  if (has_country_crossing_cost_case() == kCountryCrossingCost) {
    return _impl_.has_country_crossing_cost_.country_crossing_cost_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_country_crossing_cost(float value) {
  if (has_country_crossing_cost_case() != kCountryCrossingCost) {
    clear_has_country_crossing_cost();
    set_has_country_crossing_cost();
  }
  _impl_.has_country_crossing_cost_.country_crossing_cost_ = value;
}

// float country_crossing_penalty = 9;
inline bool Costing_Options::has_country_crossing_penalty() const {
  return has_country_crossing_penalty_case() == kCountryCrossingPenalty;
}
inline void Costing_Options::set_has_country_crossing_penalty() {
  _impl_._oneof_case_[8] = kCountryCrossingPenalty;
}
inline void Costing_Options::clear_country_crossing_penalty() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_country_crossing_penalty_case() == kCountryCrossingPenalty) {
    _impl_.has_country_crossing_penalty_.country_crossing_penalty_ = 0;
    clear_has_has_country_crossing_penalty();
  }
}
inline float Costing_Options::country_crossing_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.country_crossing_penalty)
  return _internal_country_crossing_penalty();
}
inline void Costing_Options::set_country_crossing_penalty(float value) {
  _internal_set_country_crossing_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.country_crossing_penalty)
}
inline float Costing_Options::_internal_country_crossing_penalty() const {
  if (has_country_crossing_penalty_case() == kCountryCrossingPenalty) {
    return _impl_.has_country_crossing_penalty_.country_crossing_penalty_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_country_crossing_penalty(float value) {
  if (has_country_crossing_penalty_case() != kCountryCrossingPenalty) {
    clear_has_country_crossing_penalty();
    set_has_country_crossing_penalty();
  }
  _impl_.has_country_crossing_penalty_.country_crossing_penalty_ = value;
}

// float ferry_cost = 10;
inline bool Costing_Options::has_ferry_cost() const {
  return has_ferry_cost_case() == kFerryCost;
}
inline void Costing_Options::set_has_ferry_cost() {
  _impl_._oneof_case_[9] = kFerryCost;
}
inline void Costing_Options::clear_ferry_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_ferry_cost_case() == kFerryCost) {
    _impl_.has_ferry_cost_.ferry_cost_ = 0;
    clear_has_has_ferry_cost();
  }
}
inline float Costing_Options::ferry_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.ferry_cost)
  return _internal_ferry_cost();
}
inline void Costing_Options::set_ferry_cost(float value) {
  _internal_set_ferry_cost(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.ferry_cost)
}
inline float Costing_Options::_internal_ferry_cost() const {
  if (has_ferry_cost_case() == kFerryCost) {
    return _impl_.has_ferry_cost_.ferry_cost_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_ferry_cost(float value) {
  if (has_ferry_cost_case() != kFerryCost) {
    clear_has_ferry_cost();
    set_has_ferry_cost();
  }
  _impl_.has_ferry_cost_.ferry_cost_ = value;
}

// float avoid_bad_surfaces = 11;
inline bool Costing_Options::has_avoid_bad_surfaces() const {
  return has_avoid_bad_surfaces_case() == kAvoidBadSurfaces;
}
inline void Costing_Options::set_has_avoid_bad_surfaces() {
  _impl_._oneof_case_[10] = kAvoidBadSurfaces;
}
inline void Costing_Options::clear_avoid_bad_surfaces() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_avoid_bad_surfaces_case() == kAvoidBadSurfaces) {
    _impl_.has_avoid_bad_surfaces_.avoid_bad_surfaces_ = 0;
    clear_has_has_avoid_bad_surfaces();
  }
}
inline float Costing_Options::avoid_bad_surfaces() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.avoid_bad_surfaces)
  return _internal_avoid_bad_surfaces();
}
inline void Costing_Options::set_avoid_bad_surfaces(float value) {
  _internal_set_avoid_bad_surfaces(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.avoid_bad_surfaces)
}
inline float Costing_Options::_internal_avoid_bad_surfaces() const {
  if (has_avoid_bad_surfaces_case() == kAvoidBadSurfaces) {
    return _impl_.has_avoid_bad_surfaces_.avoid_bad_surfaces_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_avoid_bad_surfaces(float value) {
  if (has_avoid_bad_surfaces_case() != kAvoidBadSurfaces) {
    clear_has_avoid_bad_surfaces();
    set_has_avoid_bad_surfaces();
  }
  _impl_.has_avoid_bad_surfaces_.avoid_bad_surfaces_ = value;
}

// float use_ferry = 12;
inline bool Costing_Options::has_use_ferry() const {
  return has_use_ferry_case() == kUseFerry;
}
inline void Costing_Options::set_has_use_ferry() {
  _impl_._oneof_case_[11] = kUseFerry;
}
inline void Costing_Options::clear_use_ferry() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_use_ferry_case() == kUseFerry) {
    _impl_.has_use_ferry_.use_ferry_ = 0;
    clear_has_has_use_ferry();
  }
}
inline float Costing_Options::use_ferry() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.use_ferry)
  return _internal_use_ferry();
}
inline void Costing_Options::set_use_ferry(float value) {
  _internal_set_use_ferry(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.use_ferry)
}
inline float Costing_Options::_internal_use_ferry() const {
  if (has_use_ferry_case() == kUseFerry) {
    return _impl_.has_use_ferry_.use_ferry_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_use_ferry(float value) {
  if (has_use_ferry_case() != kUseFerry) {
    clear_has_use_ferry();
    set_has_use_ferry();
  }
  _impl_.has_use_ferry_.use_ferry_ = value;
}

// float use_highways = 13;
inline bool Costing_Options::has_use_highways() const {
  return has_use_highways_case() == kUseHighways;
}
inline void Costing_Options::set_has_use_highways() {
  _impl_._oneof_case_[12] = kUseHighways;
}
inline void Costing_Options::clear_use_highways() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_use_highways_case() == kUseHighways) {
    _impl_.has_use_highways_.use_highways_ = 0;
    clear_has_has_use_highways();
  }
}
inline float Costing_Options::use_highways() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.use_highways)
  return _internal_use_highways();
}
inline void Costing_Options::set_use_highways(float value) {
  _internal_set_use_highways(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.use_highways)
}
inline float Costing_Options::_internal_use_highways() const {
  if (has_use_highways_case() == kUseHighways) {
    return _impl_.has_use_highways_.use_highways_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_use_highways(float value) {
  if (has_use_highways_case() != kUseHighways) {
    clear_has_use_highways();
    set_has_use_highways();
  }
  _impl_.has_use_highways_.use_highways_ = value;
}

// float use_tolls = 14;
inline bool Costing_Options::has_use_tolls() const {
  return has_use_tolls_case() == kUseTolls;
}
inline void Costing_Options::set_has_use_tolls() {
  _impl_._oneof_case_[13] = kUseTolls;
}
inline void Costing_Options::clear_use_tolls() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_use_tolls_case() == kUseTolls) {
    _impl_.has_use_tolls_.use_tolls_ = 0;
    clear_has_has_use_tolls();
  }
}
inline float Costing_Options::use_tolls() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.use_tolls)
  return _internal_use_tolls();
}
inline void Costing_Options::set_use_tolls(float value) {
  _internal_set_use_tolls(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.use_tolls)
}
inline float Costing_Options::_internal_use_tolls() const {
  if (has_use_tolls_case() == kUseTolls) {
    return _impl_.has_use_tolls_.use_tolls_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_use_tolls(float value) {
  if (has_use_tolls_case() != kUseTolls) {
    clear_has_use_tolls();
    set_has_use_tolls();
  }
  _impl_.has_use_tolls_.use_tolls_ = value;
}

// float use_roads = 15;
inline bool Costing_Options::has_use_roads() const {
  return has_use_roads_case() == kUseRoads;
}
inline void Costing_Options::set_has_use_roads() {
  _impl_._oneof_case_[14] = kUseRoads;
}
inline void Costing_Options::clear_use_roads() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_use_roads_case() == kUseRoads) {
    _impl_.has_use_roads_.use_roads_ = 0;
    clear_has_has_use_roads();
  }
}
inline float Costing_Options::use_roads() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.use_roads)
  return _internal_use_roads();
}
inline void Costing_Options::set_use_roads(float value) {
  _internal_set_use_roads(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.use_roads)
}
inline float Costing_Options::_internal_use_roads() const {
  if (has_use_roads_case() == kUseRoads) {
    return _impl_.has_use_roads_.use_roads_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_use_roads(float value) {
  if (has_use_roads_case() != kUseRoads) {
    clear_has_use_roads();
    set_has_use_roads();
  }
  _impl_.has_use_roads_.use_roads_ = value;
}

// uint32 max_distance = 16;
inline bool Costing_Options::has_max_distance() const {
  return has_max_distance_case() == kMaxDistance;
}
inline void Costing_Options::set_has_max_distance() {
  _impl_._oneof_case_[15] = kMaxDistance;
}
inline void Costing_Options::clear_max_distance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_max_distance_case() == kMaxDistance) {
    _impl_.has_max_distance_.max_distance_ = 0u;
    clear_has_has_max_distance();
  }
}
inline ::uint32_t Costing_Options::max_distance() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.max_distance)
  return _internal_max_distance();
}
inline void Costing_Options::set_max_distance(::uint32_t value) {
  _internal_set_max_distance(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.max_distance)
}
inline ::uint32_t Costing_Options::_internal_max_distance() const {
  if (has_max_distance_case() == kMaxDistance) {
    return _impl_.has_max_distance_.max_distance_;
  }
  return 0u;
}
inline void Costing_Options::_internal_set_max_distance(::uint32_t value) {
  if (has_max_distance_case() != kMaxDistance) {
    clear_has_max_distance();
    set_has_max_distance();
  }
  _impl_.has_max_distance_.max_distance_ = value;
}

// float walking_speed = 17;
inline bool Costing_Options::has_walking_speed() const {
  return has_walking_speed_case() == kWalkingSpeed;
}
inline void Costing_Options::set_has_walking_speed() {
  _impl_._oneof_case_[16] = kWalkingSpeed;
}
inline void Costing_Options::clear_walking_speed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_walking_speed_case() == kWalkingSpeed) {
    _impl_.has_walking_speed_.walking_speed_ = 0;
    clear_has_has_walking_speed();
  }
}
inline float Costing_Options::walking_speed() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.walking_speed)
  return _internal_walking_speed();
}
inline void Costing_Options::set_walking_speed(float value) {
  _internal_set_walking_speed(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.walking_speed)
}
inline float Costing_Options::_internal_walking_speed() const {
  if (has_walking_speed_case() == kWalkingSpeed) {
    return _impl_.has_walking_speed_.walking_speed_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_walking_speed(float value) {
  if (has_walking_speed_case() != kWalkingSpeed) {
    clear_has_walking_speed();
    set_has_walking_speed();
  }
  _impl_.has_walking_speed_.walking_speed_ = value;
}

// float step_penalty = 18;
inline bool Costing_Options::has_step_penalty() const {
  return has_step_penalty_case() == kStepPenalty;
}
inline void Costing_Options::set_has_step_penalty() {
  _impl_._oneof_case_[17] = kStepPenalty;
}
inline void Costing_Options::clear_step_penalty() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_step_penalty_case() == kStepPenalty) {
    _impl_.has_step_penalty_.step_penalty_ = 0;
    clear_has_has_step_penalty();
  }
}
inline float Costing_Options::step_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.step_penalty)
  return _internal_step_penalty();
}
inline void Costing_Options::set_step_penalty(float value) {
  _internal_set_step_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.step_penalty)
}
inline float Costing_Options::_internal_step_penalty() const {
  if (has_step_penalty_case() == kStepPenalty) {
    return _impl_.has_step_penalty_.step_penalty_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_step_penalty(float value) {
  if (has_step_penalty_case() != kStepPenalty) {
    clear_has_step_penalty();
    set_has_step_penalty();
  }
  _impl_.has_step_penalty_.step_penalty_ = value;
}

// uint32 max_grade = 19;
inline bool Costing_Options::has_max_grade() const {
  return has_max_grade_case() == kMaxGrade;
}
inline void Costing_Options::set_has_max_grade() {
  _impl_._oneof_case_[18] = kMaxGrade;
}
inline void Costing_Options::clear_max_grade() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_max_grade_case() == kMaxGrade) {
    _impl_.has_max_grade_.max_grade_ = 0u;
    clear_has_has_max_grade();
  }
}
inline ::uint32_t Costing_Options::max_grade() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.max_grade)
  return _internal_max_grade();
}
inline void Costing_Options::set_max_grade(::uint32_t value) {
  _internal_set_max_grade(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.max_grade)
}
inline ::uint32_t Costing_Options::_internal_max_grade() const {
  if (has_max_grade_case() == kMaxGrade) {
    return _impl_.has_max_grade_.max_grade_;
  }
  return 0u;
}
inline void Costing_Options::_internal_set_max_grade(::uint32_t value) {
  if (has_max_grade_case() != kMaxGrade) {
    clear_has_max_grade();
    set_has_max_grade();
  }
  _impl_.has_max_grade_.max_grade_ = value;
}

// uint32 max_hiking_difficulty = 20;
inline bool Costing_Options::has_max_hiking_difficulty() const {
  return has_max_hiking_difficulty_case() == kMaxHikingDifficulty;
}
inline void Costing_Options::set_has_max_hiking_difficulty() {
  _impl_._oneof_case_[19] = kMaxHikingDifficulty;
}
inline void Costing_Options::clear_max_hiking_difficulty() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_max_hiking_difficulty_case() == kMaxHikingDifficulty) {
    _impl_.has_max_hiking_difficulty_.max_hiking_difficulty_ = 0u;
    clear_has_has_max_hiking_difficulty();
  }
}
inline ::uint32_t Costing_Options::max_hiking_difficulty() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.max_hiking_difficulty)
  return _internal_max_hiking_difficulty();
}
inline void Costing_Options::set_max_hiking_difficulty(::uint32_t value) {
  _internal_set_max_hiking_difficulty(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.max_hiking_difficulty)
}
inline ::uint32_t Costing_Options::_internal_max_hiking_difficulty() const {
  if (has_max_hiking_difficulty_case() == kMaxHikingDifficulty) {
    return _impl_.has_max_hiking_difficulty_.max_hiking_difficulty_;
  }
  return 0u;
}
inline void Costing_Options::_internal_set_max_hiking_difficulty(::uint32_t value) {
  if (has_max_hiking_difficulty_case() != kMaxHikingDifficulty) {
    clear_has_max_hiking_difficulty();
    set_has_max_hiking_difficulty();
  }
  _impl_.has_max_hiking_difficulty_.max_hiking_difficulty_ = value;
}

// float mode_factor = 21;
inline bool Costing_Options::has_mode_factor() const {
  return has_mode_factor_case() == kModeFactor;
}
inline void Costing_Options::set_has_mode_factor() {
  _impl_._oneof_case_[20] = kModeFactor;
}
inline void Costing_Options::clear_mode_factor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_mode_factor_case() == kModeFactor) {
    _impl_.has_mode_factor_.mode_factor_ = 0;
    clear_has_has_mode_factor();
  }
}
inline float Costing_Options::mode_factor() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.mode_factor)
  return _internal_mode_factor();
}
inline void Costing_Options::set_mode_factor(float value) {
  _internal_set_mode_factor(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.mode_factor)
}
inline float Costing_Options::_internal_mode_factor() const {
  if (has_mode_factor_case() == kModeFactor) {
    return _impl_.has_mode_factor_.mode_factor_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_mode_factor(float value) {
  if (has_mode_factor_case() != kModeFactor) {
    clear_has_mode_factor();
    set_has_mode_factor();
  }
  _impl_.has_mode_factor_.mode_factor_ = value;
}

// float walkway_factor = 22;
inline bool Costing_Options::has_walkway_factor() const {
  return has_walkway_factor_case() == kWalkwayFactor;
}
inline void Costing_Options::set_has_walkway_factor() {
  _impl_._oneof_case_[21] = kWalkwayFactor;
}
inline void Costing_Options::clear_walkway_factor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_walkway_factor_case() == kWalkwayFactor) {
    _impl_.has_walkway_factor_.walkway_factor_ = 0;
    clear_has_has_walkway_factor();
  }
}
inline float Costing_Options::walkway_factor() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.walkway_factor)
  return _internal_walkway_factor();
}
inline void Costing_Options::set_walkway_factor(float value) {
  _internal_set_walkway_factor(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.walkway_factor)
}
inline float Costing_Options::_internal_walkway_factor() const {
  if (has_walkway_factor_case() == kWalkwayFactor) {
    return _impl_.has_walkway_factor_.walkway_factor_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_walkway_factor(float value) {
  if (has_walkway_factor_case() != kWalkwayFactor) {
    clear_has_walkway_factor();
    set_has_walkway_factor();
  }
  _impl_.has_walkway_factor_.walkway_factor_ = value;
}

// float sidewalk_factor = 23;
inline bool Costing_Options::has_sidewalk_factor() const {
  return has_sidewalk_factor_case() == kSidewalkFactor;
}
inline void Costing_Options::set_has_sidewalk_factor() {
  _impl_._oneof_case_[22] = kSidewalkFactor;
}
inline void Costing_Options::clear_sidewalk_factor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_sidewalk_factor_case() == kSidewalkFactor) {
    _impl_.has_sidewalk_factor_.sidewalk_factor_ = 0;
    clear_has_has_sidewalk_factor();
  }
}
inline float Costing_Options::sidewalk_factor() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.sidewalk_factor)
  return _internal_sidewalk_factor();
}
inline void Costing_Options::set_sidewalk_factor(float value) {
  _internal_set_sidewalk_factor(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.sidewalk_factor)
}
inline float Costing_Options::_internal_sidewalk_factor() const {
  if (has_sidewalk_factor_case() == kSidewalkFactor) {
    return _impl_.has_sidewalk_factor_.sidewalk_factor_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_sidewalk_factor(float value) {
  if (has_sidewalk_factor_case() != kSidewalkFactor) {
    clear_has_sidewalk_factor();
    set_has_sidewalk_factor();
  }
  _impl_.has_sidewalk_factor_.sidewalk_factor_ = value;
}

// float alley_factor = 24;
inline bool Costing_Options::has_alley_factor() const {
  return has_alley_factor_case() == kAlleyFactor;
}
inline void Costing_Options::set_has_alley_factor() {
  _impl_._oneof_case_[23] = kAlleyFactor;
}
inline void Costing_Options::clear_alley_factor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_alley_factor_case() == kAlleyFactor) {
    _impl_.has_alley_factor_.alley_factor_ = 0;
    clear_has_has_alley_factor();
  }
}
inline float Costing_Options::alley_factor() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.alley_factor)
  return _internal_alley_factor();
}
inline void Costing_Options::set_alley_factor(float value) {
  _internal_set_alley_factor(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.alley_factor)
}
inline float Costing_Options::_internal_alley_factor() const {
  if (has_alley_factor_case() == kAlleyFactor) {
    return _impl_.has_alley_factor_.alley_factor_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_alley_factor(float value) {
  if (has_alley_factor_case() != kAlleyFactor) {
    clear_has_alley_factor();
    set_has_alley_factor();
  }
  _impl_.has_alley_factor_.alley_factor_ = value;
}

// float driveway_factor = 25;
inline bool Costing_Options::has_driveway_factor() const {
  return has_driveway_factor_case() == kDrivewayFactor;
}
inline void Costing_Options::set_has_driveway_factor() {
  _impl_._oneof_case_[24] = kDrivewayFactor;
}
inline void Costing_Options::clear_driveway_factor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_driveway_factor_case() == kDrivewayFactor) {
    _impl_.has_driveway_factor_.driveway_factor_ = 0;
    clear_has_has_driveway_factor();
  }
}
inline float Costing_Options::driveway_factor() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.driveway_factor)
  return _internal_driveway_factor();
}
inline void Costing_Options::set_driveway_factor(float value) {
  _internal_set_driveway_factor(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.driveway_factor)
}
inline float Costing_Options::_internal_driveway_factor() const {
  if (has_driveway_factor_case() == kDrivewayFactor) {
    return _impl_.has_driveway_factor_.driveway_factor_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_driveway_factor(float value) {
  if (has_driveway_factor_case() != kDrivewayFactor) {
    clear_has_driveway_factor();
    set_has_driveway_factor();
  }
  _impl_.has_driveway_factor_.driveway_factor_ = value;
}

// float driveway_penalty = 26;
inline bool Costing_Options::has_driveway_penalty() const {
  return has_driveway_penalty_case() == kDrivewayPenalty;
}
inline void Costing_Options::set_has_driveway_penalty() {
  _impl_._oneof_case_[25] = kDrivewayPenalty;
}
inline void Costing_Options::clear_driveway_penalty() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_driveway_penalty_case() == kDrivewayPenalty) {
    _impl_.has_driveway_penalty_.driveway_penalty_ = 0;
    clear_has_has_driveway_penalty();
  }
}
inline float Costing_Options::driveway_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.driveway_penalty)
  return _internal_driveway_penalty();
}
inline void Costing_Options::set_driveway_penalty(float value) {
  _internal_set_driveway_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.driveway_penalty)
}
inline float Costing_Options::_internal_driveway_penalty() const {
  if (has_driveway_penalty_case() == kDrivewayPenalty) {
    return _impl_.has_driveway_penalty_.driveway_penalty_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_driveway_penalty(float value) {
  if (has_driveway_penalty_case() != kDrivewayPenalty) {
    clear_has_driveway_penalty();
    set_has_driveway_penalty();
  }
  _impl_.has_driveway_penalty_.driveway_penalty_ = value;
}

// uint32 transit_start_end_max_distance = 27;
inline bool Costing_Options::has_transit_start_end_max_distance() const {
  return has_transit_start_end_max_distance_case() == kTransitStartEndMaxDistance;
}
inline void Costing_Options::set_has_transit_start_end_max_distance() {
  _impl_._oneof_case_[26] = kTransitStartEndMaxDistance;
}
inline void Costing_Options::clear_transit_start_end_max_distance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_transit_start_end_max_distance_case() == kTransitStartEndMaxDistance) {
    _impl_.has_transit_start_end_max_distance_.transit_start_end_max_distance_ = 0u;
    clear_has_has_transit_start_end_max_distance();
  }
}
inline ::uint32_t Costing_Options::transit_start_end_max_distance() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.transit_start_end_max_distance)
  return _internal_transit_start_end_max_distance();
}
inline void Costing_Options::set_transit_start_end_max_distance(::uint32_t value) {
  _internal_set_transit_start_end_max_distance(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.transit_start_end_max_distance)
}
inline ::uint32_t Costing_Options::_internal_transit_start_end_max_distance() const {
  if (has_transit_start_end_max_distance_case() == kTransitStartEndMaxDistance) {
    return _impl_.has_transit_start_end_max_distance_.transit_start_end_max_distance_;
  }
  return 0u;
}
inline void Costing_Options::_internal_set_transit_start_end_max_distance(::uint32_t value) {
  if (has_transit_start_end_max_distance_case() != kTransitStartEndMaxDistance) {
    clear_has_transit_start_end_max_distance();
    set_has_transit_start_end_max_distance();
  }
  _impl_.has_transit_start_end_max_distance_.transit_start_end_max_distance_ = value;
}

// uint32 transit_transfer_max_distance = 28;
inline bool Costing_Options::has_transit_transfer_max_distance() const {
  return has_transit_transfer_max_distance_case() == kTransitTransferMaxDistance;
}
inline void Costing_Options::set_has_transit_transfer_max_distance() {
  _impl_._oneof_case_[27] = kTransitTransferMaxDistance;
}
inline void Costing_Options::clear_transit_transfer_max_distance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_transit_transfer_max_distance_case() == kTransitTransferMaxDistance) {
    _impl_.has_transit_transfer_max_distance_.transit_transfer_max_distance_ = 0u;
    clear_has_has_transit_transfer_max_distance();
  }
}
inline ::uint32_t Costing_Options::transit_transfer_max_distance() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.transit_transfer_max_distance)
  return _internal_transit_transfer_max_distance();
}
inline void Costing_Options::set_transit_transfer_max_distance(::uint32_t value) {
  _internal_set_transit_transfer_max_distance(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.transit_transfer_max_distance)
}
inline ::uint32_t Costing_Options::_internal_transit_transfer_max_distance() const {
  if (has_transit_transfer_max_distance_case() == kTransitTransferMaxDistance) {
    return _impl_.has_transit_transfer_max_distance_.transit_transfer_max_distance_;
  }
  return 0u;
}
inline void Costing_Options::_internal_set_transit_transfer_max_distance(::uint32_t value) {
  if (has_transit_transfer_max_distance_case() != kTransitTransferMaxDistance) {
    clear_has_transit_transfer_max_distance();
    set_has_transit_transfer_max_distance();
  }
  _impl_.has_transit_transfer_max_distance_.transit_transfer_max_distance_ = value;
}

// string transport_type = 29;
inline bool Costing_Options::has_transport_type() const {
  return has_transport_type_case() == kTransportType;
}
inline void Costing_Options::set_has_transport_type() {
  _impl_._oneof_case_[28] = kTransportType;
}
inline void Costing_Options::clear_transport_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_transport_type_case() == kTransportType) {
    _impl_.has_transport_type_.transport_type_.Destroy();
    clear_has_has_transport_type();
  }
}
inline const std::string& Costing_Options::transport_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.transport_type)
  return _internal_transport_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Costing_Options::set_transport_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_transport_type_case() != kTransportType) {
    clear_has_transport_type();

    set_has_transport_type();
    _impl_.has_transport_type_.transport_type_.InitDefault();
  }
  _impl_.has_transport_type_.transport_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.transport_type)
}
inline std::string* Costing_Options::mutable_transport_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_transport_type();
  // @@protoc_insertion_point(field_mutable:valhalla.Costing.Options.transport_type)
  return _s;
}
inline const std::string& Costing_Options::_internal_transport_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (has_transport_type_case() != kTransportType) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.has_transport_type_.transport_type_.Get();
}
inline void Costing_Options::_internal_set_transport_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_transport_type_case() != kTransportType) {
    clear_has_transport_type();

    set_has_transport_type();
    _impl_.has_transport_type_.transport_type_.InitDefault();
  }
  _impl_.has_transport_type_.transport_type_.Set(value, GetArena());
}
inline std::string* Costing_Options::_internal_mutable_transport_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_transport_type_case() != kTransportType) {
    clear_has_transport_type();

    set_has_transport_type();
    _impl_.has_transport_type_.transport_type_.InitDefault();
  }
  return _impl_.has_transport_type_.transport_type_.Mutable( GetArena());
}
inline std::string* Costing_Options::release_transport_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.Costing.Options.transport_type)
  if (has_transport_type_case() != kTransportType) {
    return nullptr;
  }
  clear_has_has_transport_type();
  return _impl_.has_transport_type_.transport_type_.Release();
}
inline void Costing_Options::set_allocated_transport_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_has_transport_type()) {
    clear_has_transport_type();
  }
  if (value != nullptr) {
    set_has_transport_type();
    _impl_.has_transport_type_.transport_type_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Costing.Options.transport_type)
}

// float top_speed = 30;
inline bool Costing_Options::has_top_speed() const {
  return has_top_speed_case() == kTopSpeed;
}
inline void Costing_Options::set_has_top_speed() {
  _impl_._oneof_case_[29] = kTopSpeed;
}
inline void Costing_Options::clear_top_speed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_top_speed_case() == kTopSpeed) {
    _impl_.has_top_speed_.top_speed_ = 0;
    clear_has_has_top_speed();
  }
}
inline float Costing_Options::top_speed() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.top_speed)
  return _internal_top_speed();
}
inline void Costing_Options::set_top_speed(float value) {
  _internal_set_top_speed(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.top_speed)
}
inline float Costing_Options::_internal_top_speed() const {
  if (has_top_speed_case() == kTopSpeed) {
    return _impl_.has_top_speed_.top_speed_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_top_speed(float value) {
  if (has_top_speed_case() != kTopSpeed) {
    clear_has_top_speed();
    set_has_top_speed();
  }
  _impl_.has_top_speed_.top_speed_ = value;
}

// float use_hills = 31;
inline bool Costing_Options::has_use_hills() const {
  return has_use_hills_case() == kUseHills;
}
inline void Costing_Options::set_has_use_hills() {
  _impl_._oneof_case_[30] = kUseHills;
}
inline void Costing_Options::clear_use_hills() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_use_hills_case() == kUseHills) {
    _impl_.has_use_hills_.use_hills_ = 0;
    clear_has_has_use_hills();
  }
}
inline float Costing_Options::use_hills() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.use_hills)
  return _internal_use_hills();
}
inline void Costing_Options::set_use_hills(float value) {
  _internal_set_use_hills(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.use_hills)
}
inline float Costing_Options::_internal_use_hills() const {
  if (has_use_hills_case() == kUseHills) {
    return _impl_.has_use_hills_.use_hills_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_use_hills(float value) {
  if (has_use_hills_case() != kUseHills) {
    clear_has_use_hills();
    set_has_use_hills();
  }
  _impl_.has_use_hills_.use_hills_ = value;
}

// float use_primary = 32;
inline bool Costing_Options::has_use_primary() const {
  return has_use_primary_case() == kUsePrimary;
}
inline void Costing_Options::set_has_use_primary() {
  _impl_._oneof_case_[31] = kUsePrimary;
}
inline void Costing_Options::clear_use_primary() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_use_primary_case() == kUsePrimary) {
    _impl_.has_use_primary_.use_primary_ = 0;
    clear_has_has_use_primary();
  }
}
inline float Costing_Options::use_primary() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.use_primary)
  return _internal_use_primary();
}
inline void Costing_Options::set_use_primary(float value) {
  _internal_set_use_primary(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.use_primary)
}
inline float Costing_Options::_internal_use_primary() const {
  if (has_use_primary_case() == kUsePrimary) {
    return _impl_.has_use_primary_.use_primary_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_use_primary(float value) {
  if (has_use_primary_case() != kUsePrimary) {
    clear_has_use_primary();
    set_has_use_primary();
  }
  _impl_.has_use_primary_.use_primary_ = value;
}

// float use_trails = 33;
inline bool Costing_Options::has_use_trails() const {
  return has_use_trails_case() == kUseTrails;
}
inline void Costing_Options::set_has_use_trails() {
  _impl_._oneof_case_[32] = kUseTrails;
}
inline void Costing_Options::clear_use_trails() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_use_trails_case() == kUseTrails) {
    _impl_.has_use_trails_.use_trails_ = 0;
    clear_has_has_use_trails();
  }
}
inline float Costing_Options::use_trails() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.use_trails)
  return _internal_use_trails();
}
inline void Costing_Options::set_use_trails(float value) {
  _internal_set_use_trails(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.use_trails)
}
inline float Costing_Options::_internal_use_trails() const {
  if (has_use_trails_case() == kUseTrails) {
    return _impl_.has_use_trails_.use_trails_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_use_trails(float value) {
  if (has_use_trails_case() != kUseTrails) {
    clear_has_use_trails();
    set_has_use_trails();
  }
  _impl_.has_use_trails_.use_trails_ = value;
}

// float low_class_penalty = 34;
inline bool Costing_Options::has_low_class_penalty() const {
  return has_low_class_penalty_case() == kLowClassPenalty;
}
inline void Costing_Options::set_has_low_class_penalty() {
  _impl_._oneof_case_[33] = kLowClassPenalty;
}
inline void Costing_Options::clear_low_class_penalty() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_low_class_penalty_case() == kLowClassPenalty) {
    _impl_.has_low_class_penalty_.low_class_penalty_ = 0;
    clear_has_has_low_class_penalty();
  }
}
inline float Costing_Options::low_class_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.low_class_penalty)
  return _internal_low_class_penalty();
}
inline void Costing_Options::set_low_class_penalty(float value) {
  _internal_set_low_class_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.low_class_penalty)
}
inline float Costing_Options::_internal_low_class_penalty() const {
  if (has_low_class_penalty_case() == kLowClassPenalty) {
    return _impl_.has_low_class_penalty_.low_class_penalty_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_low_class_penalty(float value) {
  if (has_low_class_penalty_case() != kLowClassPenalty) {
    clear_has_low_class_penalty();
    set_has_low_class_penalty();
  }
  _impl_.has_low_class_penalty_.low_class_penalty_ = value;
}

// bool hazmat = 35;
inline bool Costing_Options::has_hazmat() const {
  return has_hazmat_case() == kHazmat;
}
inline void Costing_Options::set_has_hazmat() {
  _impl_._oneof_case_[34] = kHazmat;
}
inline void Costing_Options::clear_hazmat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_hazmat_case() == kHazmat) {
    _impl_.has_hazmat_.hazmat_ = false;
    clear_has_has_hazmat();
  }
}
inline bool Costing_Options::hazmat() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.hazmat)
  return _internal_hazmat();
}
inline void Costing_Options::set_hazmat(bool value) {
  _internal_set_hazmat(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.hazmat)
}
inline bool Costing_Options::_internal_hazmat() const {
  if (has_hazmat_case() == kHazmat) {
    return _impl_.has_hazmat_.hazmat_;
  }
  return false;
}
inline void Costing_Options::_internal_set_hazmat(bool value) {
  if (has_hazmat_case() != kHazmat) {
    clear_has_hazmat();
    set_has_hazmat();
  }
  _impl_.has_hazmat_.hazmat_ = value;
}

// float weight = 36;
inline bool Costing_Options::has_weight() const {
  return has_weight_case() == kWeight;
}
inline void Costing_Options::set_has_weight() {
  _impl_._oneof_case_[35] = kWeight;
}
inline void Costing_Options::clear_weight() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_weight_case() == kWeight) {
    _impl_.has_weight_.weight_ = 0;
    clear_has_has_weight();
  }
}
inline float Costing_Options::weight() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.weight)
  return _internal_weight();
}
inline void Costing_Options::set_weight(float value) {
  _internal_set_weight(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.weight)
}
inline float Costing_Options::_internal_weight() const {
  if (has_weight_case() == kWeight) {
    return _impl_.has_weight_.weight_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_weight(float value) {
  if (has_weight_case() != kWeight) {
    clear_has_weight();
    set_has_weight();
  }
  _impl_.has_weight_.weight_ = value;
}

// float axle_load = 37;
inline bool Costing_Options::has_axle_load() const {
  return has_axle_load_case() == kAxleLoad;
}
inline void Costing_Options::set_has_axle_load() {
  _impl_._oneof_case_[36] = kAxleLoad;
}
inline void Costing_Options::clear_axle_load() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_axle_load_case() == kAxleLoad) {
    _impl_.has_axle_load_.axle_load_ = 0;
    clear_has_has_axle_load();
  }
}
inline float Costing_Options::axle_load() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.axle_load)
  return _internal_axle_load();
}
inline void Costing_Options::set_axle_load(float value) {
  _internal_set_axle_load(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.axle_load)
}
inline float Costing_Options::_internal_axle_load() const {
  if (has_axle_load_case() == kAxleLoad) {
    return _impl_.has_axle_load_.axle_load_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_axle_load(float value) {
  if (has_axle_load_case() != kAxleLoad) {
    clear_has_axle_load();
    set_has_axle_load();
  }
  _impl_.has_axle_load_.axle_load_ = value;
}

// float height = 38;
inline bool Costing_Options::has_height() const {
  return has_height_case() == kHeight;
}
inline void Costing_Options::set_has_height() {
  _impl_._oneof_case_[37] = kHeight;
}
inline void Costing_Options::clear_height() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_height_case() == kHeight) {
    _impl_.has_height_.height_ = 0;
    clear_has_has_height();
  }
}
inline float Costing_Options::height() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.height)
  return _internal_height();
}
inline void Costing_Options::set_height(float value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.height)
}
inline float Costing_Options::_internal_height() const {
  if (has_height_case() == kHeight) {
    return _impl_.has_height_.height_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_height(float value) {
  if (has_height_case() != kHeight) {
    clear_has_height();
    set_has_height();
  }
  _impl_.has_height_.height_ = value;
}

// float width = 39;
inline bool Costing_Options::has_width() const {
  return has_width_case() == kWidth;
}
inline void Costing_Options::set_has_width() {
  _impl_._oneof_case_[38] = kWidth;
}
inline void Costing_Options::clear_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_width_case() == kWidth) {
    _impl_.has_width_.width_ = 0;
    clear_has_has_width();
  }
}
inline float Costing_Options::width() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.width)
  return _internal_width();
}
inline void Costing_Options::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.width)
}
inline float Costing_Options::_internal_width() const {
  if (has_width_case() == kWidth) {
    return _impl_.has_width_.width_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_width(float value) {
  if (has_width_case() != kWidth) {
    clear_has_width();
    set_has_width();
  }
  _impl_.has_width_.width_ = value;
}

// float length = 40;
inline bool Costing_Options::has_length() const {
  return has_length_case() == kLength;
}
inline void Costing_Options::set_has_length() {
  _impl_._oneof_case_[39] = kLength;
}
inline void Costing_Options::clear_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_length_case() == kLength) {
    _impl_.has_length_.length_ = 0;
    clear_has_has_length();
  }
}
inline float Costing_Options::length() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.length)
  return _internal_length();
}
inline void Costing_Options::set_length(float value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.length)
}
inline float Costing_Options::_internal_length() const {
  if (has_length_case() == kLength) {
    return _impl_.has_length_.length_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_length(float value) {
  if (has_length_case() != kLength) {
    clear_has_length();
    set_has_length();
  }
  _impl_.has_length_.length_ = value;
}

// float cycling_speed = 41;
inline bool Costing_Options::has_cycling_speed() const {
  return has_cycling_speed_case() == kCyclingSpeed;
}
inline void Costing_Options::set_has_cycling_speed() {
  _impl_._oneof_case_[40] = kCyclingSpeed;
}
inline void Costing_Options::clear_cycling_speed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_cycling_speed_case() == kCyclingSpeed) {
    _impl_.has_cycling_speed_.cycling_speed_ = 0;
    clear_has_has_cycling_speed();
  }
}
inline float Costing_Options::cycling_speed() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.cycling_speed)
  return _internal_cycling_speed();
}
inline void Costing_Options::set_cycling_speed(float value) {
  _internal_set_cycling_speed(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.cycling_speed)
}
inline float Costing_Options::_internal_cycling_speed() const {
  if (has_cycling_speed_case() == kCyclingSpeed) {
    return _impl_.has_cycling_speed_.cycling_speed_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_cycling_speed(float value) {
  if (has_cycling_speed_case() != kCyclingSpeed) {
    clear_has_cycling_speed();
    set_has_cycling_speed();
  }
  _impl_.has_cycling_speed_.cycling_speed_ = value;
}

// bool wheelchair = 42;
inline bool Costing_Options::has_wheelchair() const {
  return has_wheelchair_case() == kWheelchair;
}
inline void Costing_Options::set_has_wheelchair() {
  _impl_._oneof_case_[41] = kWheelchair;
}
inline void Costing_Options::clear_wheelchair() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_wheelchair_case() == kWheelchair) {
    _impl_.has_wheelchair_.wheelchair_ = false;
    clear_has_has_wheelchair();
  }
}
inline bool Costing_Options::wheelchair() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.wheelchair)
  return _internal_wheelchair();
}
inline void Costing_Options::set_wheelchair(bool value) {
  _internal_set_wheelchair(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.wheelchair)
}
inline bool Costing_Options::_internal_wheelchair() const {
  if (has_wheelchair_case() == kWheelchair) {
    return _impl_.has_wheelchair_.wheelchair_;
  }
  return false;
}
inline void Costing_Options::_internal_set_wheelchair(bool value) {
  if (has_wheelchair_case() != kWheelchair) {
    clear_has_wheelchair();
    set_has_wheelchair();
  }
  _impl_.has_wheelchair_.wheelchair_ = value;
}

// bool bicycle = 43;
inline bool Costing_Options::has_bicycle() const {
  return has_bicycle_case() == kBicycle;
}
inline void Costing_Options::set_has_bicycle() {
  _impl_._oneof_case_[42] = kBicycle;
}
inline void Costing_Options::clear_bicycle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_bicycle_case() == kBicycle) {
    _impl_.has_bicycle_.bicycle_ = false;
    clear_has_has_bicycle();
  }
}
inline bool Costing_Options::bicycle() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.bicycle)
  return _internal_bicycle();
}
inline void Costing_Options::set_bicycle(bool value) {
  _internal_set_bicycle(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.bicycle)
}
inline bool Costing_Options::_internal_bicycle() const {
  if (has_bicycle_case() == kBicycle) {
    return _impl_.has_bicycle_.bicycle_;
  }
  return false;
}
inline void Costing_Options::_internal_set_bicycle(bool value) {
  if (has_bicycle_case() != kBicycle) {
    clear_has_bicycle();
    set_has_bicycle();
  }
  _impl_.has_bicycle_.bicycle_ = value;
}

// float use_bus = 44;
inline bool Costing_Options::has_use_bus() const {
  return has_use_bus_case() == kUseBus;
}
inline void Costing_Options::set_has_use_bus() {
  _impl_._oneof_case_[43] = kUseBus;
}
inline void Costing_Options::clear_use_bus() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_use_bus_case() == kUseBus) {
    _impl_.has_use_bus_.use_bus_ = 0;
    clear_has_has_use_bus();
  }
}
inline float Costing_Options::use_bus() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.use_bus)
  return _internal_use_bus();
}
inline void Costing_Options::set_use_bus(float value) {
  _internal_set_use_bus(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.use_bus)
}
inline float Costing_Options::_internal_use_bus() const {
  if (has_use_bus_case() == kUseBus) {
    return _impl_.has_use_bus_.use_bus_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_use_bus(float value) {
  if (has_use_bus_case() != kUseBus) {
    clear_has_use_bus();
    set_has_use_bus();
  }
  _impl_.has_use_bus_.use_bus_ = value;
}

// float use_rail = 45;
inline bool Costing_Options::has_use_rail() const {
  return has_use_rail_case() == kUseRail;
}
inline void Costing_Options::set_has_use_rail() {
  _impl_._oneof_case_[44] = kUseRail;
}
inline void Costing_Options::clear_use_rail() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_use_rail_case() == kUseRail) {
    _impl_.has_use_rail_.use_rail_ = 0;
    clear_has_has_use_rail();
  }
}
inline float Costing_Options::use_rail() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.use_rail)
  return _internal_use_rail();
}
inline void Costing_Options::set_use_rail(float value) {
  _internal_set_use_rail(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.use_rail)
}
inline float Costing_Options::_internal_use_rail() const {
  if (has_use_rail_case() == kUseRail) {
    return _impl_.has_use_rail_.use_rail_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_use_rail(float value) {
  if (has_use_rail_case() != kUseRail) {
    clear_has_use_rail();
    set_has_use_rail();
  }
  _impl_.has_use_rail_.use_rail_ = value;
}

// float use_transfers = 46;
inline bool Costing_Options::has_use_transfers() const {
  return has_use_transfers_case() == kUseTransfers;
}
inline void Costing_Options::set_has_use_transfers() {
  _impl_._oneof_case_[45] = kUseTransfers;
}
inline void Costing_Options::clear_use_transfers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_use_transfers_case() == kUseTransfers) {
    _impl_.has_use_transfers_.use_transfers_ = 0;
    clear_has_has_use_transfers();
  }
}
inline float Costing_Options::use_transfers() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.use_transfers)
  return _internal_use_transfers();
}
inline void Costing_Options::set_use_transfers(float value) {
  _internal_set_use_transfers(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.use_transfers)
}
inline float Costing_Options::_internal_use_transfers() const {
  if (has_use_transfers_case() == kUseTransfers) {
    return _impl_.has_use_transfers_.use_transfers_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_use_transfers(float value) {
  if (has_use_transfers_case() != kUseTransfers) {
    clear_has_use_transfers();
    set_has_use_transfers();
  }
  _impl_.has_use_transfers_.use_transfers_ = value;
}

// float transfer_cost = 47;
inline bool Costing_Options::has_transfer_cost() const {
  return has_transfer_cost_case() == kTransferCost;
}
inline void Costing_Options::set_has_transfer_cost() {
  _impl_._oneof_case_[46] = kTransferCost;
}
inline void Costing_Options::clear_transfer_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_transfer_cost_case() == kTransferCost) {
    _impl_.has_transfer_cost_.transfer_cost_ = 0;
    clear_has_has_transfer_cost();
  }
}
inline float Costing_Options::transfer_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.transfer_cost)
  return _internal_transfer_cost();
}
inline void Costing_Options::set_transfer_cost(float value) {
  _internal_set_transfer_cost(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.transfer_cost)
}
inline float Costing_Options::_internal_transfer_cost() const {
  if (has_transfer_cost_case() == kTransferCost) {
    return _impl_.has_transfer_cost_.transfer_cost_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_transfer_cost(float value) {
  if (has_transfer_cost_case() != kTransferCost) {
    clear_has_transfer_cost();
    set_has_transfer_cost();
  }
  _impl_.has_transfer_cost_.transfer_cost_ = value;
}

// float transfer_penalty = 48;
inline bool Costing_Options::has_transfer_penalty() const {
  return has_transfer_penalty_case() == kTransferPenalty;
}
inline void Costing_Options::set_has_transfer_penalty() {
  _impl_._oneof_case_[47] = kTransferPenalty;
}
inline void Costing_Options::clear_transfer_penalty() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_transfer_penalty_case() == kTransferPenalty) {
    _impl_.has_transfer_penalty_.transfer_penalty_ = 0;
    clear_has_has_transfer_penalty();
  }
}
inline float Costing_Options::transfer_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.transfer_penalty)
  return _internal_transfer_penalty();
}
inline void Costing_Options::set_transfer_penalty(float value) {
  _internal_set_transfer_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.transfer_penalty)
}
inline float Costing_Options::_internal_transfer_penalty() const {
  if (has_transfer_penalty_case() == kTransferPenalty) {
    return _impl_.has_transfer_penalty_.transfer_penalty_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_transfer_penalty(float value) {
  if (has_transfer_penalty_case() != kTransferPenalty) {
    clear_has_transfer_penalty();
    set_has_transfer_penalty();
  }
  _impl_.has_transfer_penalty_.transfer_penalty_ = value;
}

// .valhalla.FilterAction filter_stop_action = 49;
inline void Costing_Options::clear_filter_stop_action() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filter_stop_action_ = 0;
}
inline ::valhalla::FilterAction Costing_Options::filter_stop_action() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.filter_stop_action)
  return _internal_filter_stop_action();
}
inline void Costing_Options::set_filter_stop_action(::valhalla::FilterAction value) {
  _internal_set_filter_stop_action(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.filter_stop_action)
}
inline ::valhalla::FilterAction Costing_Options::_internal_filter_stop_action() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::FilterAction>(_impl_.filter_stop_action_);
}
inline void Costing_Options::_internal_set_filter_stop_action(::valhalla::FilterAction value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.filter_stop_action_ = value;
}

// repeated string filter_stop_ids = 50;
inline int Costing_Options::_internal_filter_stop_ids_size() const {
  return _internal_filter_stop_ids().size();
}
inline int Costing_Options::filter_stop_ids_size() const {
  return _internal_filter_stop_ids_size();
}
inline void Costing_Options::clear_filter_stop_ids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filter_stop_ids_.Clear();
}
inline std::string* Costing_Options::add_filter_stop_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_filter_stop_ids()->Add();
  // @@protoc_insertion_point(field_add_mutable:valhalla.Costing.Options.filter_stop_ids)
  return _s;
}
inline const std::string& Costing_Options::filter_stop_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.filter_stop_ids)
  return _internal_filter_stop_ids().Get(index);
}
inline std::string* Costing_Options::mutable_filter_stop_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.Costing.Options.filter_stop_ids)
  return _internal_mutable_filter_stop_ids()->Mutable(index);
}
inline void Costing_Options::set_filter_stop_ids(int index, const std::string& value) {
  _internal_mutable_filter_stop_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.filter_stop_ids)
}
inline void Costing_Options::set_filter_stop_ids(int index, std::string&& value) {
  _internal_mutable_filter_stop_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.filter_stop_ids)
}
inline void Costing_Options::set_filter_stop_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_filter_stop_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.Costing.Options.filter_stop_ids)
}
inline void Costing_Options::set_filter_stop_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_filter_stop_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.Costing.Options.filter_stop_ids)
}
inline void Costing_Options::set_filter_stop_ids(int index, absl::string_view value) {
  _internal_mutable_filter_stop_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:valhalla.Costing.Options.filter_stop_ids)
}
inline void Costing_Options::add_filter_stop_ids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_filter_stop_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:valhalla.Costing.Options.filter_stop_ids)
}
inline void Costing_Options::add_filter_stop_ids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_filter_stop_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:valhalla.Costing.Options.filter_stop_ids)
}
inline void Costing_Options::add_filter_stop_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_filter_stop_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:valhalla.Costing.Options.filter_stop_ids)
}
inline void Costing_Options::add_filter_stop_ids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_filter_stop_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:valhalla.Costing.Options.filter_stop_ids)
}
inline void Costing_Options::add_filter_stop_ids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_filter_stop_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:valhalla.Costing.Options.filter_stop_ids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Costing_Options::filter_stop_ids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.Costing.Options.filter_stop_ids)
  return _internal_filter_stop_ids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Costing_Options::mutable_filter_stop_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Costing.Options.filter_stop_ids)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_filter_stop_ids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Costing_Options::_internal_filter_stop_ids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.filter_stop_ids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Costing_Options::_internal_mutable_filter_stop_ids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.filter_stop_ids_;
}

// .valhalla.FilterAction filter_operator_action = 51;
inline void Costing_Options::clear_filter_operator_action() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filter_operator_action_ = 0;
}
inline ::valhalla::FilterAction Costing_Options::filter_operator_action() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.filter_operator_action)
  return _internal_filter_operator_action();
}
inline void Costing_Options::set_filter_operator_action(::valhalla::FilterAction value) {
  _internal_set_filter_operator_action(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.filter_operator_action)
}
inline ::valhalla::FilterAction Costing_Options::_internal_filter_operator_action() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::FilterAction>(_impl_.filter_operator_action_);
}
inline void Costing_Options::_internal_set_filter_operator_action(::valhalla::FilterAction value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.filter_operator_action_ = value;
}

// repeated string filter_operator_ids = 52;
inline int Costing_Options::_internal_filter_operator_ids_size() const {
  return _internal_filter_operator_ids().size();
}
inline int Costing_Options::filter_operator_ids_size() const {
  return _internal_filter_operator_ids_size();
}
inline void Costing_Options::clear_filter_operator_ids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filter_operator_ids_.Clear();
}
inline std::string* Costing_Options::add_filter_operator_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_filter_operator_ids()->Add();
  // @@protoc_insertion_point(field_add_mutable:valhalla.Costing.Options.filter_operator_ids)
  return _s;
}
inline const std::string& Costing_Options::filter_operator_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.filter_operator_ids)
  return _internal_filter_operator_ids().Get(index);
}
inline std::string* Costing_Options::mutable_filter_operator_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.Costing.Options.filter_operator_ids)
  return _internal_mutable_filter_operator_ids()->Mutable(index);
}
inline void Costing_Options::set_filter_operator_ids(int index, const std::string& value) {
  _internal_mutable_filter_operator_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.filter_operator_ids)
}
inline void Costing_Options::set_filter_operator_ids(int index, std::string&& value) {
  _internal_mutable_filter_operator_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.filter_operator_ids)
}
inline void Costing_Options::set_filter_operator_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_filter_operator_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.Costing.Options.filter_operator_ids)
}
inline void Costing_Options::set_filter_operator_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_filter_operator_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.Costing.Options.filter_operator_ids)
}
inline void Costing_Options::set_filter_operator_ids(int index, absl::string_view value) {
  _internal_mutable_filter_operator_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:valhalla.Costing.Options.filter_operator_ids)
}
inline void Costing_Options::add_filter_operator_ids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_filter_operator_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:valhalla.Costing.Options.filter_operator_ids)
}
inline void Costing_Options::add_filter_operator_ids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_filter_operator_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:valhalla.Costing.Options.filter_operator_ids)
}
inline void Costing_Options::add_filter_operator_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_filter_operator_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:valhalla.Costing.Options.filter_operator_ids)
}
inline void Costing_Options::add_filter_operator_ids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_filter_operator_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:valhalla.Costing.Options.filter_operator_ids)
}
inline void Costing_Options::add_filter_operator_ids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_filter_operator_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:valhalla.Costing.Options.filter_operator_ids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Costing_Options::filter_operator_ids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.Costing.Options.filter_operator_ids)
  return _internal_filter_operator_ids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Costing_Options::mutable_filter_operator_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Costing.Options.filter_operator_ids)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_filter_operator_ids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Costing_Options::_internal_filter_operator_ids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.filter_operator_ids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Costing_Options::_internal_mutable_filter_operator_ids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.filter_operator_ids_;
}

// .valhalla.FilterAction filter_route_action = 53;
inline void Costing_Options::clear_filter_route_action() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filter_route_action_ = 0;
}
inline ::valhalla::FilterAction Costing_Options::filter_route_action() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.filter_route_action)
  return _internal_filter_route_action();
}
inline void Costing_Options::set_filter_route_action(::valhalla::FilterAction value) {
  _internal_set_filter_route_action(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.filter_route_action)
}
inline ::valhalla::FilterAction Costing_Options::_internal_filter_route_action() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::FilterAction>(_impl_.filter_route_action_);
}
inline void Costing_Options::_internal_set_filter_route_action(::valhalla::FilterAction value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.filter_route_action_ = value;
}

// repeated string filter_route_ids = 54;
inline int Costing_Options::_internal_filter_route_ids_size() const {
  return _internal_filter_route_ids().size();
}
inline int Costing_Options::filter_route_ids_size() const {
  return _internal_filter_route_ids_size();
}
inline void Costing_Options::clear_filter_route_ids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filter_route_ids_.Clear();
}
inline std::string* Costing_Options::add_filter_route_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_filter_route_ids()->Add();
  // @@protoc_insertion_point(field_add_mutable:valhalla.Costing.Options.filter_route_ids)
  return _s;
}
inline const std::string& Costing_Options::filter_route_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.filter_route_ids)
  return _internal_filter_route_ids().Get(index);
}
inline std::string* Costing_Options::mutable_filter_route_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.Costing.Options.filter_route_ids)
  return _internal_mutable_filter_route_ids()->Mutable(index);
}
inline void Costing_Options::set_filter_route_ids(int index, const std::string& value) {
  _internal_mutable_filter_route_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.filter_route_ids)
}
inline void Costing_Options::set_filter_route_ids(int index, std::string&& value) {
  _internal_mutable_filter_route_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.filter_route_ids)
}
inline void Costing_Options::set_filter_route_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_filter_route_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.Costing.Options.filter_route_ids)
}
inline void Costing_Options::set_filter_route_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_filter_route_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.Costing.Options.filter_route_ids)
}
inline void Costing_Options::set_filter_route_ids(int index, absl::string_view value) {
  _internal_mutable_filter_route_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:valhalla.Costing.Options.filter_route_ids)
}
inline void Costing_Options::add_filter_route_ids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_filter_route_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:valhalla.Costing.Options.filter_route_ids)
}
inline void Costing_Options::add_filter_route_ids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_filter_route_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:valhalla.Costing.Options.filter_route_ids)
}
inline void Costing_Options::add_filter_route_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_filter_route_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:valhalla.Costing.Options.filter_route_ids)
}
inline void Costing_Options::add_filter_route_ids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_filter_route_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:valhalla.Costing.Options.filter_route_ids)
}
inline void Costing_Options::add_filter_route_ids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_filter_route_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:valhalla.Costing.Options.filter_route_ids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Costing_Options::filter_route_ids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.Costing.Options.filter_route_ids)
  return _internal_filter_route_ids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Costing_Options::mutable_filter_route_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Costing.Options.filter_route_ids)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_filter_route_ids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Costing_Options::_internal_filter_route_ids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.filter_route_ids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Costing_Options::_internal_mutable_filter_route_ids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.filter_route_ids_;
}

// uint32 flow_mask = 55;
inline bool Costing_Options::has_flow_mask() const {
  return has_flow_mask_case() == kFlowMask;
}
inline void Costing_Options::set_has_flow_mask() {
  _impl_._oneof_case_[48] = kFlowMask;
}
inline void Costing_Options::clear_flow_mask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_flow_mask_case() == kFlowMask) {
    _impl_.has_flow_mask_.flow_mask_ = 0u;
    clear_has_has_flow_mask();
  }
}
inline ::uint32_t Costing_Options::flow_mask() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.flow_mask)
  return _internal_flow_mask();
}
inline void Costing_Options::set_flow_mask(::uint32_t value) {
  _internal_set_flow_mask(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.flow_mask)
}
inline ::uint32_t Costing_Options::_internal_flow_mask() const {
  if (has_flow_mask_case() == kFlowMask) {
    return _impl_.has_flow_mask_.flow_mask_;
  }
  return 0u;
}
inline void Costing_Options::_internal_set_flow_mask(::uint32_t value) {
  if (has_flow_mask_case() != kFlowMask) {
    clear_has_flow_mask();
    set_has_flow_mask();
  }
  _impl_.has_flow_mask_.flow_mask_ = value;
}

// float bike_share_cost = 56;
inline bool Costing_Options::has_bike_share_cost() const {
  return has_bike_share_cost_case() == kBikeShareCost;
}
inline void Costing_Options::set_has_bike_share_cost() {
  _impl_._oneof_case_[49] = kBikeShareCost;
}
inline void Costing_Options::clear_bike_share_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_bike_share_cost_case() == kBikeShareCost) {
    _impl_.has_bike_share_cost_.bike_share_cost_ = 0;
    clear_has_has_bike_share_cost();
  }
}
inline float Costing_Options::bike_share_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.bike_share_cost)
  return _internal_bike_share_cost();
}
inline void Costing_Options::set_bike_share_cost(float value) {
  _internal_set_bike_share_cost(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.bike_share_cost)
}
inline float Costing_Options::_internal_bike_share_cost() const {
  if (has_bike_share_cost_case() == kBikeShareCost) {
    return _impl_.has_bike_share_cost_.bike_share_cost_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_bike_share_cost(float value) {
  if (has_bike_share_cost_case() != kBikeShareCost) {
    clear_has_bike_share_cost();
    set_has_bike_share_cost();
  }
  _impl_.has_bike_share_cost_.bike_share_cost_ = value;
}

// float bike_share_penalty = 57;
inline bool Costing_Options::has_bike_share_penalty() const {
  return has_bike_share_penalty_case() == kBikeSharePenalty;
}
inline void Costing_Options::set_has_bike_share_penalty() {
  _impl_._oneof_case_[50] = kBikeSharePenalty;
}
inline void Costing_Options::clear_bike_share_penalty() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_bike_share_penalty_case() == kBikeSharePenalty) {
    _impl_.has_bike_share_penalty_.bike_share_penalty_ = 0;
    clear_has_has_bike_share_penalty();
  }
}
inline float Costing_Options::bike_share_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.bike_share_penalty)
  return _internal_bike_share_penalty();
}
inline void Costing_Options::set_bike_share_penalty(float value) {
  _internal_set_bike_share_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.bike_share_penalty)
}
inline float Costing_Options::_internal_bike_share_penalty() const {
  if (has_bike_share_penalty_case() == kBikeSharePenalty) {
    return _impl_.has_bike_share_penalty_.bike_share_penalty_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_bike_share_penalty(float value) {
  if (has_bike_share_penalty_case() != kBikeSharePenalty) {
    clear_has_bike_share_penalty();
    set_has_bike_share_penalty();
  }
  _impl_.has_bike_share_penalty_.bike_share_penalty_ = value;
}

// float rail_ferry_cost = 58;
inline bool Costing_Options::has_rail_ferry_cost() const {
  return has_rail_ferry_cost_case() == kRailFerryCost;
}
inline void Costing_Options::set_has_rail_ferry_cost() {
  _impl_._oneof_case_[51] = kRailFerryCost;
}
inline void Costing_Options::clear_rail_ferry_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_rail_ferry_cost_case() == kRailFerryCost) {
    _impl_.has_rail_ferry_cost_.rail_ferry_cost_ = 0;
    clear_has_has_rail_ferry_cost();
  }
}
inline float Costing_Options::rail_ferry_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.rail_ferry_cost)
  return _internal_rail_ferry_cost();
}
inline void Costing_Options::set_rail_ferry_cost(float value) {
  _internal_set_rail_ferry_cost(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.rail_ferry_cost)
}
inline float Costing_Options::_internal_rail_ferry_cost() const {
  if (has_rail_ferry_cost_case() == kRailFerryCost) {
    return _impl_.has_rail_ferry_cost_.rail_ferry_cost_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_rail_ferry_cost(float value) {
  if (has_rail_ferry_cost_case() != kRailFerryCost) {
    clear_has_rail_ferry_cost();
    set_has_rail_ferry_cost();
  }
  _impl_.has_rail_ferry_cost_.rail_ferry_cost_ = value;
}

// float use_rail_ferry = 59;
inline bool Costing_Options::has_use_rail_ferry() const {
  return has_use_rail_ferry_case() == kUseRailFerry;
}
inline void Costing_Options::set_has_use_rail_ferry() {
  _impl_._oneof_case_[52] = kUseRailFerry;
}
inline void Costing_Options::clear_use_rail_ferry() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_use_rail_ferry_case() == kUseRailFerry) {
    _impl_.has_use_rail_ferry_.use_rail_ferry_ = 0;
    clear_has_has_use_rail_ferry();
  }
}
inline float Costing_Options::use_rail_ferry() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.use_rail_ferry)
  return _internal_use_rail_ferry();
}
inline void Costing_Options::set_use_rail_ferry(float value) {
  _internal_set_use_rail_ferry(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.use_rail_ferry)
}
inline float Costing_Options::_internal_use_rail_ferry() const {
  if (has_use_rail_ferry_case() == kUseRailFerry) {
    return _impl_.has_use_rail_ferry_.use_rail_ferry_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_use_rail_ferry(float value) {
  if (has_use_rail_ferry_case() != kUseRailFerry) {
    clear_has_use_rail_ferry();
    set_has_use_rail_ferry();
  }
  _impl_.has_use_rail_ferry_.use_rail_ferry_ = value;
}

// bool ignore_restrictions = 60;
inline bool Costing_Options::has_ignore_restrictions() const {
  return has_ignore_restrictions_case() == kIgnoreRestrictions;
}
inline void Costing_Options::set_has_ignore_restrictions() {
  _impl_._oneof_case_[53] = kIgnoreRestrictions;
}
inline void Costing_Options::clear_ignore_restrictions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_ignore_restrictions_case() == kIgnoreRestrictions) {
    _impl_.has_ignore_restrictions_.ignore_restrictions_ = false;
    clear_has_has_ignore_restrictions();
  }
}
inline bool Costing_Options::ignore_restrictions() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.ignore_restrictions)
  return _internal_ignore_restrictions();
}
inline void Costing_Options::set_ignore_restrictions(bool value) {
  _internal_set_ignore_restrictions(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.ignore_restrictions)
}
inline bool Costing_Options::_internal_ignore_restrictions() const {
  if (has_ignore_restrictions_case() == kIgnoreRestrictions) {
    return _impl_.has_ignore_restrictions_.ignore_restrictions_;
  }
  return false;
}
inline void Costing_Options::_internal_set_ignore_restrictions(bool value) {
  if (has_ignore_restrictions_case() != kIgnoreRestrictions) {
    clear_has_ignore_restrictions();
    set_has_ignore_restrictions();
  }
  _impl_.has_ignore_restrictions_.ignore_restrictions_ = value;
}

// bool ignore_oneways = 61;
inline bool Costing_Options::has_ignore_oneways() const {
  return has_ignore_oneways_case() == kIgnoreOneways;
}
inline void Costing_Options::set_has_ignore_oneways() {
  _impl_._oneof_case_[54] = kIgnoreOneways;
}
inline void Costing_Options::clear_ignore_oneways() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_ignore_oneways_case() == kIgnoreOneways) {
    _impl_.has_ignore_oneways_.ignore_oneways_ = false;
    clear_has_has_ignore_oneways();
  }
}
inline bool Costing_Options::ignore_oneways() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.ignore_oneways)
  return _internal_ignore_oneways();
}
inline void Costing_Options::set_ignore_oneways(bool value) {
  _internal_set_ignore_oneways(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.ignore_oneways)
}
inline bool Costing_Options::_internal_ignore_oneways() const {
  if (has_ignore_oneways_case() == kIgnoreOneways) {
    return _impl_.has_ignore_oneways_.ignore_oneways_;
  }
  return false;
}
inline void Costing_Options::_internal_set_ignore_oneways(bool value) {
  if (has_ignore_oneways_case() != kIgnoreOneways) {
    clear_has_ignore_oneways();
    set_has_ignore_oneways();
  }
  _impl_.has_ignore_oneways_.ignore_oneways_ = value;
}

// bool ignore_access = 62;
inline bool Costing_Options::has_ignore_access() const {
  return has_ignore_access_case() == kIgnoreAccess;
}
inline void Costing_Options::set_has_ignore_access() {
  _impl_._oneof_case_[55] = kIgnoreAccess;
}
inline void Costing_Options::clear_ignore_access() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_ignore_access_case() == kIgnoreAccess) {
    _impl_.has_ignore_access_.ignore_access_ = false;
    clear_has_has_ignore_access();
  }
}
inline bool Costing_Options::ignore_access() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.ignore_access)
  return _internal_ignore_access();
}
inline void Costing_Options::set_ignore_access(bool value) {
  _internal_set_ignore_access(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.ignore_access)
}
inline bool Costing_Options::_internal_ignore_access() const {
  if (has_ignore_access_case() == kIgnoreAccess) {
    return _impl_.has_ignore_access_.ignore_access_;
  }
  return false;
}
inline void Costing_Options::_internal_set_ignore_access(bool value) {
  if (has_ignore_access_case() != kIgnoreAccess) {
    clear_has_ignore_access();
    set_has_ignore_access();
  }
  _impl_.has_ignore_access_.ignore_access_ = value;
}

// bool ignore_closures = 63;
inline bool Costing_Options::has_ignore_closures() const {
  return has_ignore_closures_case() == kIgnoreClosures;
}
inline void Costing_Options::set_has_ignore_closures() {
  _impl_._oneof_case_[56] = kIgnoreClosures;
}
inline void Costing_Options::clear_ignore_closures() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_ignore_closures_case() == kIgnoreClosures) {
    _impl_.has_ignore_closures_.ignore_closures_ = false;
    clear_has_has_ignore_closures();
  }
}
inline bool Costing_Options::ignore_closures() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.ignore_closures)
  return _internal_ignore_closures();
}
inline void Costing_Options::set_ignore_closures(bool value) {
  _internal_set_ignore_closures(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.ignore_closures)
}
inline bool Costing_Options::_internal_ignore_closures() const {
  if (has_ignore_closures_case() == kIgnoreClosures) {
    return _impl_.has_ignore_closures_.ignore_closures_;
  }
  return false;
}
inline void Costing_Options::_internal_set_ignore_closures(bool value) {
  if (has_ignore_closures_case() != kIgnoreClosures) {
    clear_has_ignore_closures();
    set_has_ignore_closures();
  }
  _impl_.has_ignore_closures_.ignore_closures_ = value;
}

// bool shortest = 64;
inline bool Costing_Options::has_shortest() const {
  return has_shortest_case() == kShortest;
}
inline void Costing_Options::set_has_shortest() {
  _impl_._oneof_case_[57] = kShortest;
}
inline void Costing_Options::clear_shortest() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_shortest_case() == kShortest) {
    _impl_.has_shortest_.shortest_ = false;
    clear_has_has_shortest();
  }
}
inline bool Costing_Options::shortest() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.shortest)
  return _internal_shortest();
}
inline void Costing_Options::set_shortest(bool value) {
  _internal_set_shortest(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.shortest)
}
inline bool Costing_Options::_internal_shortest() const {
  if (has_shortest_case() == kShortest) {
    return _impl_.has_shortest_.shortest_;
  }
  return false;
}
inline void Costing_Options::_internal_set_shortest(bool value) {
  if (has_shortest_case() != kShortest) {
    clear_has_shortest();
    set_has_shortest();
  }
  _impl_.has_shortest_.shortest_ = value;
}

// float service_penalty = 65;
inline bool Costing_Options::has_service_penalty() const {
  return has_service_penalty_case() == kServicePenalty;
}
inline void Costing_Options::set_has_service_penalty() {
  _impl_._oneof_case_[58] = kServicePenalty;
}
inline void Costing_Options::clear_service_penalty() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_service_penalty_case() == kServicePenalty) {
    _impl_.has_service_penalty_.service_penalty_ = 0;
    clear_has_has_service_penalty();
  }
}
inline float Costing_Options::service_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.service_penalty)
  return _internal_service_penalty();
}
inline void Costing_Options::set_service_penalty(float value) {
  _internal_set_service_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.service_penalty)
}
inline float Costing_Options::_internal_service_penalty() const {
  if (has_service_penalty_case() == kServicePenalty) {
    return _impl_.has_service_penalty_.service_penalty_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_service_penalty(float value) {
  if (has_service_penalty_case() != kServicePenalty) {
    clear_has_service_penalty();
    set_has_service_penalty();
  }
  _impl_.has_service_penalty_.service_penalty_ = value;
}

// float use_tracks = 66;
inline bool Costing_Options::has_use_tracks() const {
  return has_use_tracks_case() == kUseTracks;
}
inline void Costing_Options::set_has_use_tracks() {
  _impl_._oneof_case_[59] = kUseTracks;
}
inline void Costing_Options::clear_use_tracks() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_use_tracks_case() == kUseTracks) {
    _impl_.has_use_tracks_.use_tracks_ = 0;
    clear_has_has_use_tracks();
  }
}
inline float Costing_Options::use_tracks() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.use_tracks)
  return _internal_use_tracks();
}
inline void Costing_Options::set_use_tracks(float value) {
  _internal_set_use_tracks(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.use_tracks)
}
inline float Costing_Options::_internal_use_tracks() const {
  if (has_use_tracks_case() == kUseTracks) {
    return _impl_.has_use_tracks_.use_tracks_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_use_tracks(float value) {
  if (has_use_tracks_case() != kUseTracks) {
    clear_has_use_tracks();
    set_has_use_tracks();
  }
  _impl_.has_use_tracks_.use_tracks_ = value;
}

// float use_distance = 67;
inline bool Costing_Options::has_use_distance() const {
  return has_use_distance_case() == kUseDistance;
}
inline void Costing_Options::set_has_use_distance() {
  _impl_._oneof_case_[60] = kUseDistance;
}
inline void Costing_Options::clear_use_distance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_use_distance_case() == kUseDistance) {
    _impl_.has_use_distance_.use_distance_ = 0;
    clear_has_has_use_distance();
  }
}
inline float Costing_Options::use_distance() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.use_distance)
  return _internal_use_distance();
}
inline void Costing_Options::set_use_distance(float value) {
  _internal_set_use_distance(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.use_distance)
}
inline float Costing_Options::_internal_use_distance() const {
  if (has_use_distance_case() == kUseDistance) {
    return _impl_.has_use_distance_.use_distance_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_use_distance(float value) {
  if (has_use_distance_case() != kUseDistance) {
    clear_has_use_distance();
    set_has_use_distance();
  }
  _impl_.has_use_distance_.use_distance_ = value;
}

// float use_living_streets = 68;
inline bool Costing_Options::has_use_living_streets() const {
  return has_use_living_streets_case() == kUseLivingStreets;
}
inline void Costing_Options::set_has_use_living_streets() {
  _impl_._oneof_case_[61] = kUseLivingStreets;
}
inline void Costing_Options::clear_use_living_streets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_use_living_streets_case() == kUseLivingStreets) {
    _impl_.has_use_living_streets_.use_living_streets_ = 0;
    clear_has_has_use_living_streets();
  }
}
inline float Costing_Options::use_living_streets() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.use_living_streets)
  return _internal_use_living_streets();
}
inline void Costing_Options::set_use_living_streets(float value) {
  _internal_set_use_living_streets(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.use_living_streets)
}
inline float Costing_Options::_internal_use_living_streets() const {
  if (has_use_living_streets_case() == kUseLivingStreets) {
    return _impl_.has_use_living_streets_.use_living_streets_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_use_living_streets(float value) {
  if (has_use_living_streets_case() != kUseLivingStreets) {
    clear_has_use_living_streets();
    set_has_use_living_streets();
  }
  _impl_.has_use_living_streets_.use_living_streets_ = value;
}

// float service_factor = 69;
inline bool Costing_Options::has_service_factor() const {
  return has_service_factor_case() == kServiceFactor;
}
inline void Costing_Options::set_has_service_factor() {
  _impl_._oneof_case_[62] = kServiceFactor;
}
inline void Costing_Options::clear_service_factor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_service_factor_case() == kServiceFactor) {
    _impl_.has_service_factor_.service_factor_ = 0;
    clear_has_has_service_factor();
  }
}
inline float Costing_Options::service_factor() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.service_factor)
  return _internal_service_factor();
}
inline void Costing_Options::set_service_factor(float value) {
  _internal_set_service_factor(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.service_factor)
}
inline float Costing_Options::_internal_service_factor() const {
  if (has_service_factor_case() == kServiceFactor) {
    return _impl_.has_service_factor_.service_factor_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_service_factor(float value) {
  if (has_service_factor_case() != kServiceFactor) {
    clear_has_service_factor();
    set_has_service_factor();
  }
  _impl_.has_service_factor_.service_factor_ = value;
}

// float closure_factor = 70;
inline bool Costing_Options::has_closure_factor() const {
  return has_closure_factor_case() == kClosureFactor;
}
inline void Costing_Options::set_has_closure_factor() {
  _impl_._oneof_case_[63] = kClosureFactor;
}
inline void Costing_Options::clear_closure_factor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_closure_factor_case() == kClosureFactor) {
    _impl_.has_closure_factor_.closure_factor_ = 0;
    clear_has_has_closure_factor();
  }
}
inline float Costing_Options::closure_factor() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.closure_factor)
  return _internal_closure_factor();
}
inline void Costing_Options::set_closure_factor(float value) {
  _internal_set_closure_factor(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.closure_factor)
}
inline float Costing_Options::_internal_closure_factor() const {
  if (has_closure_factor_case() == kClosureFactor) {
    return _impl_.has_closure_factor_.closure_factor_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_closure_factor(float value) {
  if (has_closure_factor_case() != kClosureFactor) {
    clear_has_closure_factor();
    set_has_closure_factor();
  }
  _impl_.has_closure_factor_.closure_factor_ = value;
}

// float private_access_penalty = 71;
inline bool Costing_Options::has_private_access_penalty() const {
  return has_private_access_penalty_case() == kPrivateAccessPenalty;
}
inline void Costing_Options::set_has_private_access_penalty() {
  _impl_._oneof_case_[64] = kPrivateAccessPenalty;
}
inline void Costing_Options::clear_private_access_penalty() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_private_access_penalty_case() == kPrivateAccessPenalty) {
    _impl_.has_private_access_penalty_.private_access_penalty_ = 0;
    clear_has_has_private_access_penalty();
  }
}
inline float Costing_Options::private_access_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.private_access_penalty)
  return _internal_private_access_penalty();
}
inline void Costing_Options::set_private_access_penalty(float value) {
  _internal_set_private_access_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.private_access_penalty)
}
inline float Costing_Options::_internal_private_access_penalty() const {
  if (has_private_access_penalty_case() == kPrivateAccessPenalty) {
    return _impl_.has_private_access_penalty_.private_access_penalty_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_private_access_penalty(float value) {
  if (has_private_access_penalty_case() != kPrivateAccessPenalty) {
    clear_has_private_access_penalty();
    set_has_private_access_penalty();
  }
  _impl_.has_private_access_penalty_.private_access_penalty_ = value;
}

// bool exclude_unpaved = 72;
inline bool Costing_Options::has_exclude_unpaved() const {
  return has_exclude_unpaved_case() == kExcludeUnpaved;
}
inline void Costing_Options::set_has_exclude_unpaved() {
  _impl_._oneof_case_[65] = kExcludeUnpaved;
}
inline void Costing_Options::clear_exclude_unpaved() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_exclude_unpaved_case() == kExcludeUnpaved) {
    _impl_.has_exclude_unpaved_.exclude_unpaved_ = false;
    clear_has_has_exclude_unpaved();
  }
}
inline bool Costing_Options::exclude_unpaved() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.exclude_unpaved)
  return _internal_exclude_unpaved();
}
inline void Costing_Options::set_exclude_unpaved(bool value) {
  _internal_set_exclude_unpaved(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.exclude_unpaved)
}
inline bool Costing_Options::_internal_exclude_unpaved() const {
  if (has_exclude_unpaved_case() == kExcludeUnpaved) {
    return _impl_.has_exclude_unpaved_.exclude_unpaved_;
  }
  return false;
}
inline void Costing_Options::_internal_set_exclude_unpaved(bool value) {
  if (has_exclude_unpaved_case() != kExcludeUnpaved) {
    clear_has_exclude_unpaved();
    set_has_exclude_unpaved();
  }
  _impl_.has_exclude_unpaved_.exclude_unpaved_ = value;
}

// bool include_hot = 73;
inline bool Costing_Options::has_include_hot() const {
  return has_include_hot_case() == kIncludeHot;
}
inline void Costing_Options::set_has_include_hot() {
  _impl_._oneof_case_[66] = kIncludeHot;
}
inline void Costing_Options::clear_include_hot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_include_hot_case() == kIncludeHot) {
    _impl_.has_include_hot_.include_hot_ = false;
    clear_has_has_include_hot();
  }
}
inline bool Costing_Options::include_hot() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.include_hot)
  return _internal_include_hot();
}
inline void Costing_Options::set_include_hot(bool value) {
  _internal_set_include_hot(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.include_hot)
}
inline bool Costing_Options::_internal_include_hot() const {
  if (has_include_hot_case() == kIncludeHot) {
    return _impl_.has_include_hot_.include_hot_;
  }
  return false;
}
inline void Costing_Options::_internal_set_include_hot(bool value) {
  if (has_include_hot_case() != kIncludeHot) {
    clear_has_include_hot();
    set_has_include_hot();
  }
  _impl_.has_include_hot_.include_hot_ = value;
}

// bool include_hov2 = 74;
inline bool Costing_Options::has_include_hov2() const {
  return has_include_hov2_case() == kIncludeHov2;
}
inline void Costing_Options::set_has_include_hov2() {
  _impl_._oneof_case_[67] = kIncludeHov2;
}
inline void Costing_Options::clear_include_hov2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_include_hov2_case() == kIncludeHov2) {
    _impl_.has_include_hov2_.include_hov2_ = false;
    clear_has_has_include_hov2();
  }
}
inline bool Costing_Options::include_hov2() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.include_hov2)
  return _internal_include_hov2();
}
inline void Costing_Options::set_include_hov2(bool value) {
  _internal_set_include_hov2(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.include_hov2)
}
inline bool Costing_Options::_internal_include_hov2() const {
  if (has_include_hov2_case() == kIncludeHov2) {
    return _impl_.has_include_hov2_.include_hov2_;
  }
  return false;
}
inline void Costing_Options::_internal_set_include_hov2(bool value) {
  if (has_include_hov2_case() != kIncludeHov2) {
    clear_has_include_hov2();
    set_has_include_hov2();
  }
  _impl_.has_include_hov2_.include_hov2_ = value;
}

// bool include_hov3 = 75;
inline bool Costing_Options::has_include_hov3() const {
  return has_include_hov3_case() == kIncludeHov3;
}
inline void Costing_Options::set_has_include_hov3() {
  _impl_._oneof_case_[68] = kIncludeHov3;
}
inline void Costing_Options::clear_include_hov3() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_include_hov3_case() == kIncludeHov3) {
    _impl_.has_include_hov3_.include_hov3_ = false;
    clear_has_has_include_hov3();
  }
}
inline bool Costing_Options::include_hov3() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.include_hov3)
  return _internal_include_hov3();
}
inline void Costing_Options::set_include_hov3(bool value) {
  _internal_set_include_hov3(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.include_hov3)
}
inline bool Costing_Options::_internal_include_hov3() const {
  if (has_include_hov3_case() == kIncludeHov3) {
    return _impl_.has_include_hov3_.include_hov3_;
  }
  return false;
}
inline void Costing_Options::_internal_set_include_hov3(bool value) {
  if (has_include_hov3_case() != kIncludeHov3) {
    clear_has_include_hov3();
    set_has_include_hov3();
  }
  _impl_.has_include_hov3_.include_hov3_ = value;
}

// bool exclude_cash_only_tolls = 76;
inline bool Costing_Options::has_exclude_cash_only_tolls() const {
  return has_exclude_cash_only_tolls_case() == kExcludeCashOnlyTolls;
}
inline void Costing_Options::set_has_exclude_cash_only_tolls() {
  _impl_._oneof_case_[69] = kExcludeCashOnlyTolls;
}
inline void Costing_Options::clear_exclude_cash_only_tolls() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_exclude_cash_only_tolls_case() == kExcludeCashOnlyTolls) {
    _impl_.has_exclude_cash_only_tolls_.exclude_cash_only_tolls_ = false;
    clear_has_has_exclude_cash_only_tolls();
  }
}
inline bool Costing_Options::exclude_cash_only_tolls() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.exclude_cash_only_tolls)
  return _internal_exclude_cash_only_tolls();
}
inline void Costing_Options::set_exclude_cash_only_tolls(bool value) {
  _internal_set_exclude_cash_only_tolls(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.exclude_cash_only_tolls)
}
inline bool Costing_Options::_internal_exclude_cash_only_tolls() const {
  if (has_exclude_cash_only_tolls_case() == kExcludeCashOnlyTolls) {
    return _impl_.has_exclude_cash_only_tolls_.exclude_cash_only_tolls_;
  }
  return false;
}
inline void Costing_Options::_internal_set_exclude_cash_only_tolls(bool value) {
  if (has_exclude_cash_only_tolls_case() != kExcludeCashOnlyTolls) {
    clear_has_exclude_cash_only_tolls();
    set_has_exclude_cash_only_tolls();
  }
  _impl_.has_exclude_cash_only_tolls_.exclude_cash_only_tolls_ = value;
}

// uint32 restriction_probability = 77;
inline bool Costing_Options::has_restriction_probability() const {
  return has_restriction_probability_case() == kRestrictionProbability;
}
inline void Costing_Options::set_has_restriction_probability() {
  _impl_._oneof_case_[70] = kRestrictionProbability;
}
inline void Costing_Options::clear_restriction_probability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_restriction_probability_case() == kRestrictionProbability) {
    _impl_.has_restriction_probability_.restriction_probability_ = 0u;
    clear_has_has_restriction_probability();
  }
}
inline ::uint32_t Costing_Options::restriction_probability() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.restriction_probability)
  return _internal_restriction_probability();
}
inline void Costing_Options::set_restriction_probability(::uint32_t value) {
  _internal_set_restriction_probability(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.restriction_probability)
}
inline ::uint32_t Costing_Options::_internal_restriction_probability() const {
  if (has_restriction_probability_case() == kRestrictionProbability) {
    return _impl_.has_restriction_probability_.restriction_probability_;
  }
  return 0u;
}
inline void Costing_Options::_internal_set_restriction_probability(::uint32_t value) {
  if (has_restriction_probability_case() != kRestrictionProbability) {
    clear_has_restriction_probability();
    set_has_restriction_probability();
  }
  _impl_.has_restriction_probability_.restriction_probability_ = value;
}

// repeated .valhalla.AvoidEdge exclude_edges = 78;
inline int Costing_Options::_internal_exclude_edges_size() const {
  return _internal_exclude_edges().size();
}
inline int Costing_Options::exclude_edges_size() const {
  return _internal_exclude_edges_size();
}
inline void Costing_Options::clear_exclude_edges() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.exclude_edges_.Clear();
}
inline ::valhalla::AvoidEdge* Costing_Options::mutable_exclude_edges(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.Costing.Options.exclude_edges)
  return _internal_mutable_exclude_edges()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::AvoidEdge>* Costing_Options::mutable_exclude_edges()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Costing.Options.exclude_edges)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_exclude_edges();
}
inline const ::valhalla::AvoidEdge& Costing_Options::exclude_edges(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.exclude_edges)
  return _internal_exclude_edges().Get(index);
}
inline ::valhalla::AvoidEdge* Costing_Options::add_exclude_edges() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::AvoidEdge* _add = _internal_mutable_exclude_edges()->Add();
  // @@protoc_insertion_point(field_add:valhalla.Costing.Options.exclude_edges)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::AvoidEdge>& Costing_Options::exclude_edges() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.Costing.Options.exclude_edges)
  return _internal_exclude_edges();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::AvoidEdge>&
Costing_Options::_internal_exclude_edges() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.exclude_edges_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::AvoidEdge>*
Costing_Options::_internal_mutable_exclude_edges() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.exclude_edges_;
}

// float elevator_penalty = 79;
inline bool Costing_Options::has_elevator_penalty() const {
  return has_elevator_penalty_case() == kElevatorPenalty;
}
inline void Costing_Options::set_has_elevator_penalty() {
  _impl_._oneof_case_[71] = kElevatorPenalty;
}
inline void Costing_Options::clear_elevator_penalty() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_elevator_penalty_case() == kElevatorPenalty) {
    _impl_.has_elevator_penalty_.elevator_penalty_ = 0;
    clear_has_has_elevator_penalty();
  }
}
inline float Costing_Options::elevator_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.elevator_penalty)
  return _internal_elevator_penalty();
}
inline void Costing_Options::set_elevator_penalty(float value) {
  _internal_set_elevator_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.elevator_penalty)
}
inline float Costing_Options::_internal_elevator_penalty() const {
  if (has_elevator_penalty_case() == kElevatorPenalty) {
    return _impl_.has_elevator_penalty_.elevator_penalty_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_elevator_penalty(float value) {
  if (has_elevator_penalty_case() != kElevatorPenalty) {
    clear_has_elevator_penalty();
    set_has_elevator_penalty();
  }
  _impl_.has_elevator_penalty_.elevator_penalty_ = value;
}

// uint32 fixed_speed = 80;
inline void Costing_Options::clear_fixed_speed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fixed_speed_ = 0u;
}
inline ::uint32_t Costing_Options::fixed_speed() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.fixed_speed)
  return _internal_fixed_speed();
}
inline void Costing_Options::set_fixed_speed(::uint32_t value) {
  _internal_set_fixed_speed(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.fixed_speed)
}
inline ::uint32_t Costing_Options::_internal_fixed_speed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fixed_speed_;
}
inline void Costing_Options::_internal_set_fixed_speed(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fixed_speed_ = value;
}

// uint32 axle_count = 81;
inline void Costing_Options::clear_axle_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.axle_count_ = 0u;
}
inline ::uint32_t Costing_Options::axle_count() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.axle_count)
  return _internal_axle_count();
}
inline void Costing_Options::set_axle_count(::uint32_t value) {
  _internal_set_axle_count(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.axle_count)
}
inline ::uint32_t Costing_Options::_internal_axle_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.axle_count_;
}
inline void Costing_Options::_internal_set_axle_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.axle_count_ = value;
}

// float use_lit = 82;
inline void Costing_Options::clear_use_lit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_lit_ = 0;
}
inline float Costing_Options::use_lit() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.use_lit)
  return _internal_use_lit();
}
inline void Costing_Options::set_use_lit(float value) {
  _internal_set_use_lit(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.use_lit)
}
inline float Costing_Options::_internal_use_lit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_lit_;
}
inline void Costing_Options::_internal_set_use_lit(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.use_lit_ = value;
}

// bool disable_hierarchy_pruning = 83;
inline void Costing_Options::clear_disable_hierarchy_pruning() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.disable_hierarchy_pruning_ = false;
}
inline bool Costing_Options::disable_hierarchy_pruning() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.disable_hierarchy_pruning)
  return _internal_disable_hierarchy_pruning();
}
inline void Costing_Options::set_disable_hierarchy_pruning(bool value) {
  _internal_set_disable_hierarchy_pruning(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.disable_hierarchy_pruning)
}
inline bool Costing_Options::_internal_disable_hierarchy_pruning() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.disable_hierarchy_pruning_;
}
inline void Costing_Options::_internal_set_disable_hierarchy_pruning(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.disable_hierarchy_pruning_ = value;
}

// bool ignore_non_vehicular_restrictions = 84;
inline void Costing_Options::clear_ignore_non_vehicular_restrictions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ignore_non_vehicular_restrictions_ = false;
}
inline bool Costing_Options::ignore_non_vehicular_restrictions() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.ignore_non_vehicular_restrictions)
  return _internal_ignore_non_vehicular_restrictions();
}
inline void Costing_Options::set_ignore_non_vehicular_restrictions(bool value) {
  _internal_set_ignore_non_vehicular_restrictions(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.ignore_non_vehicular_restrictions)
}
inline bool Costing_Options::_internal_ignore_non_vehicular_restrictions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ignore_non_vehicular_restrictions_;
}
inline void Costing_Options::_internal_set_ignore_non_vehicular_restrictions(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ignore_non_vehicular_restrictions_ = value;
}

// float hgv_no_access_penalty = 85;
inline bool Costing_Options::has_hgv_no_access_penalty() const {
  return has_hgv_no_access_penalty_case() == kHgvNoAccessPenalty;
}
inline void Costing_Options::set_has_hgv_no_access_penalty() {
  _impl_._oneof_case_[72] = kHgvNoAccessPenalty;
}
inline void Costing_Options::clear_hgv_no_access_penalty() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_hgv_no_access_penalty_case() == kHgvNoAccessPenalty) {
    _impl_.has_hgv_no_access_penalty_.hgv_no_access_penalty_ = 0;
    clear_has_has_hgv_no_access_penalty();
  }
}
inline float Costing_Options::hgv_no_access_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.hgv_no_access_penalty)
  return _internal_hgv_no_access_penalty();
}
inline void Costing_Options::set_hgv_no_access_penalty(float value) {
  _internal_set_hgv_no_access_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.hgv_no_access_penalty)
}
inline float Costing_Options::_internal_hgv_no_access_penalty() const {
  if (has_hgv_no_access_penalty_case() == kHgvNoAccessPenalty) {
    return _impl_.has_hgv_no_access_penalty_.hgv_no_access_penalty_;
  }
  return 0;
}
inline void Costing_Options::_internal_set_hgv_no_access_penalty(float value) {
  if (has_hgv_no_access_penalty_case() != kHgvNoAccessPenalty) {
    clear_has_hgv_no_access_penalty();
    set_has_hgv_no_access_penalty();
  }
  _impl_.has_hgv_no_access_penalty_.hgv_no_access_penalty_ = value;
}

// float use_truck_route = 86;
inline void Costing_Options::clear_use_truck_route() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_truck_route_ = 0;
}
inline float Costing_Options::use_truck_route() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.Options.use_truck_route)
  return _internal_use_truck_route();
}
inline void Costing_Options::set_use_truck_route(float value) {
  _internal_set_use_truck_route(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.Options.use_truck_route)
}
inline float Costing_Options::_internal_use_truck_route() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_truck_route_;
}
inline void Costing_Options::_internal_set_use_truck_route(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.use_truck_route_ = value;
}

inline bool Costing_Options::has_has_maneuver_penalty() const {
  return has_maneuver_penalty_case() != HAS_MANEUVER_PENALTY_NOT_SET;
}
inline void Costing_Options::clear_has_has_maneuver_penalty() {
  _impl_._oneof_case_[0] = HAS_MANEUVER_PENALTY_NOT_SET;
}
inline bool Costing_Options::has_has_destination_only_penalty() const {
  return has_destination_only_penalty_case() != HAS_DESTINATION_ONLY_PENALTY_NOT_SET;
}
inline void Costing_Options::clear_has_has_destination_only_penalty() {
  _impl_._oneof_case_[1] = HAS_DESTINATION_ONLY_PENALTY_NOT_SET;
}
inline bool Costing_Options::has_has_gate_cost() const {
  return has_gate_cost_case() != HAS_GATE_COST_NOT_SET;
}
inline void Costing_Options::clear_has_has_gate_cost() {
  _impl_._oneof_case_[2] = HAS_GATE_COST_NOT_SET;
}
inline bool Costing_Options::has_has_gate_penalty() const {
  return has_gate_penalty_case() != HAS_GATE_PENALTY_NOT_SET;
}
inline void Costing_Options::clear_has_has_gate_penalty() {
  _impl_._oneof_case_[3] = HAS_GATE_PENALTY_NOT_SET;
}
inline bool Costing_Options::has_has_toll_booth_cost() const {
  return has_toll_booth_cost_case() != HAS_TOLL_BOOTH_COST_NOT_SET;
}
inline void Costing_Options::clear_has_has_toll_booth_cost() {
  _impl_._oneof_case_[4] = HAS_TOLL_BOOTH_COST_NOT_SET;
}
inline bool Costing_Options::has_has_toll_booth_penalty() const {
  return has_toll_booth_penalty_case() != HAS_TOLL_BOOTH_PENALTY_NOT_SET;
}
inline void Costing_Options::clear_has_has_toll_booth_penalty() {
  _impl_._oneof_case_[5] = HAS_TOLL_BOOTH_PENALTY_NOT_SET;
}
inline bool Costing_Options::has_has_alley_penalty() const {
  return has_alley_penalty_case() != HAS_ALLEY_PENALTY_NOT_SET;
}
inline void Costing_Options::clear_has_has_alley_penalty() {
  _impl_._oneof_case_[6] = HAS_ALLEY_PENALTY_NOT_SET;
}
inline bool Costing_Options::has_has_country_crossing_cost() const {
  return has_country_crossing_cost_case() != HAS_COUNTRY_CROSSING_COST_NOT_SET;
}
inline void Costing_Options::clear_has_has_country_crossing_cost() {
  _impl_._oneof_case_[7] = HAS_COUNTRY_CROSSING_COST_NOT_SET;
}
inline bool Costing_Options::has_has_country_crossing_penalty() const {
  return has_country_crossing_penalty_case() != HAS_COUNTRY_CROSSING_PENALTY_NOT_SET;
}
inline void Costing_Options::clear_has_has_country_crossing_penalty() {
  _impl_._oneof_case_[8] = HAS_COUNTRY_CROSSING_PENALTY_NOT_SET;
}
inline bool Costing_Options::has_has_ferry_cost() const {
  return has_ferry_cost_case() != HAS_FERRY_COST_NOT_SET;
}
inline void Costing_Options::clear_has_has_ferry_cost() {
  _impl_._oneof_case_[9] = HAS_FERRY_COST_NOT_SET;
}
inline bool Costing_Options::has_has_avoid_bad_surfaces() const {
  return has_avoid_bad_surfaces_case() != HAS_AVOID_BAD_SURFACES_NOT_SET;
}
inline void Costing_Options::clear_has_has_avoid_bad_surfaces() {
  _impl_._oneof_case_[10] = HAS_AVOID_BAD_SURFACES_NOT_SET;
}
inline bool Costing_Options::has_has_use_ferry() const {
  return has_use_ferry_case() != HAS_USE_FERRY_NOT_SET;
}
inline void Costing_Options::clear_has_has_use_ferry() {
  _impl_._oneof_case_[11] = HAS_USE_FERRY_NOT_SET;
}
inline bool Costing_Options::has_has_use_highways() const {
  return has_use_highways_case() != HAS_USE_HIGHWAYS_NOT_SET;
}
inline void Costing_Options::clear_has_has_use_highways() {
  _impl_._oneof_case_[12] = HAS_USE_HIGHWAYS_NOT_SET;
}
inline bool Costing_Options::has_has_use_tolls() const {
  return has_use_tolls_case() != HAS_USE_TOLLS_NOT_SET;
}
inline void Costing_Options::clear_has_has_use_tolls() {
  _impl_._oneof_case_[13] = HAS_USE_TOLLS_NOT_SET;
}
inline bool Costing_Options::has_has_use_roads() const {
  return has_use_roads_case() != HAS_USE_ROADS_NOT_SET;
}
inline void Costing_Options::clear_has_has_use_roads() {
  _impl_._oneof_case_[14] = HAS_USE_ROADS_NOT_SET;
}
inline bool Costing_Options::has_has_max_distance() const {
  return has_max_distance_case() != HAS_MAX_DISTANCE_NOT_SET;
}
inline void Costing_Options::clear_has_has_max_distance() {
  _impl_._oneof_case_[15] = HAS_MAX_DISTANCE_NOT_SET;
}
inline bool Costing_Options::has_has_walking_speed() const {
  return has_walking_speed_case() != HAS_WALKING_SPEED_NOT_SET;
}
inline void Costing_Options::clear_has_has_walking_speed() {
  _impl_._oneof_case_[16] = HAS_WALKING_SPEED_NOT_SET;
}
inline bool Costing_Options::has_has_step_penalty() const {
  return has_step_penalty_case() != HAS_STEP_PENALTY_NOT_SET;
}
inline void Costing_Options::clear_has_has_step_penalty() {
  _impl_._oneof_case_[17] = HAS_STEP_PENALTY_NOT_SET;
}
inline bool Costing_Options::has_has_max_grade() const {
  return has_max_grade_case() != HAS_MAX_GRADE_NOT_SET;
}
inline void Costing_Options::clear_has_has_max_grade() {
  _impl_._oneof_case_[18] = HAS_MAX_GRADE_NOT_SET;
}
inline bool Costing_Options::has_has_max_hiking_difficulty() const {
  return has_max_hiking_difficulty_case() != HAS_MAX_HIKING_DIFFICULTY_NOT_SET;
}
inline void Costing_Options::clear_has_has_max_hiking_difficulty() {
  _impl_._oneof_case_[19] = HAS_MAX_HIKING_DIFFICULTY_NOT_SET;
}
inline bool Costing_Options::has_has_mode_factor() const {
  return has_mode_factor_case() != HAS_MODE_FACTOR_NOT_SET;
}
inline void Costing_Options::clear_has_has_mode_factor() {
  _impl_._oneof_case_[20] = HAS_MODE_FACTOR_NOT_SET;
}
inline bool Costing_Options::has_has_walkway_factor() const {
  return has_walkway_factor_case() != HAS_WALKWAY_FACTOR_NOT_SET;
}
inline void Costing_Options::clear_has_has_walkway_factor() {
  _impl_._oneof_case_[21] = HAS_WALKWAY_FACTOR_NOT_SET;
}
inline bool Costing_Options::has_has_sidewalk_factor() const {
  return has_sidewalk_factor_case() != HAS_SIDEWALK_FACTOR_NOT_SET;
}
inline void Costing_Options::clear_has_has_sidewalk_factor() {
  _impl_._oneof_case_[22] = HAS_SIDEWALK_FACTOR_NOT_SET;
}
inline bool Costing_Options::has_has_alley_factor() const {
  return has_alley_factor_case() != HAS_ALLEY_FACTOR_NOT_SET;
}
inline void Costing_Options::clear_has_has_alley_factor() {
  _impl_._oneof_case_[23] = HAS_ALLEY_FACTOR_NOT_SET;
}
inline bool Costing_Options::has_has_driveway_factor() const {
  return has_driveway_factor_case() != HAS_DRIVEWAY_FACTOR_NOT_SET;
}
inline void Costing_Options::clear_has_has_driveway_factor() {
  _impl_._oneof_case_[24] = HAS_DRIVEWAY_FACTOR_NOT_SET;
}
inline bool Costing_Options::has_has_driveway_penalty() const {
  return has_driveway_penalty_case() != HAS_DRIVEWAY_PENALTY_NOT_SET;
}
inline void Costing_Options::clear_has_has_driveway_penalty() {
  _impl_._oneof_case_[25] = HAS_DRIVEWAY_PENALTY_NOT_SET;
}
inline bool Costing_Options::has_has_transit_start_end_max_distance() const {
  return has_transit_start_end_max_distance_case() != HAS_TRANSIT_START_END_MAX_DISTANCE_NOT_SET;
}
inline void Costing_Options::clear_has_has_transit_start_end_max_distance() {
  _impl_._oneof_case_[26] = HAS_TRANSIT_START_END_MAX_DISTANCE_NOT_SET;
}
inline bool Costing_Options::has_has_transit_transfer_max_distance() const {
  return has_transit_transfer_max_distance_case() != HAS_TRANSIT_TRANSFER_MAX_DISTANCE_NOT_SET;
}
inline void Costing_Options::clear_has_has_transit_transfer_max_distance() {
  _impl_._oneof_case_[27] = HAS_TRANSIT_TRANSFER_MAX_DISTANCE_NOT_SET;
}
inline bool Costing_Options::has_has_transport_type() const {
  return has_transport_type_case() != HAS_TRANSPORT_TYPE_NOT_SET;
}
inline void Costing_Options::clear_has_has_transport_type() {
  _impl_._oneof_case_[28] = HAS_TRANSPORT_TYPE_NOT_SET;
}
inline bool Costing_Options::has_has_top_speed() const {
  return has_top_speed_case() != HAS_TOP_SPEED_NOT_SET;
}
inline void Costing_Options::clear_has_has_top_speed() {
  _impl_._oneof_case_[29] = HAS_TOP_SPEED_NOT_SET;
}
inline bool Costing_Options::has_has_use_hills() const {
  return has_use_hills_case() != HAS_USE_HILLS_NOT_SET;
}
inline void Costing_Options::clear_has_has_use_hills() {
  _impl_._oneof_case_[30] = HAS_USE_HILLS_NOT_SET;
}
inline bool Costing_Options::has_has_use_primary() const {
  return has_use_primary_case() != HAS_USE_PRIMARY_NOT_SET;
}
inline void Costing_Options::clear_has_has_use_primary() {
  _impl_._oneof_case_[31] = HAS_USE_PRIMARY_NOT_SET;
}
inline bool Costing_Options::has_has_use_trails() const {
  return has_use_trails_case() != HAS_USE_TRAILS_NOT_SET;
}
inline void Costing_Options::clear_has_has_use_trails() {
  _impl_._oneof_case_[32] = HAS_USE_TRAILS_NOT_SET;
}
inline bool Costing_Options::has_has_low_class_penalty() const {
  return has_low_class_penalty_case() != HAS_LOW_CLASS_PENALTY_NOT_SET;
}
inline void Costing_Options::clear_has_has_low_class_penalty() {
  _impl_._oneof_case_[33] = HAS_LOW_CLASS_PENALTY_NOT_SET;
}
inline bool Costing_Options::has_has_hazmat() const {
  return has_hazmat_case() != HAS_HAZMAT_NOT_SET;
}
inline void Costing_Options::clear_has_has_hazmat() {
  _impl_._oneof_case_[34] = HAS_HAZMAT_NOT_SET;
}
inline bool Costing_Options::has_has_weight() const {
  return has_weight_case() != HAS_WEIGHT_NOT_SET;
}
inline void Costing_Options::clear_has_has_weight() {
  _impl_._oneof_case_[35] = HAS_WEIGHT_NOT_SET;
}
inline bool Costing_Options::has_has_axle_load() const {
  return has_axle_load_case() != HAS_AXLE_LOAD_NOT_SET;
}
inline void Costing_Options::clear_has_has_axle_load() {
  _impl_._oneof_case_[36] = HAS_AXLE_LOAD_NOT_SET;
}
inline bool Costing_Options::has_has_height() const {
  return has_height_case() != HAS_HEIGHT_NOT_SET;
}
inline void Costing_Options::clear_has_has_height() {
  _impl_._oneof_case_[37] = HAS_HEIGHT_NOT_SET;
}
inline bool Costing_Options::has_has_width() const {
  return has_width_case() != HAS_WIDTH_NOT_SET;
}
inline void Costing_Options::clear_has_has_width() {
  _impl_._oneof_case_[38] = HAS_WIDTH_NOT_SET;
}
inline bool Costing_Options::has_has_length() const {
  return has_length_case() != HAS_LENGTH_NOT_SET;
}
inline void Costing_Options::clear_has_has_length() {
  _impl_._oneof_case_[39] = HAS_LENGTH_NOT_SET;
}
inline bool Costing_Options::has_has_cycling_speed() const {
  return has_cycling_speed_case() != HAS_CYCLING_SPEED_NOT_SET;
}
inline void Costing_Options::clear_has_has_cycling_speed() {
  _impl_._oneof_case_[40] = HAS_CYCLING_SPEED_NOT_SET;
}
inline bool Costing_Options::has_has_wheelchair() const {
  return has_wheelchair_case() != HAS_WHEELCHAIR_NOT_SET;
}
inline void Costing_Options::clear_has_has_wheelchair() {
  _impl_._oneof_case_[41] = HAS_WHEELCHAIR_NOT_SET;
}
inline bool Costing_Options::has_has_bicycle() const {
  return has_bicycle_case() != HAS_BICYCLE_NOT_SET;
}
inline void Costing_Options::clear_has_has_bicycle() {
  _impl_._oneof_case_[42] = HAS_BICYCLE_NOT_SET;
}
inline bool Costing_Options::has_has_use_bus() const {
  return has_use_bus_case() != HAS_USE_BUS_NOT_SET;
}
inline void Costing_Options::clear_has_has_use_bus() {
  _impl_._oneof_case_[43] = HAS_USE_BUS_NOT_SET;
}
inline bool Costing_Options::has_has_use_rail() const {
  return has_use_rail_case() != HAS_USE_RAIL_NOT_SET;
}
inline void Costing_Options::clear_has_has_use_rail() {
  _impl_._oneof_case_[44] = HAS_USE_RAIL_NOT_SET;
}
inline bool Costing_Options::has_has_use_transfers() const {
  return has_use_transfers_case() != HAS_USE_TRANSFERS_NOT_SET;
}
inline void Costing_Options::clear_has_has_use_transfers() {
  _impl_._oneof_case_[45] = HAS_USE_TRANSFERS_NOT_SET;
}
inline bool Costing_Options::has_has_transfer_cost() const {
  return has_transfer_cost_case() != HAS_TRANSFER_COST_NOT_SET;
}
inline void Costing_Options::clear_has_has_transfer_cost() {
  _impl_._oneof_case_[46] = HAS_TRANSFER_COST_NOT_SET;
}
inline bool Costing_Options::has_has_transfer_penalty() const {
  return has_transfer_penalty_case() != HAS_TRANSFER_PENALTY_NOT_SET;
}
inline void Costing_Options::clear_has_has_transfer_penalty() {
  _impl_._oneof_case_[47] = HAS_TRANSFER_PENALTY_NOT_SET;
}
inline bool Costing_Options::has_has_flow_mask() const {
  return has_flow_mask_case() != HAS_FLOW_MASK_NOT_SET;
}
inline void Costing_Options::clear_has_has_flow_mask() {
  _impl_._oneof_case_[48] = HAS_FLOW_MASK_NOT_SET;
}
inline bool Costing_Options::has_has_bike_share_cost() const {
  return has_bike_share_cost_case() != HAS_BIKE_SHARE_COST_NOT_SET;
}
inline void Costing_Options::clear_has_has_bike_share_cost() {
  _impl_._oneof_case_[49] = HAS_BIKE_SHARE_COST_NOT_SET;
}
inline bool Costing_Options::has_has_bike_share_penalty() const {
  return has_bike_share_penalty_case() != HAS_BIKE_SHARE_PENALTY_NOT_SET;
}
inline void Costing_Options::clear_has_has_bike_share_penalty() {
  _impl_._oneof_case_[50] = HAS_BIKE_SHARE_PENALTY_NOT_SET;
}
inline bool Costing_Options::has_has_rail_ferry_cost() const {
  return has_rail_ferry_cost_case() != HAS_RAIL_FERRY_COST_NOT_SET;
}
inline void Costing_Options::clear_has_has_rail_ferry_cost() {
  _impl_._oneof_case_[51] = HAS_RAIL_FERRY_COST_NOT_SET;
}
inline bool Costing_Options::has_has_use_rail_ferry() const {
  return has_use_rail_ferry_case() != HAS_USE_RAIL_FERRY_NOT_SET;
}
inline void Costing_Options::clear_has_has_use_rail_ferry() {
  _impl_._oneof_case_[52] = HAS_USE_RAIL_FERRY_NOT_SET;
}
inline bool Costing_Options::has_has_ignore_restrictions() const {
  return has_ignore_restrictions_case() != HAS_IGNORE_RESTRICTIONS_NOT_SET;
}
inline void Costing_Options::clear_has_has_ignore_restrictions() {
  _impl_._oneof_case_[53] = HAS_IGNORE_RESTRICTIONS_NOT_SET;
}
inline bool Costing_Options::has_has_ignore_oneways() const {
  return has_ignore_oneways_case() != HAS_IGNORE_ONEWAYS_NOT_SET;
}
inline void Costing_Options::clear_has_has_ignore_oneways() {
  _impl_._oneof_case_[54] = HAS_IGNORE_ONEWAYS_NOT_SET;
}
inline bool Costing_Options::has_has_ignore_access() const {
  return has_ignore_access_case() != HAS_IGNORE_ACCESS_NOT_SET;
}
inline void Costing_Options::clear_has_has_ignore_access() {
  _impl_._oneof_case_[55] = HAS_IGNORE_ACCESS_NOT_SET;
}
inline bool Costing_Options::has_has_ignore_closures() const {
  return has_ignore_closures_case() != HAS_IGNORE_CLOSURES_NOT_SET;
}
inline void Costing_Options::clear_has_has_ignore_closures() {
  _impl_._oneof_case_[56] = HAS_IGNORE_CLOSURES_NOT_SET;
}
inline bool Costing_Options::has_has_shortest() const {
  return has_shortest_case() != HAS_SHORTEST_NOT_SET;
}
inline void Costing_Options::clear_has_has_shortest() {
  _impl_._oneof_case_[57] = HAS_SHORTEST_NOT_SET;
}
inline bool Costing_Options::has_has_service_penalty() const {
  return has_service_penalty_case() != HAS_SERVICE_PENALTY_NOT_SET;
}
inline void Costing_Options::clear_has_has_service_penalty() {
  _impl_._oneof_case_[58] = HAS_SERVICE_PENALTY_NOT_SET;
}
inline bool Costing_Options::has_has_use_tracks() const {
  return has_use_tracks_case() != HAS_USE_TRACKS_NOT_SET;
}
inline void Costing_Options::clear_has_has_use_tracks() {
  _impl_._oneof_case_[59] = HAS_USE_TRACKS_NOT_SET;
}
inline bool Costing_Options::has_has_use_distance() const {
  return has_use_distance_case() != HAS_USE_DISTANCE_NOT_SET;
}
inline void Costing_Options::clear_has_has_use_distance() {
  _impl_._oneof_case_[60] = HAS_USE_DISTANCE_NOT_SET;
}
inline bool Costing_Options::has_has_use_living_streets() const {
  return has_use_living_streets_case() != HAS_USE_LIVING_STREETS_NOT_SET;
}
inline void Costing_Options::clear_has_has_use_living_streets() {
  _impl_._oneof_case_[61] = HAS_USE_LIVING_STREETS_NOT_SET;
}
inline bool Costing_Options::has_has_service_factor() const {
  return has_service_factor_case() != HAS_SERVICE_FACTOR_NOT_SET;
}
inline void Costing_Options::clear_has_has_service_factor() {
  _impl_._oneof_case_[62] = HAS_SERVICE_FACTOR_NOT_SET;
}
inline bool Costing_Options::has_has_closure_factor() const {
  return has_closure_factor_case() != HAS_CLOSURE_FACTOR_NOT_SET;
}
inline void Costing_Options::clear_has_has_closure_factor() {
  _impl_._oneof_case_[63] = HAS_CLOSURE_FACTOR_NOT_SET;
}
inline bool Costing_Options::has_has_private_access_penalty() const {
  return has_private_access_penalty_case() != HAS_PRIVATE_ACCESS_PENALTY_NOT_SET;
}
inline void Costing_Options::clear_has_has_private_access_penalty() {
  _impl_._oneof_case_[64] = HAS_PRIVATE_ACCESS_PENALTY_NOT_SET;
}
inline bool Costing_Options::has_has_exclude_unpaved() const {
  return has_exclude_unpaved_case() != HAS_EXCLUDE_UNPAVED_NOT_SET;
}
inline void Costing_Options::clear_has_has_exclude_unpaved() {
  _impl_._oneof_case_[65] = HAS_EXCLUDE_UNPAVED_NOT_SET;
}
inline bool Costing_Options::has_has_include_hot() const {
  return has_include_hot_case() != HAS_INCLUDE_HOT_NOT_SET;
}
inline void Costing_Options::clear_has_has_include_hot() {
  _impl_._oneof_case_[66] = HAS_INCLUDE_HOT_NOT_SET;
}
inline bool Costing_Options::has_has_include_hov2() const {
  return has_include_hov2_case() != HAS_INCLUDE_HOV2_NOT_SET;
}
inline void Costing_Options::clear_has_has_include_hov2() {
  _impl_._oneof_case_[67] = HAS_INCLUDE_HOV2_NOT_SET;
}
inline bool Costing_Options::has_has_include_hov3() const {
  return has_include_hov3_case() != HAS_INCLUDE_HOV3_NOT_SET;
}
inline void Costing_Options::clear_has_has_include_hov3() {
  _impl_._oneof_case_[68] = HAS_INCLUDE_HOV3_NOT_SET;
}
inline bool Costing_Options::has_has_exclude_cash_only_tolls() const {
  return has_exclude_cash_only_tolls_case() != HAS_EXCLUDE_CASH_ONLY_TOLLS_NOT_SET;
}
inline void Costing_Options::clear_has_has_exclude_cash_only_tolls() {
  _impl_._oneof_case_[69] = HAS_EXCLUDE_CASH_ONLY_TOLLS_NOT_SET;
}
inline bool Costing_Options::has_has_restriction_probability() const {
  return has_restriction_probability_case() != HAS_RESTRICTION_PROBABILITY_NOT_SET;
}
inline void Costing_Options::clear_has_has_restriction_probability() {
  _impl_._oneof_case_[70] = HAS_RESTRICTION_PROBABILITY_NOT_SET;
}
inline bool Costing_Options::has_has_elevator_penalty() const {
  return has_elevator_penalty_case() != HAS_ELEVATOR_PENALTY_NOT_SET;
}
inline void Costing_Options::clear_has_has_elevator_penalty() {
  _impl_._oneof_case_[71] = HAS_ELEVATOR_PENALTY_NOT_SET;
}
inline bool Costing_Options::has_has_hgv_no_access_penalty() const {
  return has_hgv_no_access_penalty_case() != HAS_HGV_NO_ACCESS_PENALTY_NOT_SET;
}
inline void Costing_Options::clear_has_has_hgv_no_access_penalty() {
  _impl_._oneof_case_[72] = HAS_HGV_NO_ACCESS_PENALTY_NOT_SET;
}
inline Costing_Options::HasManeuverPenaltyCase Costing_Options::has_maneuver_penalty_case() const {
  return Costing_Options::HasManeuverPenaltyCase(_impl_._oneof_case_[0]);
}
inline Costing_Options::HasDestinationOnlyPenaltyCase Costing_Options::has_destination_only_penalty_case() const {
  return Costing_Options::HasDestinationOnlyPenaltyCase(_impl_._oneof_case_[1]);
}
inline Costing_Options::HasGateCostCase Costing_Options::has_gate_cost_case() const {
  return Costing_Options::HasGateCostCase(_impl_._oneof_case_[2]);
}
inline Costing_Options::HasGatePenaltyCase Costing_Options::has_gate_penalty_case() const {
  return Costing_Options::HasGatePenaltyCase(_impl_._oneof_case_[3]);
}
inline Costing_Options::HasTollBoothCostCase Costing_Options::has_toll_booth_cost_case() const {
  return Costing_Options::HasTollBoothCostCase(_impl_._oneof_case_[4]);
}
inline Costing_Options::HasTollBoothPenaltyCase Costing_Options::has_toll_booth_penalty_case() const {
  return Costing_Options::HasTollBoothPenaltyCase(_impl_._oneof_case_[5]);
}
inline Costing_Options::HasAlleyPenaltyCase Costing_Options::has_alley_penalty_case() const {
  return Costing_Options::HasAlleyPenaltyCase(_impl_._oneof_case_[6]);
}
inline Costing_Options::HasCountryCrossingCostCase Costing_Options::has_country_crossing_cost_case() const {
  return Costing_Options::HasCountryCrossingCostCase(_impl_._oneof_case_[7]);
}
inline Costing_Options::HasCountryCrossingPenaltyCase Costing_Options::has_country_crossing_penalty_case() const {
  return Costing_Options::HasCountryCrossingPenaltyCase(_impl_._oneof_case_[8]);
}
inline Costing_Options::HasFerryCostCase Costing_Options::has_ferry_cost_case() const {
  return Costing_Options::HasFerryCostCase(_impl_._oneof_case_[9]);
}
inline Costing_Options::HasAvoidBadSurfacesCase Costing_Options::has_avoid_bad_surfaces_case() const {
  return Costing_Options::HasAvoidBadSurfacesCase(_impl_._oneof_case_[10]);
}
inline Costing_Options::HasUseFerryCase Costing_Options::has_use_ferry_case() const {
  return Costing_Options::HasUseFerryCase(_impl_._oneof_case_[11]);
}
inline Costing_Options::HasUseHighwaysCase Costing_Options::has_use_highways_case() const {
  return Costing_Options::HasUseHighwaysCase(_impl_._oneof_case_[12]);
}
inline Costing_Options::HasUseTollsCase Costing_Options::has_use_tolls_case() const {
  return Costing_Options::HasUseTollsCase(_impl_._oneof_case_[13]);
}
inline Costing_Options::HasUseRoadsCase Costing_Options::has_use_roads_case() const {
  return Costing_Options::HasUseRoadsCase(_impl_._oneof_case_[14]);
}
inline Costing_Options::HasMaxDistanceCase Costing_Options::has_max_distance_case() const {
  return Costing_Options::HasMaxDistanceCase(_impl_._oneof_case_[15]);
}
inline Costing_Options::HasWalkingSpeedCase Costing_Options::has_walking_speed_case() const {
  return Costing_Options::HasWalkingSpeedCase(_impl_._oneof_case_[16]);
}
inline Costing_Options::HasStepPenaltyCase Costing_Options::has_step_penalty_case() const {
  return Costing_Options::HasStepPenaltyCase(_impl_._oneof_case_[17]);
}
inline Costing_Options::HasMaxGradeCase Costing_Options::has_max_grade_case() const {
  return Costing_Options::HasMaxGradeCase(_impl_._oneof_case_[18]);
}
inline Costing_Options::HasMaxHikingDifficultyCase Costing_Options::has_max_hiking_difficulty_case() const {
  return Costing_Options::HasMaxHikingDifficultyCase(_impl_._oneof_case_[19]);
}
inline Costing_Options::HasModeFactorCase Costing_Options::has_mode_factor_case() const {
  return Costing_Options::HasModeFactorCase(_impl_._oneof_case_[20]);
}
inline Costing_Options::HasWalkwayFactorCase Costing_Options::has_walkway_factor_case() const {
  return Costing_Options::HasWalkwayFactorCase(_impl_._oneof_case_[21]);
}
inline Costing_Options::HasSidewalkFactorCase Costing_Options::has_sidewalk_factor_case() const {
  return Costing_Options::HasSidewalkFactorCase(_impl_._oneof_case_[22]);
}
inline Costing_Options::HasAlleyFactorCase Costing_Options::has_alley_factor_case() const {
  return Costing_Options::HasAlleyFactorCase(_impl_._oneof_case_[23]);
}
inline Costing_Options::HasDrivewayFactorCase Costing_Options::has_driveway_factor_case() const {
  return Costing_Options::HasDrivewayFactorCase(_impl_._oneof_case_[24]);
}
inline Costing_Options::HasDrivewayPenaltyCase Costing_Options::has_driveway_penalty_case() const {
  return Costing_Options::HasDrivewayPenaltyCase(_impl_._oneof_case_[25]);
}
inline Costing_Options::HasTransitStartEndMaxDistanceCase Costing_Options::has_transit_start_end_max_distance_case() const {
  return Costing_Options::HasTransitStartEndMaxDistanceCase(_impl_._oneof_case_[26]);
}
inline Costing_Options::HasTransitTransferMaxDistanceCase Costing_Options::has_transit_transfer_max_distance_case() const {
  return Costing_Options::HasTransitTransferMaxDistanceCase(_impl_._oneof_case_[27]);
}
inline Costing_Options::HasTransportTypeCase Costing_Options::has_transport_type_case() const {
  return Costing_Options::HasTransportTypeCase(_impl_._oneof_case_[28]);
}
inline Costing_Options::HasTopSpeedCase Costing_Options::has_top_speed_case() const {
  return Costing_Options::HasTopSpeedCase(_impl_._oneof_case_[29]);
}
inline Costing_Options::HasUseHillsCase Costing_Options::has_use_hills_case() const {
  return Costing_Options::HasUseHillsCase(_impl_._oneof_case_[30]);
}
inline Costing_Options::HasUsePrimaryCase Costing_Options::has_use_primary_case() const {
  return Costing_Options::HasUsePrimaryCase(_impl_._oneof_case_[31]);
}
inline Costing_Options::HasUseTrailsCase Costing_Options::has_use_trails_case() const {
  return Costing_Options::HasUseTrailsCase(_impl_._oneof_case_[32]);
}
inline Costing_Options::HasLowClassPenaltyCase Costing_Options::has_low_class_penalty_case() const {
  return Costing_Options::HasLowClassPenaltyCase(_impl_._oneof_case_[33]);
}
inline Costing_Options::HasHazmatCase Costing_Options::has_hazmat_case() const {
  return Costing_Options::HasHazmatCase(_impl_._oneof_case_[34]);
}
inline Costing_Options::HasWeightCase Costing_Options::has_weight_case() const {
  return Costing_Options::HasWeightCase(_impl_._oneof_case_[35]);
}
inline Costing_Options::HasAxleLoadCase Costing_Options::has_axle_load_case() const {
  return Costing_Options::HasAxleLoadCase(_impl_._oneof_case_[36]);
}
inline Costing_Options::HasHeightCase Costing_Options::has_height_case() const {
  return Costing_Options::HasHeightCase(_impl_._oneof_case_[37]);
}
inline Costing_Options::HasWidthCase Costing_Options::has_width_case() const {
  return Costing_Options::HasWidthCase(_impl_._oneof_case_[38]);
}
inline Costing_Options::HasLengthCase Costing_Options::has_length_case() const {
  return Costing_Options::HasLengthCase(_impl_._oneof_case_[39]);
}
inline Costing_Options::HasCyclingSpeedCase Costing_Options::has_cycling_speed_case() const {
  return Costing_Options::HasCyclingSpeedCase(_impl_._oneof_case_[40]);
}
inline Costing_Options::HasWheelchairCase Costing_Options::has_wheelchair_case() const {
  return Costing_Options::HasWheelchairCase(_impl_._oneof_case_[41]);
}
inline Costing_Options::HasBicycleCase Costing_Options::has_bicycle_case() const {
  return Costing_Options::HasBicycleCase(_impl_._oneof_case_[42]);
}
inline Costing_Options::HasUseBusCase Costing_Options::has_use_bus_case() const {
  return Costing_Options::HasUseBusCase(_impl_._oneof_case_[43]);
}
inline Costing_Options::HasUseRailCase Costing_Options::has_use_rail_case() const {
  return Costing_Options::HasUseRailCase(_impl_._oneof_case_[44]);
}
inline Costing_Options::HasUseTransfersCase Costing_Options::has_use_transfers_case() const {
  return Costing_Options::HasUseTransfersCase(_impl_._oneof_case_[45]);
}
inline Costing_Options::HasTransferCostCase Costing_Options::has_transfer_cost_case() const {
  return Costing_Options::HasTransferCostCase(_impl_._oneof_case_[46]);
}
inline Costing_Options::HasTransferPenaltyCase Costing_Options::has_transfer_penalty_case() const {
  return Costing_Options::HasTransferPenaltyCase(_impl_._oneof_case_[47]);
}
inline Costing_Options::HasFlowMaskCase Costing_Options::has_flow_mask_case() const {
  return Costing_Options::HasFlowMaskCase(_impl_._oneof_case_[48]);
}
inline Costing_Options::HasBikeShareCostCase Costing_Options::has_bike_share_cost_case() const {
  return Costing_Options::HasBikeShareCostCase(_impl_._oneof_case_[49]);
}
inline Costing_Options::HasBikeSharePenaltyCase Costing_Options::has_bike_share_penalty_case() const {
  return Costing_Options::HasBikeSharePenaltyCase(_impl_._oneof_case_[50]);
}
inline Costing_Options::HasRailFerryCostCase Costing_Options::has_rail_ferry_cost_case() const {
  return Costing_Options::HasRailFerryCostCase(_impl_._oneof_case_[51]);
}
inline Costing_Options::HasUseRailFerryCase Costing_Options::has_use_rail_ferry_case() const {
  return Costing_Options::HasUseRailFerryCase(_impl_._oneof_case_[52]);
}
inline Costing_Options::HasIgnoreRestrictionsCase Costing_Options::has_ignore_restrictions_case() const {
  return Costing_Options::HasIgnoreRestrictionsCase(_impl_._oneof_case_[53]);
}
inline Costing_Options::HasIgnoreOnewaysCase Costing_Options::has_ignore_oneways_case() const {
  return Costing_Options::HasIgnoreOnewaysCase(_impl_._oneof_case_[54]);
}
inline Costing_Options::HasIgnoreAccessCase Costing_Options::has_ignore_access_case() const {
  return Costing_Options::HasIgnoreAccessCase(_impl_._oneof_case_[55]);
}
inline Costing_Options::HasIgnoreClosuresCase Costing_Options::has_ignore_closures_case() const {
  return Costing_Options::HasIgnoreClosuresCase(_impl_._oneof_case_[56]);
}
inline Costing_Options::HasShortestCase Costing_Options::has_shortest_case() const {
  return Costing_Options::HasShortestCase(_impl_._oneof_case_[57]);
}
inline Costing_Options::HasServicePenaltyCase Costing_Options::has_service_penalty_case() const {
  return Costing_Options::HasServicePenaltyCase(_impl_._oneof_case_[58]);
}
inline Costing_Options::HasUseTracksCase Costing_Options::has_use_tracks_case() const {
  return Costing_Options::HasUseTracksCase(_impl_._oneof_case_[59]);
}
inline Costing_Options::HasUseDistanceCase Costing_Options::has_use_distance_case() const {
  return Costing_Options::HasUseDistanceCase(_impl_._oneof_case_[60]);
}
inline Costing_Options::HasUseLivingStreetsCase Costing_Options::has_use_living_streets_case() const {
  return Costing_Options::HasUseLivingStreetsCase(_impl_._oneof_case_[61]);
}
inline Costing_Options::HasServiceFactorCase Costing_Options::has_service_factor_case() const {
  return Costing_Options::HasServiceFactorCase(_impl_._oneof_case_[62]);
}
inline Costing_Options::HasClosureFactorCase Costing_Options::has_closure_factor_case() const {
  return Costing_Options::HasClosureFactorCase(_impl_._oneof_case_[63]);
}
inline Costing_Options::HasPrivateAccessPenaltyCase Costing_Options::has_private_access_penalty_case() const {
  return Costing_Options::HasPrivateAccessPenaltyCase(_impl_._oneof_case_[64]);
}
inline Costing_Options::HasExcludeUnpavedCase Costing_Options::has_exclude_unpaved_case() const {
  return Costing_Options::HasExcludeUnpavedCase(_impl_._oneof_case_[65]);
}
inline Costing_Options::HasIncludeHotCase Costing_Options::has_include_hot_case() const {
  return Costing_Options::HasIncludeHotCase(_impl_._oneof_case_[66]);
}
inline Costing_Options::HasIncludeHov2Case Costing_Options::has_include_hov2_case() const {
  return Costing_Options::HasIncludeHov2Case(_impl_._oneof_case_[67]);
}
inline Costing_Options::HasIncludeHov3Case Costing_Options::has_include_hov3_case() const {
  return Costing_Options::HasIncludeHov3Case(_impl_._oneof_case_[68]);
}
inline Costing_Options::HasExcludeCashOnlyTollsCase Costing_Options::has_exclude_cash_only_tolls_case() const {
  return Costing_Options::HasExcludeCashOnlyTollsCase(_impl_._oneof_case_[69]);
}
inline Costing_Options::HasRestrictionProbabilityCase Costing_Options::has_restriction_probability_case() const {
  return Costing_Options::HasRestrictionProbabilityCase(_impl_._oneof_case_[70]);
}
inline Costing_Options::HasElevatorPenaltyCase Costing_Options::has_elevator_penalty_case() const {
  return Costing_Options::HasElevatorPenaltyCase(_impl_._oneof_case_[71]);
}
inline Costing_Options::HasHgvNoAccessPenaltyCase Costing_Options::has_hgv_no_access_penalty_case() const {
  return Costing_Options::HasHgvNoAccessPenaltyCase(_impl_._oneof_case_[72]);
}
// -------------------------------------------------------------------

// Costing

// .valhalla.Costing.Options options = 1;
inline bool Costing::has_options() const {
  return has_options_case() == kOptions;
}
inline bool Costing::_internal_has_options() const {
  return has_options_case() == kOptions;
}
inline void Costing::set_has_options() {
  _impl_._oneof_case_[0] = kOptions;
}
inline void Costing::clear_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_options_case() == kOptions) {
    if (GetArena() == nullptr) {
      delete _impl_.has_options_.options_;
    }
    clear_has_has_options();
  }
}
inline ::valhalla::Costing_Options* Costing::release_options() {
  // @@protoc_insertion_point(field_release:valhalla.Costing.options)
  if (has_options_case() == kOptions) {
    clear_has_has_options();
    auto* temp = _impl_.has_options_.options_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.has_options_.options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::valhalla::Costing_Options& Costing::_internal_options() const {
  return has_options_case() == kOptions ? *_impl_.has_options_.options_ : reinterpret_cast<::valhalla::Costing_Options&>(::valhalla::_Costing_Options_default_instance_);
}
inline const ::valhalla::Costing_Options& Costing::options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Costing.options)
  return _internal_options();
}
inline ::valhalla::Costing_Options* Costing::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_unsafe_arena_release:valhalla.Costing.options)
  if (has_options_case() == kOptions) {
    clear_has_has_options();
    auto* temp = _impl_.has_options_.options_;
    _impl_.has_options_.options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Costing::unsafe_arena_set_allocated_options(::valhalla::Costing_Options* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_has_options();
  if (value) {
    set_has_options();
    _impl_.has_options_.options_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.Costing.options)
}
inline ::valhalla::Costing_Options* Costing::_internal_mutable_options() {
  if (has_options_case() != kOptions) {
    clear_has_options();
    set_has_options();
    _impl_.has_options_.options_ = CreateMaybeMessage<::valhalla::Costing_Options>(GetArena());
  }
  return _impl_.has_options_.options_;
}
inline ::valhalla::Costing_Options* Costing::mutable_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::Costing_Options* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:valhalla.Costing.options)
  return _msg;
}

// .valhalla.Costing.Type type = 2;
inline void Costing::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::valhalla::Costing_Type Costing::type() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.type)
  return _internal_type();
}
inline void Costing::set_type(::valhalla::Costing_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.type)
}
inline ::valhalla::Costing_Type Costing::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::Costing_Type>(_impl_.type_);
}
inline void Costing::_internal_set_type(::valhalla::Costing_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// string name = 3;
inline bool Costing::has_name() const {
  return has_name_case() == kName;
}
inline void Costing::set_has_name() {
  _impl_._oneof_case_[1] = kName;
}
inline void Costing::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_name_case() == kName) {
    _impl_.has_name_.name_.Destroy();
    clear_has_has_name();
  }
}
inline const std::string& Costing::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Costing.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Costing::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_name_case() != kName) {
    clear_has_name();

    set_has_name();
    _impl_.has_name_.name_.InitDefault();
  }
  _impl_.has_name_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.Costing.name)
}
inline std::string* Costing::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:valhalla.Costing.name)
  return _s;
}
inline const std::string& Costing::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (has_name_case() != kName) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.has_name_.name_.Get();
}
inline void Costing::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_name_case() != kName) {
    clear_has_name();

    set_has_name();
    _impl_.has_name_.name_.InitDefault();
  }
  _impl_.has_name_.name_.Set(value, GetArena());
}
inline std::string* Costing::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_name_case() != kName) {
    clear_has_name();

    set_has_name();
    _impl_.has_name_.name_.InitDefault();
  }
  return _impl_.has_name_.name_.Mutable( GetArena());
}
inline std::string* Costing::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.Costing.name)
  if (has_name_case() != kName) {
    return nullptr;
  }
  clear_has_has_name();
  return _impl_.has_name_.name_.Release();
}
inline void Costing::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_has_name()) {
    clear_has_name();
  }
  if (value != nullptr) {
    set_has_name();
    _impl_.has_name_.name_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Costing.name)
}

// bool filter_closures = 4;
inline bool Costing::has_filter_closures() const {
  return has_filter_closures_case() == kFilterClosures;
}
inline void Costing::set_has_filter_closures() {
  _impl_._oneof_case_[2] = kFilterClosures;
}
inline void Costing::clear_filter_closures() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_filter_closures_case() == kFilterClosures) {
    _impl_.has_filter_closures_.filter_closures_ = false;
    clear_has_has_filter_closures();
  }
}
inline bool Costing::filter_closures() const {
  // @@protoc_insertion_point(field_get:valhalla.Costing.filter_closures)
  return _internal_filter_closures();
}
inline void Costing::set_filter_closures(bool value) {
  _internal_set_filter_closures(value);
  // @@protoc_insertion_point(field_set:valhalla.Costing.filter_closures)
}
inline bool Costing::_internal_filter_closures() const {
  if (has_filter_closures_case() == kFilterClosures) {
    return _impl_.has_filter_closures_.filter_closures_;
  }
  return false;
}
inline void Costing::_internal_set_filter_closures(bool value) {
  if (has_filter_closures_case() != kFilterClosures) {
    clear_has_filter_closures();
    set_has_filter_closures();
  }
  _impl_.has_filter_closures_.filter_closures_ = value;
}

inline bool Costing::has_has_options() const {
  return has_options_case() != HAS_OPTIONS_NOT_SET;
}
inline void Costing::clear_has_has_options() {
  _impl_._oneof_case_[0] = HAS_OPTIONS_NOT_SET;
}
inline bool Costing::has_has_name() const {
  return has_name_case() != HAS_NAME_NOT_SET;
}
inline void Costing::clear_has_has_name() {
  _impl_._oneof_case_[1] = HAS_NAME_NOT_SET;
}
inline bool Costing::has_has_filter_closures() const {
  return has_filter_closures_case() != HAS_FILTER_CLOSURES_NOT_SET;
}
inline void Costing::clear_has_has_filter_closures() {
  _impl_._oneof_case_[2] = HAS_FILTER_CLOSURES_NOT_SET;
}
inline Costing::HasOptionsCase Costing::has_options_case() const {
  return Costing::HasOptionsCase(_impl_._oneof_case_[0]);
}
inline Costing::HasNameCase Costing::has_name_case() const {
  return Costing::HasNameCase(_impl_._oneof_case_[1]);
}
inline Costing::HasFilterClosuresCase Costing::has_filter_closures_case() const {
  return Costing::HasFilterClosuresCase(_impl_._oneof_case_[2]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Options

// .valhalla.Options.Units units = 1;
inline void Options::clear_units() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.units_ = 0;
}
inline ::valhalla::Options_Units Options::units() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.units)
  return _internal_units();
}
inline void Options::set_units(::valhalla::Options_Units value) {
  _internal_set_units(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.units)
}
inline ::valhalla::Options_Units Options::_internal_units() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::Options_Units>(_impl_.units_);
}
inline void Options::_internal_set_units(::valhalla::Options_Units value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.units_ = value;
}

// string language = 2;
inline bool Options::has_language() const {
  return has_language_case() == kLanguage;
}
inline void Options::set_has_language() {
  _impl_._oneof_case_[0] = kLanguage;
}
inline void Options::clear_language() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_language_case() == kLanguage) {
    _impl_.has_language_.language_.Destroy();
    clear_has_has_language();
  }
}
inline const std::string& Options::language() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Options.language)
  return _internal_language();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Options::set_language(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_language_case() != kLanguage) {
    clear_has_language();

    set_has_language();
    _impl_.has_language_.language_.InitDefault();
  }
  _impl_.has_language_.language_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.Options.language)
}
inline std::string* Options::mutable_language() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:valhalla.Options.language)
  return _s;
}
inline const std::string& Options::_internal_language() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (has_language_case() != kLanguage) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.has_language_.language_.Get();
}
inline void Options::_internal_set_language(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_language_case() != kLanguage) {
    clear_has_language();

    set_has_language();
    _impl_.has_language_.language_.InitDefault();
  }
  _impl_.has_language_.language_.Set(value, GetArena());
}
inline std::string* Options::_internal_mutable_language() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_language_case() != kLanguage) {
    clear_has_language();

    set_has_language();
    _impl_.has_language_.language_.InitDefault();
  }
  return _impl_.has_language_.language_.Mutable( GetArena());
}
inline std::string* Options::release_language() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.Options.language)
  if (has_language_case() != kLanguage) {
    return nullptr;
  }
  clear_has_has_language();
  return _impl_.has_language_.language_.Release();
}
inline void Options::set_allocated_language(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_has_language()) {
    clear_has_language();
  }
  if (value != nullptr) {
    set_has_language();
    _impl_.has_language_.language_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Options.language)
}

// .valhalla.DirectionsType directions_type = 3;
inline void Options::clear_directions_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.directions_type_ = 0;
}
inline ::valhalla::DirectionsType Options::directions_type() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.directions_type)
  return _internal_directions_type();
}
inline void Options::set_directions_type(::valhalla::DirectionsType value) {
  _internal_set_directions_type(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.directions_type)
}
inline ::valhalla::DirectionsType Options::_internal_directions_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::DirectionsType>(_impl_.directions_type_);
}
inline void Options::_internal_set_directions_type(::valhalla::DirectionsType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.directions_type_ = value;
}

// .valhalla.Options.Format format = 4;
inline void Options::clear_format() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.format_ = 0;
}
inline ::valhalla::Options_Format Options::format() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.format)
  return _internal_format();
}
inline void Options::set_format(::valhalla::Options_Format value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.format)
}
inline ::valhalla::Options_Format Options::_internal_format() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::Options_Format>(_impl_.format_);
}
inline void Options::_internal_set_format(::valhalla::Options_Format value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.format_ = value;
}

// string id = 5;
inline bool Options::has_id() const {
  return has_id_case() == kId;
}
inline void Options::set_has_id() {
  _impl_._oneof_case_[1] = kId;
}
inline void Options::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_id_case() == kId) {
    _impl_.has_id_.id_.Destroy();
    clear_has_has_id();
  }
}
inline const std::string& Options::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Options.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Options::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_id_case() != kId) {
    clear_has_id();

    set_has_id();
    _impl_.has_id_.id_.InitDefault();
  }
  _impl_.has_id_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.Options.id)
}
inline std::string* Options::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:valhalla.Options.id)
  return _s;
}
inline const std::string& Options::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (has_id_case() != kId) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.has_id_.id_.Get();
}
inline void Options::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_id_case() != kId) {
    clear_has_id();

    set_has_id();
    _impl_.has_id_.id_.InitDefault();
  }
  _impl_.has_id_.id_.Set(value, GetArena());
}
inline std::string* Options::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_id_case() != kId) {
    clear_has_id();

    set_has_id();
    _impl_.has_id_.id_.InitDefault();
  }
  return _impl_.has_id_.id_.Mutable( GetArena());
}
inline std::string* Options::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.Options.id)
  if (has_id_case() != kId) {
    return nullptr;
  }
  clear_has_has_id();
  return _impl_.has_id_.id_.Release();
}
inline void Options::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_has_id()) {
    clear_has_id();
  }
  if (value != nullptr) {
    set_has_id();
    _impl_.has_id_.id_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Options.id)
}

// string jsonp = 6;
inline bool Options::has_jsonp() const {
  return has_jsonp_case() == kJsonp;
}
inline void Options::set_has_jsonp() {
  _impl_._oneof_case_[2] = kJsonp;
}
inline void Options::clear_jsonp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_jsonp_case() == kJsonp) {
    _impl_.has_jsonp_.jsonp_.Destroy();
    clear_has_has_jsonp();
  }
}
inline const std::string& Options::jsonp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Options.jsonp)
  return _internal_jsonp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Options::set_jsonp(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_jsonp_case() != kJsonp) {
    clear_has_jsonp();

    set_has_jsonp();
    _impl_.has_jsonp_.jsonp_.InitDefault();
  }
  _impl_.has_jsonp_.jsonp_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.Options.jsonp)
}
inline std::string* Options::mutable_jsonp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_jsonp();
  // @@protoc_insertion_point(field_mutable:valhalla.Options.jsonp)
  return _s;
}
inline const std::string& Options::_internal_jsonp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (has_jsonp_case() != kJsonp) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.has_jsonp_.jsonp_.Get();
}
inline void Options::_internal_set_jsonp(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_jsonp_case() != kJsonp) {
    clear_has_jsonp();

    set_has_jsonp();
    _impl_.has_jsonp_.jsonp_.InitDefault();
  }
  _impl_.has_jsonp_.jsonp_.Set(value, GetArena());
}
inline std::string* Options::_internal_mutable_jsonp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_jsonp_case() != kJsonp) {
    clear_has_jsonp();

    set_has_jsonp();
    _impl_.has_jsonp_.jsonp_.InitDefault();
  }
  return _impl_.has_jsonp_.jsonp_.Mutable( GetArena());
}
inline std::string* Options::release_jsonp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.Options.jsonp)
  if (has_jsonp_case() != kJsonp) {
    return nullptr;
  }
  clear_has_has_jsonp();
  return _impl_.has_jsonp_.jsonp_.Release();
}
inline void Options::set_allocated_jsonp(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_has_jsonp()) {
    clear_has_jsonp();
  }
  if (value != nullptr) {
    set_has_jsonp();
    _impl_.has_jsonp_.jsonp_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Options.jsonp)
}

// string encoded_polyline = 7;
inline bool Options::has_encoded_polyline() const {
  return has_encoded_polyline_case() == kEncodedPolyline;
}
inline void Options::set_has_encoded_polyline() {
  _impl_._oneof_case_[3] = kEncodedPolyline;
}
inline void Options::clear_encoded_polyline() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_encoded_polyline_case() == kEncodedPolyline) {
    _impl_.has_encoded_polyline_.encoded_polyline_.Destroy();
    clear_has_has_encoded_polyline();
  }
}
inline const std::string& Options::encoded_polyline() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Options.encoded_polyline)
  return _internal_encoded_polyline();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Options::set_encoded_polyline(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_encoded_polyline_case() != kEncodedPolyline) {
    clear_has_encoded_polyline();

    set_has_encoded_polyline();
    _impl_.has_encoded_polyline_.encoded_polyline_.InitDefault();
  }
  _impl_.has_encoded_polyline_.encoded_polyline_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.Options.encoded_polyline)
}
inline std::string* Options::mutable_encoded_polyline() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_encoded_polyline();
  // @@protoc_insertion_point(field_mutable:valhalla.Options.encoded_polyline)
  return _s;
}
inline const std::string& Options::_internal_encoded_polyline() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (has_encoded_polyline_case() != kEncodedPolyline) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.has_encoded_polyline_.encoded_polyline_.Get();
}
inline void Options::_internal_set_encoded_polyline(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_encoded_polyline_case() != kEncodedPolyline) {
    clear_has_encoded_polyline();

    set_has_encoded_polyline();
    _impl_.has_encoded_polyline_.encoded_polyline_.InitDefault();
  }
  _impl_.has_encoded_polyline_.encoded_polyline_.Set(value, GetArena());
}
inline std::string* Options::_internal_mutable_encoded_polyline() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_encoded_polyline_case() != kEncodedPolyline) {
    clear_has_encoded_polyline();

    set_has_encoded_polyline();
    _impl_.has_encoded_polyline_.encoded_polyline_.InitDefault();
  }
  return _impl_.has_encoded_polyline_.encoded_polyline_.Mutable( GetArena());
}
inline std::string* Options::release_encoded_polyline() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.Options.encoded_polyline)
  if (has_encoded_polyline_case() != kEncodedPolyline) {
    return nullptr;
  }
  clear_has_has_encoded_polyline();
  return _impl_.has_encoded_polyline_.encoded_polyline_.Release();
}
inline void Options::set_allocated_encoded_polyline(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_has_encoded_polyline()) {
    clear_has_encoded_polyline();
  }
  if (value != nullptr) {
    set_has_encoded_polyline();
    _impl_.has_encoded_polyline_.encoded_polyline_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Options.encoded_polyline)
}

// .valhalla.Options.Action action = 8;
inline void Options::clear_action() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.action_ = 0;
}
inline ::valhalla::Options_Action Options::action() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.action)
  return _internal_action();
}
inline void Options::set_action(::valhalla::Options_Action value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.action)
}
inline ::valhalla::Options_Action Options::_internal_action() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::Options_Action>(_impl_.action_);
}
inline void Options::_internal_set_action(::valhalla::Options_Action value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.action_ = value;
}

// bool range = 10;
inline bool Options::has_range() const {
  return has_range_case() == kRange;
}
inline void Options::set_has_range() {
  _impl_._oneof_case_[4] = kRange;
}
inline void Options::clear_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_range_case() == kRange) {
    _impl_.has_range_.range_ = false;
    clear_has_has_range();
  }
}
inline bool Options::range() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.range)
  return _internal_range();
}
inline void Options::set_range(bool value) {
  _internal_set_range(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.range)
}
inline bool Options::_internal_range() const {
  if (has_range_case() == kRange) {
    return _impl_.has_range_.range_;
  }
  return false;
}
inline void Options::_internal_set_range(bool value) {
  if (has_range_case() != kRange) {
    clear_has_range();
    set_has_range();
  }
  _impl_.has_range_.range_ = value;
}

// bool verbose = 11;
inline bool Options::has_verbose() const {
  return has_verbose_case() == kVerbose;
}
inline void Options::set_has_verbose() {
  _impl_._oneof_case_[5] = kVerbose;
}
inline void Options::clear_verbose() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_verbose_case() == kVerbose) {
    _impl_.has_verbose_.verbose_ = false;
    clear_has_has_verbose();
  }
}
inline bool Options::verbose() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.verbose)
  return _internal_verbose();
}
inline void Options::set_verbose(bool value) {
  _internal_set_verbose(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.verbose)
}
inline bool Options::_internal_verbose() const {
  if (has_verbose_case() == kVerbose) {
    return _impl_.has_verbose_.verbose_;
  }
  return false;
}
inline void Options::_internal_set_verbose(bool value) {
  if (has_verbose_case() != kVerbose) {
    clear_has_verbose();
    set_has_verbose();
  }
  _impl_.has_verbose_.verbose_ = value;
}

// .valhalla.Costing.Type costing_type = 12;
inline void Options::clear_costing_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.costing_type_ = 0;
}
inline ::valhalla::Costing_Type Options::costing_type() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.costing_type)
  return _internal_costing_type();
}
inline void Options::set_costing_type(::valhalla::Costing_Type value) {
  _internal_set_costing_type(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.costing_type)
}
inline ::valhalla::Costing_Type Options::_internal_costing_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::Costing_Type>(_impl_.costing_type_);
}
inline void Options::_internal_set_costing_type(::valhalla::Costing_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.costing_type_ = value;
}

// map<int32, .valhalla.Costing> costings = 13;
inline int Options::_internal_costings_size() const {
  return _internal_costings().size();
}
inline int Options::costings_size() const {
  return _internal_costings_size();
}
inline void Options::clear_costings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.costings_.Clear();
}
inline const ::google::protobuf::Map<::int32_t, ::valhalla::Costing>& Options::_internal_costings() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.costings_.GetMap();
}
inline const ::google::protobuf::Map<::int32_t, ::valhalla::Costing>& Options::costings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:valhalla.Options.costings)
  return _internal_costings();
}
inline ::google::protobuf::Map<::int32_t, ::valhalla::Costing>* Options::_internal_mutable_costings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.costings_.MutableMap();
}
inline ::google::protobuf::Map<::int32_t, ::valhalla::Costing>* Options::mutable_costings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:valhalla.Options.costings)
  return _internal_mutable_costings();
}

// repeated .valhalla.Location locations = 14;
inline int Options::_internal_locations_size() const {
  return _internal_locations().size();
}
inline int Options::locations_size() const {
  return _internal_locations_size();
}
inline ::valhalla::Location* Options::mutable_locations(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.locations)
  return _internal_mutable_locations()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::Location>* Options::mutable_locations()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.locations)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_locations();
}
inline const ::valhalla::Location& Options::locations(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Options.locations)
  return _internal_locations().Get(index);
}
inline ::valhalla::Location* Options::add_locations() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::Location* _add = _internal_mutable_locations()->Add();
  // @@protoc_insertion_point(field_add:valhalla.Options.locations)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::Location>& Options::locations() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.Options.locations)
  return _internal_locations();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::Location>&
Options::_internal_locations() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.locations_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::Location>*
Options::_internal_mutable_locations() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.locations_;
}

// repeated .valhalla.Location exclude_locations = 15;
inline int Options::_internal_exclude_locations_size() const {
  return _internal_exclude_locations().size();
}
inline int Options::exclude_locations_size() const {
  return _internal_exclude_locations_size();
}
inline ::valhalla::Location* Options::mutable_exclude_locations(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.exclude_locations)
  return _internal_mutable_exclude_locations()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::Location>* Options::mutable_exclude_locations()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.exclude_locations)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_exclude_locations();
}
inline const ::valhalla::Location& Options::exclude_locations(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Options.exclude_locations)
  return _internal_exclude_locations().Get(index);
}
inline ::valhalla::Location* Options::add_exclude_locations() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::Location* _add = _internal_mutable_exclude_locations()->Add();
  // @@protoc_insertion_point(field_add:valhalla.Options.exclude_locations)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::Location>& Options::exclude_locations() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.Options.exclude_locations)
  return _internal_exclude_locations();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::Location>&
Options::_internal_exclude_locations() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.exclude_locations_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::Location>*
Options::_internal_mutable_exclude_locations() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.exclude_locations_;
}

// repeated .valhalla.Location sources = 16;
inline int Options::_internal_sources_size() const {
  return _internal_sources().size();
}
inline int Options::sources_size() const {
  return _internal_sources_size();
}
inline ::valhalla::Location* Options::mutable_sources(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.sources)
  return _internal_mutable_sources()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::Location>* Options::mutable_sources()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.sources)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_sources();
}
inline const ::valhalla::Location& Options::sources(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Options.sources)
  return _internal_sources().Get(index);
}
inline ::valhalla::Location* Options::add_sources() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::Location* _add = _internal_mutable_sources()->Add();
  // @@protoc_insertion_point(field_add:valhalla.Options.sources)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::Location>& Options::sources() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.Options.sources)
  return _internal_sources();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::Location>&
Options::_internal_sources() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sources_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::Location>*
Options::_internal_mutable_sources() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.sources_;
}

// repeated .valhalla.Location targets = 17;
inline int Options::_internal_targets_size() const {
  return _internal_targets().size();
}
inline int Options::targets_size() const {
  return _internal_targets_size();
}
inline ::valhalla::Location* Options::mutable_targets(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.targets)
  return _internal_mutable_targets()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::Location>* Options::mutable_targets()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.targets)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_targets();
}
inline const ::valhalla::Location& Options::targets(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Options.targets)
  return _internal_targets().Get(index);
}
inline ::valhalla::Location* Options::add_targets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::Location* _add = _internal_mutable_targets()->Add();
  // @@protoc_insertion_point(field_add:valhalla.Options.targets)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::Location>& Options::targets() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.Options.targets)
  return _internal_targets();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::Location>&
Options::_internal_targets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.targets_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::Location>*
Options::_internal_mutable_targets() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.targets_;
}

// .valhalla.Options.DateTimeType date_time_type = 18;
inline void Options::clear_date_time_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.date_time_type_ = 0;
}
inline ::valhalla::Options_DateTimeType Options::date_time_type() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.date_time_type)
  return _internal_date_time_type();
}
inline void Options::set_date_time_type(::valhalla::Options_DateTimeType value) {
  _internal_set_date_time_type(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.date_time_type)
}
inline ::valhalla::Options_DateTimeType Options::_internal_date_time_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::Options_DateTimeType>(_impl_.date_time_type_);
}
inline void Options::_internal_set_date_time_type(::valhalla::Options_DateTimeType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.date_time_type_ = value;
}

// string date_time = 19;
inline bool Options::has_date_time() const {
  return has_date_time_case() == kDateTime;
}
inline void Options::set_has_date_time() {
  _impl_._oneof_case_[6] = kDateTime;
}
inline void Options::clear_date_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_date_time_case() == kDateTime) {
    _impl_.has_date_time_.date_time_.Destroy();
    clear_has_has_date_time();
  }
}
inline const std::string& Options::date_time() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Options.date_time)
  return _internal_date_time();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Options::set_date_time(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_date_time_case() != kDateTime) {
    clear_has_date_time();

    set_has_date_time();
    _impl_.has_date_time_.date_time_.InitDefault();
  }
  _impl_.has_date_time_.date_time_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.Options.date_time)
}
inline std::string* Options::mutable_date_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_date_time();
  // @@protoc_insertion_point(field_mutable:valhalla.Options.date_time)
  return _s;
}
inline const std::string& Options::_internal_date_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (has_date_time_case() != kDateTime) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.has_date_time_.date_time_.Get();
}
inline void Options::_internal_set_date_time(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_date_time_case() != kDateTime) {
    clear_has_date_time();

    set_has_date_time();
    _impl_.has_date_time_.date_time_.InitDefault();
  }
  _impl_.has_date_time_.date_time_.Set(value, GetArena());
}
inline std::string* Options::_internal_mutable_date_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_date_time_case() != kDateTime) {
    clear_has_date_time();

    set_has_date_time();
    _impl_.has_date_time_.date_time_.InitDefault();
  }
  return _impl_.has_date_time_.date_time_.Mutable( GetArena());
}
inline std::string* Options::release_date_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.Options.date_time)
  if (has_date_time_case() != kDateTime) {
    return nullptr;
  }
  clear_has_has_date_time();
  return _impl_.has_date_time_.date_time_.Release();
}
inline void Options::set_allocated_date_time(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_has_date_time()) {
    clear_has_date_time();
  }
  if (value != nullptr) {
    set_has_date_time();
    _impl_.has_date_time_.date_time_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:valhalla.Options.date_time)
}

// repeated .valhalla.Location shape = 20;
inline int Options::_internal_shape_size() const {
  return _internal_shape().size();
}
inline int Options::shape_size() const {
  return _internal_shape_size();
}
inline ::valhalla::Location* Options::mutable_shape(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.shape)
  return _internal_mutable_shape()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::Location>* Options::mutable_shape()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.shape)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_shape();
}
inline const ::valhalla::Location& Options::shape(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Options.shape)
  return _internal_shape().Get(index);
}
inline ::valhalla::Location* Options::add_shape() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::Location* _add = _internal_mutable_shape()->Add();
  // @@protoc_insertion_point(field_add:valhalla.Options.shape)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::Location>& Options::shape() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.Options.shape)
  return _internal_shape();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::Location>&
Options::_internal_shape() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.shape_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::Location>*
Options::_internal_mutable_shape() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.shape_;
}

// double resample_distance = 21;
inline bool Options::has_resample_distance() const {
  return has_resample_distance_case() == kResampleDistance;
}
inline void Options::set_has_resample_distance() {
  _impl_._oneof_case_[7] = kResampleDistance;
}
inline void Options::clear_resample_distance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_resample_distance_case() == kResampleDistance) {
    _impl_.has_resample_distance_.resample_distance_ = 0;
    clear_has_has_resample_distance();
  }
}
inline double Options::resample_distance() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.resample_distance)
  return _internal_resample_distance();
}
inline void Options::set_resample_distance(double value) {
  _internal_set_resample_distance(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.resample_distance)
}
inline double Options::_internal_resample_distance() const {
  if (has_resample_distance_case() == kResampleDistance) {
    return _impl_.has_resample_distance_.resample_distance_;
  }
  return 0;
}
inline void Options::_internal_set_resample_distance(double value) {
  if (has_resample_distance_case() != kResampleDistance) {
    clear_has_resample_distance();
    set_has_resample_distance();
  }
  _impl_.has_resample_distance_.resample_distance_ = value;
}

// repeated .valhalla.Contour contours = 22;
inline int Options::_internal_contours_size() const {
  return _internal_contours().size();
}
inline int Options::contours_size() const {
  return _internal_contours_size();
}
inline void Options::clear_contours() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.contours_.Clear();
}
inline ::valhalla::Contour* Options::mutable_contours(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.contours)
  return _internal_mutable_contours()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::Contour>* Options::mutable_contours()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.contours)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_contours();
}
inline const ::valhalla::Contour& Options::contours(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Options.contours)
  return _internal_contours().Get(index);
}
inline ::valhalla::Contour* Options::add_contours() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::Contour* _add = _internal_mutable_contours()->Add();
  // @@protoc_insertion_point(field_add:valhalla.Options.contours)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::Contour>& Options::contours() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.Options.contours)
  return _internal_contours();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::Contour>&
Options::_internal_contours() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.contours_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::Contour>*
Options::_internal_mutable_contours() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.contours_;
}

// bool polygons = 23;
inline bool Options::has_polygons() const {
  return has_polygons_case() == kPolygons;
}
inline void Options::set_has_polygons() {
  _impl_._oneof_case_[8] = kPolygons;
}
inline void Options::clear_polygons() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_polygons_case() == kPolygons) {
    _impl_.has_polygons_.polygons_ = false;
    clear_has_has_polygons();
  }
}
inline bool Options::polygons() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.polygons)
  return _internal_polygons();
}
inline void Options::set_polygons(bool value) {
  _internal_set_polygons(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.polygons)
}
inline bool Options::_internal_polygons() const {
  if (has_polygons_case() == kPolygons) {
    return _impl_.has_polygons_.polygons_;
  }
  return false;
}
inline void Options::_internal_set_polygons(bool value) {
  if (has_polygons_case() != kPolygons) {
    clear_has_polygons();
    set_has_polygons();
  }
  _impl_.has_polygons_.polygons_ = value;
}

// float denoise = 24;
inline bool Options::has_denoise() const {
  return has_denoise_case() == kDenoise;
}
inline void Options::set_has_denoise() {
  _impl_._oneof_case_[9] = kDenoise;
}
inline void Options::clear_denoise() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_denoise_case() == kDenoise) {
    _impl_.has_denoise_.denoise_ = 0;
    clear_has_has_denoise();
  }
}
inline float Options::denoise() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.denoise)
  return _internal_denoise();
}
inline void Options::set_denoise(float value) {
  _internal_set_denoise(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.denoise)
}
inline float Options::_internal_denoise() const {
  if (has_denoise_case() == kDenoise) {
    return _impl_.has_denoise_.denoise_;
  }
  return 0;
}
inline void Options::_internal_set_denoise(float value) {
  if (has_denoise_case() != kDenoise) {
    clear_has_denoise();
    set_has_denoise();
  }
  _impl_.has_denoise_.denoise_ = value;
}

// float generalize = 25;
inline bool Options::has_generalize() const {
  return has_generalize_case() == kGeneralize;
}
inline void Options::set_has_generalize() {
  _impl_._oneof_case_[10] = kGeneralize;
}
inline void Options::clear_generalize() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_generalize_case() == kGeneralize) {
    _impl_.has_generalize_.generalize_ = 0;
    clear_has_has_generalize();
  }
}
inline float Options::generalize() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.generalize)
  return _internal_generalize();
}
inline void Options::set_generalize(float value) {
  _internal_set_generalize(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.generalize)
}
inline float Options::_internal_generalize() const {
  if (has_generalize_case() == kGeneralize) {
    return _impl_.has_generalize_.generalize_;
  }
  return 0;
}
inline void Options::_internal_set_generalize(float value) {
  if (has_generalize_case() != kGeneralize) {
    clear_has_generalize();
    set_has_generalize();
  }
  _impl_.has_generalize_.generalize_ = value;
}

// bool show_locations = 26;
inline bool Options::has_show_locations() const {
  return has_show_locations_case() == kShowLocations;
}
inline void Options::set_has_show_locations() {
  _impl_._oneof_case_[11] = kShowLocations;
}
inline void Options::clear_show_locations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_show_locations_case() == kShowLocations) {
    _impl_.has_show_locations_.show_locations_ = false;
    clear_has_has_show_locations();
  }
}
inline bool Options::show_locations() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.show_locations)
  return _internal_show_locations();
}
inline void Options::set_show_locations(bool value) {
  _internal_set_show_locations(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.show_locations)
}
inline bool Options::_internal_show_locations() const {
  if (has_show_locations_case() == kShowLocations) {
    return _impl_.has_show_locations_.show_locations_;
  }
  return false;
}
inline void Options::_internal_set_show_locations(bool value) {
  if (has_show_locations_case() != kShowLocations) {
    clear_has_show_locations();
    set_has_show_locations();
  }
  _impl_.has_show_locations_.show_locations_ = value;
}

// repeated .valhalla.Location trace = 27;
inline int Options::_internal_trace_size() const {
  return _internal_trace().size();
}
inline int Options::trace_size() const {
  return _internal_trace_size();
}
inline ::valhalla::Location* Options::mutable_trace(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.trace)
  return _internal_mutable_trace()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::Location>* Options::mutable_trace()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.trace)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_trace();
}
inline const ::valhalla::Location& Options::trace(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Options.trace)
  return _internal_trace().Get(index);
}
inline ::valhalla::Location* Options::add_trace() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::Location* _add = _internal_mutable_trace()->Add();
  // @@protoc_insertion_point(field_add:valhalla.Options.trace)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::Location>& Options::trace() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.Options.trace)
  return _internal_trace();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::Location>&
Options::_internal_trace() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.trace_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::Location>*
Options::_internal_mutable_trace() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.trace_;
}

// .valhalla.ShapeMatch shape_match = 28;
inline void Options::clear_shape_match() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.shape_match_ = 0;
}
inline ::valhalla::ShapeMatch Options::shape_match() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.shape_match)
  return _internal_shape_match();
}
inline void Options::set_shape_match(::valhalla::ShapeMatch value) {
  _internal_set_shape_match(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.shape_match)
}
inline ::valhalla::ShapeMatch Options::_internal_shape_match() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::ShapeMatch>(_impl_.shape_match_);
}
inline void Options::_internal_set_shape_match(::valhalla::ShapeMatch value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.shape_match_ = value;
}

// float gps_accuracy = 30;
inline bool Options::has_gps_accuracy() const {
  return has_gps_accuracy_case() == kGpsAccuracy;
}
inline void Options::set_has_gps_accuracy() {
  _impl_._oneof_case_[12] = kGpsAccuracy;
}
inline void Options::clear_gps_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_gps_accuracy_case() == kGpsAccuracy) {
    _impl_.has_gps_accuracy_.gps_accuracy_ = 0;
    clear_has_has_gps_accuracy();
  }
}
inline float Options::gps_accuracy() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.gps_accuracy)
  return _internal_gps_accuracy();
}
inline void Options::set_gps_accuracy(float value) {
  _internal_set_gps_accuracy(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.gps_accuracy)
}
inline float Options::_internal_gps_accuracy() const {
  if (has_gps_accuracy_case() == kGpsAccuracy) {
    return _impl_.has_gps_accuracy_.gps_accuracy_;
  }
  return 0;
}
inline void Options::_internal_set_gps_accuracy(float value) {
  if (has_gps_accuracy_case() != kGpsAccuracy) {
    clear_has_gps_accuracy();
    set_has_gps_accuracy();
  }
  _impl_.has_gps_accuracy_.gps_accuracy_ = value;
}

// float search_radius = 31;
inline bool Options::has_search_radius() const {
  return has_search_radius_case() == kSearchRadius;
}
inline void Options::set_has_search_radius() {
  _impl_._oneof_case_[13] = kSearchRadius;
}
inline void Options::clear_search_radius() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_search_radius_case() == kSearchRadius) {
    _impl_.has_search_radius_.search_radius_ = 0;
    clear_has_has_search_radius();
  }
}
inline float Options::search_radius() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.search_radius)
  return _internal_search_radius();
}
inline void Options::set_search_radius(float value) {
  _internal_set_search_radius(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.search_radius)
}
inline float Options::_internal_search_radius() const {
  if (has_search_radius_case() == kSearchRadius) {
    return _impl_.has_search_radius_.search_radius_;
  }
  return 0;
}
inline void Options::_internal_set_search_radius(float value) {
  if (has_search_radius_case() != kSearchRadius) {
    clear_has_search_radius();
    set_has_search_radius();
  }
  _impl_.has_search_radius_.search_radius_ = value;
}

// float turn_penalty_factor = 32;
inline bool Options::has_turn_penalty_factor() const {
  return has_turn_penalty_factor_case() == kTurnPenaltyFactor;
}
inline void Options::set_has_turn_penalty_factor() {
  _impl_._oneof_case_[14] = kTurnPenaltyFactor;
}
inline void Options::clear_turn_penalty_factor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_turn_penalty_factor_case() == kTurnPenaltyFactor) {
    _impl_.has_turn_penalty_factor_.turn_penalty_factor_ = 0;
    clear_has_has_turn_penalty_factor();
  }
}
inline float Options::turn_penalty_factor() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.turn_penalty_factor)
  return _internal_turn_penalty_factor();
}
inline void Options::set_turn_penalty_factor(float value) {
  _internal_set_turn_penalty_factor(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.turn_penalty_factor)
}
inline float Options::_internal_turn_penalty_factor() const {
  if (has_turn_penalty_factor_case() == kTurnPenaltyFactor) {
    return _impl_.has_turn_penalty_factor_.turn_penalty_factor_;
  }
  return 0;
}
inline void Options::_internal_set_turn_penalty_factor(float value) {
  if (has_turn_penalty_factor_case() != kTurnPenaltyFactor) {
    clear_has_turn_penalty_factor();
    set_has_turn_penalty_factor();
  }
  _impl_.has_turn_penalty_factor_.turn_penalty_factor_ = value;
}

// .valhalla.FilterAction filter_action = 33;
inline void Options::clear_filter_action() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filter_action_ = 0;
}
inline ::valhalla::FilterAction Options::filter_action() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.filter_action)
  return _internal_filter_action();
}
inline void Options::set_filter_action(::valhalla::FilterAction value) {
  _internal_set_filter_action(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.filter_action)
}
inline ::valhalla::FilterAction Options::_internal_filter_action() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::FilterAction>(_impl_.filter_action_);
}
inline void Options::_internal_set_filter_action(::valhalla::FilterAction value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.filter_action_ = value;
}

// repeated string filter_attributes = 34;
inline int Options::_internal_filter_attributes_size() const {
  return _internal_filter_attributes().size();
}
inline int Options::filter_attributes_size() const {
  return _internal_filter_attributes_size();
}
inline void Options::clear_filter_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filter_attributes_.Clear();
}
inline std::string* Options::add_filter_attributes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_filter_attributes()->Add();
  // @@protoc_insertion_point(field_add_mutable:valhalla.Options.filter_attributes)
  return _s;
}
inline const std::string& Options::filter_attributes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Options.filter_attributes)
  return _internal_filter_attributes().Get(index);
}
inline std::string* Options::mutable_filter_attributes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.filter_attributes)
  return _internal_mutable_filter_attributes()->Mutable(index);
}
inline void Options::set_filter_attributes(int index, const std::string& value) {
  _internal_mutable_filter_attributes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.filter_attributes)
}
inline void Options::set_filter_attributes(int index, std::string&& value) {
  _internal_mutable_filter_attributes()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:valhalla.Options.filter_attributes)
}
inline void Options::set_filter_attributes(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_filter_attributes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.Options.filter_attributes)
}
inline void Options::set_filter_attributes(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_filter_attributes()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.Options.filter_attributes)
}
inline void Options::set_filter_attributes(int index, absl::string_view value) {
  _internal_mutable_filter_attributes()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:valhalla.Options.filter_attributes)
}
inline void Options::add_filter_attributes(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_filter_attributes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:valhalla.Options.filter_attributes)
}
inline void Options::add_filter_attributes(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_filter_attributes()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:valhalla.Options.filter_attributes)
}
inline void Options::add_filter_attributes(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_filter_attributes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:valhalla.Options.filter_attributes)
}
inline void Options::add_filter_attributes(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_filter_attributes()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:valhalla.Options.filter_attributes)
}
inline void Options::add_filter_attributes(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_filter_attributes()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:valhalla.Options.filter_attributes)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Options::filter_attributes() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.Options.filter_attributes)
  return _internal_filter_attributes();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Options::mutable_filter_attributes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.filter_attributes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_filter_attributes();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Options::_internal_filter_attributes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.filter_attributes_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Options::_internal_mutable_filter_attributes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.filter_attributes_;
}

// float breakage_distance = 36;
inline bool Options::has_breakage_distance() const {
  return has_breakage_distance_case() == kBreakageDistance;
}
inline void Options::set_has_breakage_distance() {
  _impl_._oneof_case_[15] = kBreakageDistance;
}
inline void Options::clear_breakage_distance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_breakage_distance_case() == kBreakageDistance) {
    _impl_.has_breakage_distance_.breakage_distance_ = 0;
    clear_has_has_breakage_distance();
  }
}
inline float Options::breakage_distance() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.breakage_distance)
  return _internal_breakage_distance();
}
inline void Options::set_breakage_distance(float value) {
  _internal_set_breakage_distance(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.breakage_distance)
}
inline float Options::_internal_breakage_distance() const {
  if (has_breakage_distance_case() == kBreakageDistance) {
    return _impl_.has_breakage_distance_.breakage_distance_;
  }
  return 0;
}
inline void Options::_internal_set_breakage_distance(float value) {
  if (has_breakage_distance_case() != kBreakageDistance) {
    clear_has_breakage_distance();
    set_has_breakage_distance();
  }
  _impl_.has_breakage_distance_.breakage_distance_ = value;
}

// bool use_timestamps = 37;
inline bool Options::has_use_timestamps() const {
  return has_use_timestamps_case() == kUseTimestamps;
}
inline void Options::set_has_use_timestamps() {
  _impl_._oneof_case_[16] = kUseTimestamps;
}
inline void Options::clear_use_timestamps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_use_timestamps_case() == kUseTimestamps) {
    _impl_.has_use_timestamps_.use_timestamps_ = false;
    clear_has_has_use_timestamps();
  }
}
inline bool Options::use_timestamps() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.use_timestamps)
  return _internal_use_timestamps();
}
inline void Options::set_use_timestamps(bool value) {
  _internal_set_use_timestamps(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.use_timestamps)
}
inline bool Options::_internal_use_timestamps() const {
  if (has_use_timestamps_case() == kUseTimestamps) {
    return _impl_.has_use_timestamps_.use_timestamps_;
  }
  return false;
}
inline void Options::_internal_set_use_timestamps(bool value) {
  if (has_use_timestamps_case() != kUseTimestamps) {
    clear_has_use_timestamps();
    set_has_use_timestamps();
  }
  _impl_.has_use_timestamps_.use_timestamps_ = value;
}

// .valhalla.ShapeFormat shape_format = 38;
inline bool Options::has_shape_format() const {
  return has_shape_format_case() == kShapeFormat;
}
inline void Options::set_has_shape_format() {
  _impl_._oneof_case_[17] = kShapeFormat;
}
inline void Options::clear_shape_format() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_shape_format_case() == kShapeFormat) {
    _impl_.has_shape_format_.shape_format_ = 0;
    clear_has_has_shape_format();
  }
}
inline ::valhalla::ShapeFormat Options::shape_format() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.shape_format)
  return _internal_shape_format();
}
inline void Options::set_shape_format(::valhalla::ShapeFormat value) {
  _internal_set_shape_format(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.shape_format)
}
inline ::valhalla::ShapeFormat Options::_internal_shape_format() const {
  if (has_shape_format_case() == kShapeFormat) {
    return static_cast<::valhalla::ShapeFormat>(_impl_.has_shape_format_.shape_format_);
  }
  return static_cast<::valhalla::ShapeFormat>(0);
}
inline void Options::_internal_set_shape_format(::valhalla::ShapeFormat value) {
  if (has_shape_format_case() != kShapeFormat) {
    clear_has_shape_format();
    set_has_shape_format();
  }
  _impl_.has_shape_format_.shape_format_ = value;
}

// uint32 alternates = 39;
inline bool Options::has_alternates() const {
  return has_alternates_case() == kAlternates;
}
inline void Options::set_has_alternates() {
  _impl_._oneof_case_[18] = kAlternates;
}
inline void Options::clear_alternates() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_alternates_case() == kAlternates) {
    _impl_.has_alternates_.alternates_ = 0u;
    clear_has_has_alternates();
  }
}
inline ::uint32_t Options::alternates() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.alternates)
  return _internal_alternates();
}
inline void Options::set_alternates(::uint32_t value) {
  _internal_set_alternates(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.alternates)
}
inline ::uint32_t Options::_internal_alternates() const {
  if (has_alternates_case() == kAlternates) {
    return _impl_.has_alternates_.alternates_;
  }
  return 0u;
}
inline void Options::_internal_set_alternates(::uint32_t value) {
  if (has_alternates_case() != kAlternates) {
    clear_has_alternates();
    set_has_alternates();
  }
  _impl_.has_alternates_.alternates_ = value;
}

// float interpolation_distance = 40;
inline bool Options::has_interpolation_distance() const {
  return has_interpolation_distance_case() == kInterpolationDistance;
}
inline void Options::set_has_interpolation_distance() {
  _impl_._oneof_case_[19] = kInterpolationDistance;
}
inline void Options::clear_interpolation_distance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_interpolation_distance_case() == kInterpolationDistance) {
    _impl_.has_interpolation_distance_.interpolation_distance_ = 0;
    clear_has_has_interpolation_distance();
  }
}
inline float Options::interpolation_distance() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.interpolation_distance)
  return _internal_interpolation_distance();
}
inline void Options::set_interpolation_distance(float value) {
  _internal_set_interpolation_distance(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.interpolation_distance)
}
inline float Options::_internal_interpolation_distance() const {
  if (has_interpolation_distance_case() == kInterpolationDistance) {
    return _impl_.has_interpolation_distance_.interpolation_distance_;
  }
  return 0;
}
inline void Options::_internal_set_interpolation_distance(float value) {
  if (has_interpolation_distance_case() != kInterpolationDistance) {
    clear_has_interpolation_distance();
    set_has_interpolation_distance();
  }
  _impl_.has_interpolation_distance_.interpolation_distance_ = value;
}

// bool guidance_views = 41;
inline bool Options::has_guidance_views() const {
  return has_guidance_views_case() == kGuidanceViews;
}
inline void Options::set_has_guidance_views() {
  _impl_._oneof_case_[20] = kGuidanceViews;
}
inline void Options::clear_guidance_views() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_guidance_views_case() == kGuidanceViews) {
    _impl_.has_guidance_views_.guidance_views_ = false;
    clear_has_has_guidance_views();
  }
}
inline bool Options::guidance_views() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.guidance_views)
  return _internal_guidance_views();
}
inline void Options::set_guidance_views(bool value) {
  _internal_set_guidance_views(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.guidance_views)
}
inline bool Options::_internal_guidance_views() const {
  if (has_guidance_views_case() == kGuidanceViews) {
    return _impl_.has_guidance_views_.guidance_views_;
  }
  return false;
}
inline void Options::_internal_set_guidance_views(bool value) {
  if (has_guidance_views_case() != kGuidanceViews) {
    clear_has_guidance_views();
    set_has_guidance_views();
  }
  _impl_.has_guidance_views_.guidance_views_ = value;
}

// uint32 height_precision = 43;
inline bool Options::has_height_precision() const {
  return has_height_precision_case() == kHeightPrecision;
}
inline void Options::set_has_height_precision() {
  _impl_._oneof_case_[21] = kHeightPrecision;
}
inline void Options::clear_height_precision() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_height_precision_case() == kHeightPrecision) {
    _impl_.has_height_precision_.height_precision_ = 0u;
    clear_has_has_height_precision();
  }
}
inline ::uint32_t Options::height_precision() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.height_precision)
  return _internal_height_precision();
}
inline void Options::set_height_precision(::uint32_t value) {
  _internal_set_height_precision(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.height_precision)
}
inline ::uint32_t Options::_internal_height_precision() const {
  if (has_height_precision_case() == kHeightPrecision) {
    return _impl_.has_height_precision_.height_precision_;
  }
  return 0u;
}
inline void Options::_internal_set_height_precision(::uint32_t value) {
  if (has_height_precision_case() != kHeightPrecision) {
    clear_has_height_precision();
    set_has_height_precision();
  }
  _impl_.has_height_precision_.height_precision_ = value;
}

// bool roundabout_exits = 44;
inline bool Options::has_roundabout_exits() const {
  return has_roundabout_exits_case() == kRoundaboutExits;
}
inline void Options::set_has_roundabout_exits() {
  _impl_._oneof_case_[22] = kRoundaboutExits;
}
inline void Options::clear_roundabout_exits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_roundabout_exits_case() == kRoundaboutExits) {
    _impl_.has_roundabout_exits_.roundabout_exits_ = false;
    clear_has_has_roundabout_exits();
  }
}
inline bool Options::roundabout_exits() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.roundabout_exits)
  return _internal_roundabout_exits();
}
inline void Options::set_roundabout_exits(bool value) {
  _internal_set_roundabout_exits(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.roundabout_exits)
}
inline bool Options::_internal_roundabout_exits() const {
  if (has_roundabout_exits_case() == kRoundaboutExits) {
    return _impl_.has_roundabout_exits_.roundabout_exits_;
  }
  return false;
}
inline void Options::_internal_set_roundabout_exits(bool value) {
  if (has_roundabout_exits_case() != kRoundaboutExits) {
    clear_has_roundabout_exits();
    set_has_roundabout_exits();
  }
  _impl_.has_roundabout_exits_.roundabout_exits_ = value;
}

// bool linear_references = 45;
inline bool Options::has_linear_references() const {
  return has_linear_references_case() == kLinearReferences;
}
inline void Options::set_has_linear_references() {
  _impl_._oneof_case_[23] = kLinearReferences;
}
inline void Options::clear_linear_references() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_linear_references_case() == kLinearReferences) {
    _impl_.has_linear_references_.linear_references_ = false;
    clear_has_has_linear_references();
  }
}
inline bool Options::linear_references() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.linear_references)
  return _internal_linear_references();
}
inline void Options::set_linear_references(bool value) {
  _internal_set_linear_references(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.linear_references)
}
inline bool Options::_internal_linear_references() const {
  if (has_linear_references_case() == kLinearReferences) {
    return _impl_.has_linear_references_.linear_references_;
  }
  return false;
}
inline void Options::_internal_set_linear_references(bool value) {
  if (has_linear_references_case() != kLinearReferences) {
    clear_has_linear_references();
    set_has_linear_references();
  }
  _impl_.has_linear_references_.linear_references_ = value;
}

// repeated .valhalla.Costing recostings = 46;
inline int Options::_internal_recostings_size() const {
  return _internal_recostings().size();
}
inline int Options::recostings_size() const {
  return _internal_recostings_size();
}
inline void Options::clear_recostings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.recostings_.Clear();
}
inline ::valhalla::Costing* Options::mutable_recostings(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.recostings)
  return _internal_mutable_recostings()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::Costing>* Options::mutable_recostings()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.recostings)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_recostings();
}
inline const ::valhalla::Costing& Options::recostings(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Options.recostings)
  return _internal_recostings().Get(index);
}
inline ::valhalla::Costing* Options::add_recostings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::Costing* _add = _internal_mutable_recostings()->Add();
  // @@protoc_insertion_point(field_add:valhalla.Options.recostings)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::Costing>& Options::recostings() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.Options.recostings)
  return _internal_recostings();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::Costing>&
Options::_internal_recostings() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.recostings_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::Costing>*
Options::_internal_mutable_recostings() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.recostings_;
}

// repeated .valhalla.Ring exclude_polygons = 47;
inline int Options::_internal_exclude_polygons_size() const {
  return _internal_exclude_polygons().size();
}
inline int Options::exclude_polygons_size() const {
  return _internal_exclude_polygons_size();
}
inline void Options::clear_exclude_polygons() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.exclude_polygons_.Clear();
}
inline ::valhalla::Ring* Options::mutable_exclude_polygons(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.exclude_polygons)
  return _internal_mutable_exclude_polygons()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::Ring>* Options::mutable_exclude_polygons()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.exclude_polygons)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_exclude_polygons();
}
inline const ::valhalla::Ring& Options::exclude_polygons(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Options.exclude_polygons)
  return _internal_exclude_polygons().Get(index);
}
inline ::valhalla::Ring* Options::add_exclude_polygons() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::Ring* _add = _internal_mutable_exclude_polygons()->Add();
  // @@protoc_insertion_point(field_add:valhalla.Options.exclude_polygons)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::Ring>& Options::exclude_polygons() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.Options.exclude_polygons)
  return _internal_exclude_polygons();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::Ring>&
Options::_internal_exclude_polygons() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.exclude_polygons_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::Ring>*
Options::_internal_mutable_exclude_polygons() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.exclude_polygons_;
}

// bool prioritize_bidirectional = 48;
inline bool Options::has_prioritize_bidirectional() const {
  return has_prioritize_bidirectional_case() == kPrioritizeBidirectional;
}
inline void Options::set_has_prioritize_bidirectional() {
  _impl_._oneof_case_[24] = kPrioritizeBidirectional;
}
inline void Options::clear_prioritize_bidirectional() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_prioritize_bidirectional_case() == kPrioritizeBidirectional) {
    _impl_.has_prioritize_bidirectional_.prioritize_bidirectional_ = false;
    clear_has_has_prioritize_bidirectional();
  }
}
inline bool Options::prioritize_bidirectional() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.prioritize_bidirectional)
  return _internal_prioritize_bidirectional();
}
inline void Options::set_prioritize_bidirectional(bool value) {
  _internal_set_prioritize_bidirectional(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.prioritize_bidirectional)
}
inline bool Options::_internal_prioritize_bidirectional() const {
  if (has_prioritize_bidirectional_case() == kPrioritizeBidirectional) {
    return _impl_.has_prioritize_bidirectional_.prioritize_bidirectional_;
  }
  return false;
}
inline void Options::_internal_set_prioritize_bidirectional(bool value) {
  if (has_prioritize_bidirectional_case() != kPrioritizeBidirectional) {
    clear_has_prioritize_bidirectional();
    set_has_prioritize_bidirectional();
  }
  _impl_.has_prioritize_bidirectional_.prioritize_bidirectional_ = value;
}

// .valhalla.Options.Action expansion_action = 49;
inline bool Options::has_expansion_action() const {
  return has_expansion_action_case() == kExpansionAction;
}
inline void Options::set_has_expansion_action() {
  _impl_._oneof_case_[25] = kExpansionAction;
}
inline void Options::clear_expansion_action() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_expansion_action_case() == kExpansionAction) {
    _impl_.has_expansion_action_.expansion_action_ = 0;
    clear_has_has_expansion_action();
  }
}
inline ::valhalla::Options_Action Options::expansion_action() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.expansion_action)
  return _internal_expansion_action();
}
inline void Options::set_expansion_action(::valhalla::Options_Action value) {
  _internal_set_expansion_action(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.expansion_action)
}
inline ::valhalla::Options_Action Options::_internal_expansion_action() const {
  if (has_expansion_action_case() == kExpansionAction) {
    return static_cast<::valhalla::Options_Action>(_impl_.has_expansion_action_.expansion_action_);
  }
  return static_cast<::valhalla::Options_Action>(0);
}
inline void Options::_internal_set_expansion_action(::valhalla::Options_Action value) {
  if (has_expansion_action_case() != kExpansionAction) {
    clear_has_expansion_action();
    set_has_expansion_action();
  }
  _impl_.has_expansion_action_.expansion_action_ = value;
}

// bool skip_opposites = 50;
inline bool Options::has_skip_opposites() const {
  return has_skip_opposites_case() == kSkipOpposites;
}
inline void Options::set_has_skip_opposites() {
  _impl_._oneof_case_[26] = kSkipOpposites;
}
inline void Options::clear_skip_opposites() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_skip_opposites_case() == kSkipOpposites) {
    _impl_.has_skip_opposites_.skip_opposites_ = false;
    clear_has_has_skip_opposites();
  }
}
inline bool Options::skip_opposites() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.skip_opposites)
  return _internal_skip_opposites();
}
inline void Options::set_skip_opposites(bool value) {
  _internal_set_skip_opposites(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.skip_opposites)
}
inline bool Options::_internal_skip_opposites() const {
  if (has_skip_opposites_case() == kSkipOpposites) {
    return _impl_.has_skip_opposites_.skip_opposites_;
  }
  return false;
}
inline void Options::_internal_set_skip_opposites(bool value) {
  if (has_skip_opposites_case() != kSkipOpposites) {
    clear_has_skip_opposites();
    set_has_skip_opposites();
  }
  _impl_.has_skip_opposites_.skip_opposites_ = value;
}

// repeated .valhalla.Options.ExpansionProperties expansion_properties = 51;
inline int Options::_internal_expansion_properties_size() const {
  return _internal_expansion_properties().size();
}
inline int Options::expansion_properties_size() const {
  return _internal_expansion_properties_size();
}
inline void Options::clear_expansion_properties() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.expansion_properties_.Clear();
}
inline ::valhalla::Options_ExpansionProperties Options::expansion_properties(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.expansion_properties)
  return static_cast<::valhalla::Options_ExpansionProperties>(_internal_expansion_properties().Get(index));
}
inline void Options::set_expansion_properties(int index, ::valhalla::Options_ExpansionProperties value) {
  _internal_mutable_expansion_properties()->Set(index, value);
  // @@protoc_insertion_point(field_set:valhalla.Options.expansion_properties)
}
inline void Options::add_expansion_properties(::valhalla::Options_ExpansionProperties value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_expansion_properties()->Add(value);
  // @@protoc_insertion_point(field_add:valhalla.Options.expansion_properties)
}
inline const ::google::protobuf::RepeatedField<int>& Options::expansion_properties() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.Options.expansion_properties)
  return _internal_expansion_properties();
}
inline ::google::protobuf::RepeatedField<int>* Options::mutable_expansion_properties()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.expansion_properties)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_expansion_properties();
}
inline const ::google::protobuf::RepeatedField<int>& Options::_internal_expansion_properties() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.expansion_properties_;
}
inline ::google::protobuf::RepeatedField<int>* Options::_internal_mutable_expansion_properties() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.expansion_properties_;
}

// .valhalla.PbfFieldSelector pbf_field_selector = 52;
inline bool Options::has_pbf_field_selector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pbf_field_selector_ != nullptr);
  return value;
}
inline void Options::clear_pbf_field_selector() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pbf_field_selector_ != nullptr) _impl_.pbf_field_selector_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::valhalla::PbfFieldSelector& Options::_internal_pbf_field_selector() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::PbfFieldSelector* p = _impl_.pbf_field_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::PbfFieldSelector&>(::valhalla::_PbfFieldSelector_default_instance_);
}
inline const ::valhalla::PbfFieldSelector& Options::pbf_field_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Options.pbf_field_selector)
  return _internal_pbf_field_selector();
}
inline void Options::unsafe_arena_set_allocated_pbf_field_selector(::valhalla::PbfFieldSelector* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pbf_field_selector_);
  }
  _impl_.pbf_field_selector_ = reinterpret_cast<::valhalla::PbfFieldSelector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.Options.pbf_field_selector)
}
inline ::valhalla::PbfFieldSelector* Options::release_pbf_field_selector() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::PbfFieldSelector* released = _impl_.pbf_field_selector_;
  _impl_.pbf_field_selector_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::PbfFieldSelector* Options::unsafe_arena_release_pbf_field_selector() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.Options.pbf_field_selector)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::PbfFieldSelector* temp = _impl_.pbf_field_selector_;
  _impl_.pbf_field_selector_ = nullptr;
  return temp;
}
inline ::valhalla::PbfFieldSelector* Options::_internal_mutable_pbf_field_selector() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.pbf_field_selector_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::PbfFieldSelector>(GetArena());
    _impl_.pbf_field_selector_ = reinterpret_cast<::valhalla::PbfFieldSelector*>(p);
  }
  return _impl_.pbf_field_selector_;
}
inline ::valhalla::PbfFieldSelector* Options::mutable_pbf_field_selector() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::PbfFieldSelector* _msg = _internal_mutable_pbf_field_selector();
  // @@protoc_insertion_point(field_mutable:valhalla.Options.pbf_field_selector)
  return _msg;
}
inline void Options::set_allocated_pbf_field_selector(::valhalla::PbfFieldSelector* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::valhalla::PbfFieldSelector*>(_impl_.pbf_field_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::valhalla::PbfFieldSelector*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pbf_field_selector_ = reinterpret_cast<::valhalla::PbfFieldSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.Options.pbf_field_selector)
}

// bool reverse = 53;
inline void Options::clear_reverse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reverse_ = false;
}
inline bool Options::reverse() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.reverse)
  return _internal_reverse();
}
inline void Options::set_reverse(bool value) {
  _internal_set_reverse(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.reverse)
}
inline bool Options::_internal_reverse() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.reverse_;
}
inline void Options::_internal_set_reverse(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.reverse_ = value;
}

// uint32 matrix_locations = 54;
inline bool Options::has_matrix_locations() const {
  return has_matrix_locations_case() == kMatrixLocations;
}
inline void Options::set_has_matrix_locations() {
  _impl_._oneof_case_[27] = kMatrixLocations;
}
inline void Options::clear_matrix_locations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_matrix_locations_case() == kMatrixLocations) {
    _impl_.has_matrix_locations_.matrix_locations_ = 0u;
    clear_has_has_matrix_locations();
  }
}
inline ::uint32_t Options::matrix_locations() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.matrix_locations)
  return _internal_matrix_locations();
}
inline void Options::set_matrix_locations(::uint32_t value) {
  _internal_set_matrix_locations(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.matrix_locations)
}
inline ::uint32_t Options::_internal_matrix_locations() const {
  if (has_matrix_locations_case() == kMatrixLocations) {
    return _impl_.has_matrix_locations_.matrix_locations_;
  }
  return 0u;
}
inline void Options::_internal_set_matrix_locations(::uint32_t value) {
  if (has_matrix_locations_case() != kMatrixLocations) {
    clear_has_matrix_locations();
    set_has_matrix_locations();
  }
  _impl_.has_matrix_locations_.matrix_locations_ = value;
}

// bool banner_instructions = 55;
inline void Options::clear_banner_instructions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.banner_instructions_ = false;
}
inline bool Options::banner_instructions() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.banner_instructions)
  return _internal_banner_instructions();
}
inline void Options::set_banner_instructions(bool value) {
  _internal_set_banner_instructions(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.banner_instructions)
}
inline bool Options::_internal_banner_instructions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.banner_instructions_;
}
inline void Options::_internal_set_banner_instructions(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.banner_instructions_ = value;
}

// float elevation_interval = 56;
inline void Options::clear_elevation_interval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.elevation_interval_ = 0;
}
inline float Options::elevation_interval() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.elevation_interval)
  return _internal_elevation_interval();
}
inline void Options::set_elevation_interval(float value) {
  _internal_set_elevation_interval(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.elevation_interval)
}
inline float Options::_internal_elevation_interval() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.elevation_interval_;
}
inline void Options::_internal_set_elevation_interval(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.elevation_interval_ = value;
}

// bool voice_instructions = 57;
inline void Options::clear_voice_instructions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.voice_instructions_ = false;
}
inline bool Options::voice_instructions() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.voice_instructions)
  return _internal_voice_instructions();
}
inline void Options::set_voice_instructions(bool value) {
  _internal_set_voice_instructions(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.voice_instructions)
}
inline bool Options::_internal_voice_instructions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.voice_instructions_;
}
inline void Options::_internal_set_voice_instructions(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.voice_instructions_ = value;
}

// bool dedupe = 58;
inline void Options::clear_dedupe() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dedupe_ = false;
}
inline bool Options::dedupe() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.dedupe)
  return _internal_dedupe();
}
inline void Options::set_dedupe(bool value) {
  _internal_set_dedupe(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.dedupe)
}
inline bool Options::_internal_dedupe() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dedupe_;
}
inline void Options::_internal_set_dedupe(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dedupe_ = value;
}

inline bool Options::has_has_language() const {
  return has_language_case() != HAS_LANGUAGE_NOT_SET;
}
inline void Options::clear_has_has_language() {
  _impl_._oneof_case_[0] = HAS_LANGUAGE_NOT_SET;
}
inline bool Options::has_has_id() const {
  return has_id_case() != HAS_ID_NOT_SET;
}
inline void Options::clear_has_has_id() {
  _impl_._oneof_case_[1] = HAS_ID_NOT_SET;
}
inline bool Options::has_has_jsonp() const {
  return has_jsonp_case() != HAS_JSONP_NOT_SET;
}
inline void Options::clear_has_has_jsonp() {
  _impl_._oneof_case_[2] = HAS_JSONP_NOT_SET;
}
inline bool Options::has_has_encoded_polyline() const {
  return has_encoded_polyline_case() != HAS_ENCODED_POLYLINE_NOT_SET;
}
inline void Options::clear_has_has_encoded_polyline() {
  _impl_._oneof_case_[3] = HAS_ENCODED_POLYLINE_NOT_SET;
}
inline bool Options::has_has_range() const {
  return has_range_case() != HAS_RANGE_NOT_SET;
}
inline void Options::clear_has_has_range() {
  _impl_._oneof_case_[4] = HAS_RANGE_NOT_SET;
}
inline bool Options::has_has_verbose() const {
  return has_verbose_case() != HAS_VERBOSE_NOT_SET;
}
inline void Options::clear_has_has_verbose() {
  _impl_._oneof_case_[5] = HAS_VERBOSE_NOT_SET;
}
inline bool Options::has_has_date_time() const {
  return has_date_time_case() != HAS_DATE_TIME_NOT_SET;
}
inline void Options::clear_has_has_date_time() {
  _impl_._oneof_case_[6] = HAS_DATE_TIME_NOT_SET;
}
inline bool Options::has_has_resample_distance() const {
  return has_resample_distance_case() != HAS_RESAMPLE_DISTANCE_NOT_SET;
}
inline void Options::clear_has_has_resample_distance() {
  _impl_._oneof_case_[7] = HAS_RESAMPLE_DISTANCE_NOT_SET;
}
inline bool Options::has_has_polygons() const {
  return has_polygons_case() != HAS_POLYGONS_NOT_SET;
}
inline void Options::clear_has_has_polygons() {
  _impl_._oneof_case_[8] = HAS_POLYGONS_NOT_SET;
}
inline bool Options::has_has_denoise() const {
  return has_denoise_case() != HAS_DENOISE_NOT_SET;
}
inline void Options::clear_has_has_denoise() {
  _impl_._oneof_case_[9] = HAS_DENOISE_NOT_SET;
}
inline bool Options::has_has_generalize() const {
  return has_generalize_case() != HAS_GENERALIZE_NOT_SET;
}
inline void Options::clear_has_has_generalize() {
  _impl_._oneof_case_[10] = HAS_GENERALIZE_NOT_SET;
}
inline bool Options::has_has_show_locations() const {
  return has_show_locations_case() != HAS_SHOW_LOCATIONS_NOT_SET;
}
inline void Options::clear_has_has_show_locations() {
  _impl_._oneof_case_[11] = HAS_SHOW_LOCATIONS_NOT_SET;
}
inline bool Options::has_has_gps_accuracy() const {
  return has_gps_accuracy_case() != HAS_GPS_ACCURACY_NOT_SET;
}
inline void Options::clear_has_has_gps_accuracy() {
  _impl_._oneof_case_[12] = HAS_GPS_ACCURACY_NOT_SET;
}
inline bool Options::has_has_search_radius() const {
  return has_search_radius_case() != HAS_SEARCH_RADIUS_NOT_SET;
}
inline void Options::clear_has_has_search_radius() {
  _impl_._oneof_case_[13] = HAS_SEARCH_RADIUS_NOT_SET;
}
inline bool Options::has_has_turn_penalty_factor() const {
  return has_turn_penalty_factor_case() != HAS_TURN_PENALTY_FACTOR_NOT_SET;
}
inline void Options::clear_has_has_turn_penalty_factor() {
  _impl_._oneof_case_[14] = HAS_TURN_PENALTY_FACTOR_NOT_SET;
}
inline bool Options::has_has_breakage_distance() const {
  return has_breakage_distance_case() != HAS_BREAKAGE_DISTANCE_NOT_SET;
}
inline void Options::clear_has_has_breakage_distance() {
  _impl_._oneof_case_[15] = HAS_BREAKAGE_DISTANCE_NOT_SET;
}
inline bool Options::has_has_use_timestamps() const {
  return has_use_timestamps_case() != HAS_USE_TIMESTAMPS_NOT_SET;
}
inline void Options::clear_has_has_use_timestamps() {
  _impl_._oneof_case_[16] = HAS_USE_TIMESTAMPS_NOT_SET;
}
inline bool Options::has_has_shape_format() const {
  return has_shape_format_case() != HAS_SHAPE_FORMAT_NOT_SET;
}
inline void Options::clear_has_has_shape_format() {
  _impl_._oneof_case_[17] = HAS_SHAPE_FORMAT_NOT_SET;
}
inline bool Options::has_has_alternates() const {
  return has_alternates_case() != HAS_ALTERNATES_NOT_SET;
}
inline void Options::clear_has_has_alternates() {
  _impl_._oneof_case_[18] = HAS_ALTERNATES_NOT_SET;
}
inline bool Options::has_has_interpolation_distance() const {
  return has_interpolation_distance_case() != HAS_INTERPOLATION_DISTANCE_NOT_SET;
}
inline void Options::clear_has_has_interpolation_distance() {
  _impl_._oneof_case_[19] = HAS_INTERPOLATION_DISTANCE_NOT_SET;
}
inline bool Options::has_has_guidance_views() const {
  return has_guidance_views_case() != HAS_GUIDANCE_VIEWS_NOT_SET;
}
inline void Options::clear_has_has_guidance_views() {
  _impl_._oneof_case_[20] = HAS_GUIDANCE_VIEWS_NOT_SET;
}
inline bool Options::has_has_height_precision() const {
  return has_height_precision_case() != HAS_HEIGHT_PRECISION_NOT_SET;
}
inline void Options::clear_has_has_height_precision() {
  _impl_._oneof_case_[21] = HAS_HEIGHT_PRECISION_NOT_SET;
}
inline bool Options::has_has_roundabout_exits() const {
  return has_roundabout_exits_case() != HAS_ROUNDABOUT_EXITS_NOT_SET;
}
inline void Options::clear_has_has_roundabout_exits() {
  _impl_._oneof_case_[22] = HAS_ROUNDABOUT_EXITS_NOT_SET;
}
inline bool Options::has_has_linear_references() const {
  return has_linear_references_case() != HAS_LINEAR_REFERENCES_NOT_SET;
}
inline void Options::clear_has_has_linear_references() {
  _impl_._oneof_case_[23] = HAS_LINEAR_REFERENCES_NOT_SET;
}
inline bool Options::has_has_prioritize_bidirectional() const {
  return has_prioritize_bidirectional_case() != HAS_PRIORITIZE_BIDIRECTIONAL_NOT_SET;
}
inline void Options::clear_has_has_prioritize_bidirectional() {
  _impl_._oneof_case_[24] = HAS_PRIORITIZE_BIDIRECTIONAL_NOT_SET;
}
inline bool Options::has_has_expansion_action() const {
  return has_expansion_action_case() != HAS_EXPANSION_ACTION_NOT_SET;
}
inline void Options::clear_has_has_expansion_action() {
  _impl_._oneof_case_[25] = HAS_EXPANSION_ACTION_NOT_SET;
}
inline bool Options::has_has_skip_opposites() const {
  return has_skip_opposites_case() != HAS_SKIP_OPPOSITES_NOT_SET;
}
inline void Options::clear_has_has_skip_opposites() {
  _impl_._oneof_case_[26] = HAS_SKIP_OPPOSITES_NOT_SET;
}
inline bool Options::has_has_matrix_locations() const {
  return has_matrix_locations_case() != HAS_MATRIX_LOCATIONS_NOT_SET;
}
inline void Options::clear_has_has_matrix_locations() {
  _impl_._oneof_case_[27] = HAS_MATRIX_LOCATIONS_NOT_SET;
}
inline Options::HasLanguageCase Options::has_language_case() const {
  return Options::HasLanguageCase(_impl_._oneof_case_[0]);
}
inline Options::HasIdCase Options::has_id_case() const {
  return Options::HasIdCase(_impl_._oneof_case_[1]);
}
inline Options::HasJsonpCase Options::has_jsonp_case() const {
  return Options::HasJsonpCase(_impl_._oneof_case_[2]);
}
inline Options::HasEncodedPolylineCase Options::has_encoded_polyline_case() const {
  return Options::HasEncodedPolylineCase(_impl_._oneof_case_[3]);
}
inline Options::HasRangeCase Options::has_range_case() const {
  return Options::HasRangeCase(_impl_._oneof_case_[4]);
}
inline Options::HasVerboseCase Options::has_verbose_case() const {
  return Options::HasVerboseCase(_impl_._oneof_case_[5]);
}
inline Options::HasDateTimeCase Options::has_date_time_case() const {
  return Options::HasDateTimeCase(_impl_._oneof_case_[6]);
}
inline Options::HasResampleDistanceCase Options::has_resample_distance_case() const {
  return Options::HasResampleDistanceCase(_impl_._oneof_case_[7]);
}
inline Options::HasPolygonsCase Options::has_polygons_case() const {
  return Options::HasPolygonsCase(_impl_._oneof_case_[8]);
}
inline Options::HasDenoiseCase Options::has_denoise_case() const {
  return Options::HasDenoiseCase(_impl_._oneof_case_[9]);
}
inline Options::HasGeneralizeCase Options::has_generalize_case() const {
  return Options::HasGeneralizeCase(_impl_._oneof_case_[10]);
}
inline Options::HasShowLocationsCase Options::has_show_locations_case() const {
  return Options::HasShowLocationsCase(_impl_._oneof_case_[11]);
}
inline Options::HasGpsAccuracyCase Options::has_gps_accuracy_case() const {
  return Options::HasGpsAccuracyCase(_impl_._oneof_case_[12]);
}
inline Options::HasSearchRadiusCase Options::has_search_radius_case() const {
  return Options::HasSearchRadiusCase(_impl_._oneof_case_[13]);
}
inline Options::HasTurnPenaltyFactorCase Options::has_turn_penalty_factor_case() const {
  return Options::HasTurnPenaltyFactorCase(_impl_._oneof_case_[14]);
}
inline Options::HasBreakageDistanceCase Options::has_breakage_distance_case() const {
  return Options::HasBreakageDistanceCase(_impl_._oneof_case_[15]);
}
inline Options::HasUseTimestampsCase Options::has_use_timestamps_case() const {
  return Options::HasUseTimestampsCase(_impl_._oneof_case_[16]);
}
inline Options::HasShapeFormatCase Options::has_shape_format_case() const {
  return Options::HasShapeFormatCase(_impl_._oneof_case_[17]);
}
inline Options::HasAlternatesCase Options::has_alternates_case() const {
  return Options::HasAlternatesCase(_impl_._oneof_case_[18]);
}
inline Options::HasInterpolationDistanceCase Options::has_interpolation_distance_case() const {
  return Options::HasInterpolationDistanceCase(_impl_._oneof_case_[19]);
}
inline Options::HasGuidanceViewsCase Options::has_guidance_views_case() const {
  return Options::HasGuidanceViewsCase(_impl_._oneof_case_[20]);
}
inline Options::HasHeightPrecisionCase Options::has_height_precision_case() const {
  return Options::HasHeightPrecisionCase(_impl_._oneof_case_[21]);
}
inline Options::HasRoundaboutExitsCase Options::has_roundabout_exits_case() const {
  return Options::HasRoundaboutExitsCase(_impl_._oneof_case_[22]);
}
inline Options::HasLinearReferencesCase Options::has_linear_references_case() const {
  return Options::HasLinearReferencesCase(_impl_._oneof_case_[23]);
}
inline Options::HasPrioritizeBidirectionalCase Options::has_prioritize_bidirectional_case() const {
  return Options::HasPrioritizeBidirectionalCase(_impl_._oneof_case_[24]);
}
inline Options::HasExpansionActionCase Options::has_expansion_action_case() const {
  return Options::HasExpansionActionCase(_impl_._oneof_case_[25]);
}
inline Options::HasSkipOppositesCase Options::has_skip_opposites_case() const {
  return Options::HasSkipOppositesCase(_impl_._oneof_case_[26]);
}
inline Options::HasMatrixLocationsCase Options::has_matrix_locations_case() const {
  return Options::HasMatrixLocationsCase(_impl_._oneof_case_[27]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace valhalla


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::valhalla::Costing_Type> : std::true_type {};
template <>
struct is_proto_enum<::valhalla::Options_Units> : std::true_type {};
template <>
struct is_proto_enum<::valhalla::Options_Format> : std::true_type {};
template <>
struct is_proto_enum<::valhalla::Options_Action> : std::true_type {};
template <>
struct is_proto_enum<::valhalla::Options_DateTimeType> : std::true_type {};
template <>
struct is_proto_enum<::valhalla::Options_ExpansionProperties> : std::true_type {};
template <>
struct is_proto_enum<::valhalla::ShapeMatch> : std::true_type {};
template <>
struct is_proto_enum<::valhalla::FilterAction> : std::true_type {};
template <>
struct is_proto_enum<::valhalla::DirectionsType> : std::true_type {};
template <>
struct is_proto_enum<::valhalla::ShapeFormat> : std::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_options_2eproto_2epb_2eh
