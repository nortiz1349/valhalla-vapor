// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_common_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_common_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_util.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_common_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_common_2eproto {
  static const ::uint32_t offsets[];
};
namespace valhalla {
class BikeShareStationInfo;
struct BikeShareStationInfoDefaultTypeInternal;
extern BikeShareStationInfoDefaultTypeInternal _BikeShareStationInfo_default_instance_;
class BoundingBox;
struct BoundingBoxDefaultTypeInternal;
extern BoundingBoxDefaultTypeInternal _BoundingBox_default_instance_;
class Correlation;
struct CorrelationDefaultTypeInternal;
extern CorrelationDefaultTypeInternal _Correlation_default_instance_;
class LatLng;
struct LatLngDefaultTypeInternal;
extern LatLngDefaultTypeInternal _LatLng_default_instance_;
class Location;
struct LocationDefaultTypeInternal;
extern LocationDefaultTypeInternal _Location_default_instance_;
class PathEdge;
struct PathEdgeDefaultTypeInternal;
extern PathEdgeDefaultTypeInternal _PathEdge_default_instance_;
class Pronunciation;
struct PronunciationDefaultTypeInternal;
extern PronunciationDefaultTypeInternal _Pronunciation_default_instance_;
class RouteLandmark;
struct RouteLandmarkDefaultTypeInternal;
extern RouteLandmarkDefaultTypeInternal _RouteLandmark_default_instance_;
class SearchFilter;
struct SearchFilterDefaultTypeInternal;
extern SearchFilterDefaultTypeInternal _SearchFilter_default_instance_;
class StreetName;
struct StreetNameDefaultTypeInternal;
extern StreetNameDefaultTypeInternal _StreetName_default_instance_;
class Summary;
struct SummaryDefaultTypeInternal;
extern SummaryDefaultTypeInternal _Summary_default_instance_;
class TaggedValue;
struct TaggedValueDefaultTypeInternal;
extern TaggedValueDefaultTypeInternal _TaggedValue_default_instance_;
class TransitEgressInfo;
struct TransitEgressInfoDefaultTypeInternal;
extern TransitEgressInfoDefaultTypeInternal _TransitEgressInfo_default_instance_;
class TransitPlatformInfo;
struct TransitPlatformInfoDefaultTypeInternal;
extern TransitPlatformInfoDefaultTypeInternal _TransitPlatformInfo_default_instance_;
class TransitRouteInfo;
struct TransitRouteInfoDefaultTypeInternal;
extern TransitRouteInfoDefaultTypeInternal _TransitRouteInfo_default_instance_;
class TransitStationInfo;
struct TransitStationInfoDefaultTypeInternal;
extern TransitStationInfoDefaultTypeInternal _TransitStationInfo_default_instance_;
class TurnLane;
struct TurnLaneDefaultTypeInternal;
extern TurnLaneDefaultTypeInternal _TurnLane_default_instance_;
}  // namespace valhalla
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace valhalla {
enum RouteLandmark_Type : int {
  RouteLandmark_Type_kUnused = 0,
  RouteLandmark_Type_kFuel = 1,
  RouteLandmark_Type_kPostOffice = 2,
  RouteLandmark_Type_kPolice = 3,
  RouteLandmark_Type_kFireStation = 4,
  RouteLandmark_Type_kCarWash = 5,
  RouteLandmark_Type_kRestaurant = 6,
  RouteLandmark_Type_kFastFood = 7,
  RouteLandmark_Type_kCafe = 8,
  RouteLandmark_Type_kBank = 9,
  RouteLandmark_Type_kPharmacy = 10,
  RouteLandmark_Type_kKindergarten = 11,
  RouteLandmark_Type_kBar = 12,
  RouteLandmark_Type_kHospital = 13,
  RouteLandmark_Type_kPub = 14,
  RouteLandmark_Type_kClinic = 15,
  RouteLandmark_Type_kTheatre = 16,
  RouteLandmark_Type_kCinema = 17,
  RouteLandmark_Type_kCasino = 18,
  RouteLandmark_Type_RouteLandmark_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RouteLandmark_Type_RouteLandmark_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RouteLandmark_Type_IsValid(int value);
extern const uint32_t RouteLandmark_Type_internal_data_[];
constexpr RouteLandmark_Type RouteLandmark_Type_Type_MIN = static_cast<RouteLandmark_Type>(0);
constexpr RouteLandmark_Type RouteLandmark_Type_Type_MAX = static_cast<RouteLandmark_Type>(18);
constexpr int RouteLandmark_Type_Type_ARRAYSIZE = 18 + 1;
const std::string& RouteLandmark_Type_Name(RouteLandmark_Type value);
template <typename T>
const std::string& RouteLandmark_Type_Name(T value) {
  static_assert(std::is_same<T, RouteLandmark_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return RouteLandmark_Type_Name(static_cast<RouteLandmark_Type>(value));
}
const std::string& RouteLandmark_Type_Name(RouteLandmark_Type value);
bool RouteLandmark_Type_Parse(absl::string_view name, RouteLandmark_Type* value);
enum Location_Type : int {
  Location_Type_kBreak = 0,
  Location_Type_kThrough = 1,
  Location_Type_kVia = 2,
  Location_Type_kBreakThrough = 3,
  Location_Type_Location_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Location_Type_Location_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Location_Type_IsValid(int value);
extern const uint32_t Location_Type_internal_data_[];
constexpr Location_Type Location_Type_Type_MIN = static_cast<Location_Type>(0);
constexpr Location_Type Location_Type_Type_MAX = static_cast<Location_Type>(3);
constexpr int Location_Type_Type_ARRAYSIZE = 3 + 1;
const std::string& Location_Type_Name(Location_Type value);
template <typename T>
const std::string& Location_Type_Name(T value) {
  static_assert(std::is_same<T, Location_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return Location_Type_Name(static_cast<Location_Type>(value));
}
const std::string& Location_Type_Name(Location_Type value);
bool Location_Type_Parse(absl::string_view name, Location_Type* value);
enum Location_PreferredSide : int {
  Location_PreferredSide_either = 0,
  Location_PreferredSide_same = 1,
  Location_PreferredSide_opposite = 2,
  Location_PreferredSide_Location_PreferredSide_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Location_PreferredSide_Location_PreferredSide_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Location_PreferredSide_IsValid(int value);
extern const uint32_t Location_PreferredSide_internal_data_[];
constexpr Location_PreferredSide Location_PreferredSide_PreferredSide_MIN = static_cast<Location_PreferredSide>(0);
constexpr Location_PreferredSide Location_PreferredSide_PreferredSide_MAX = static_cast<Location_PreferredSide>(2);
constexpr int Location_PreferredSide_PreferredSide_ARRAYSIZE = 2 + 1;
const std::string& Location_PreferredSide_Name(Location_PreferredSide value);
template <typename T>
const std::string& Location_PreferredSide_Name(T value) {
  static_assert(std::is_same<T, Location_PreferredSide>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PreferredSide_Name().");
  return Location_PreferredSide_Name(static_cast<Location_PreferredSide>(value));
}
const std::string& Location_PreferredSide_Name(Location_PreferredSide value);
bool Location_PreferredSide_Parse(absl::string_view name, Location_PreferredSide* value);
enum Location_SideOfStreet : int {
  Location_SideOfStreet_kNone = 0,
  Location_SideOfStreet_kLeft = 1,
  Location_SideOfStreet_kRight = 2,
  Location_SideOfStreet_Location_SideOfStreet_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Location_SideOfStreet_Location_SideOfStreet_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Location_SideOfStreet_IsValid(int value);
extern const uint32_t Location_SideOfStreet_internal_data_[];
constexpr Location_SideOfStreet Location_SideOfStreet_SideOfStreet_MIN = static_cast<Location_SideOfStreet>(0);
constexpr Location_SideOfStreet Location_SideOfStreet_SideOfStreet_MAX = static_cast<Location_SideOfStreet>(2);
constexpr int Location_SideOfStreet_SideOfStreet_ARRAYSIZE = 2 + 1;
const std::string& Location_SideOfStreet_Name(Location_SideOfStreet value);
template <typename T>
const std::string& Location_SideOfStreet_Name(T value) {
  static_assert(std::is_same<T, Location_SideOfStreet>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SideOfStreet_Name().");
  return Location_SideOfStreet_Name(static_cast<Location_SideOfStreet>(value));
}
const std::string& Location_SideOfStreet_Name(Location_SideOfStreet value);
bool Location_SideOfStreet_Parse(absl::string_view name, Location_SideOfStreet* value);
enum TransitPlatformInfo_Type : int {
  TransitPlatformInfo_Type_kStop = 0,
  TransitPlatformInfo_Type_kStation = 1,
  TransitPlatformInfo_Type_TransitPlatformInfo_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TransitPlatformInfo_Type_TransitPlatformInfo_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TransitPlatformInfo_Type_IsValid(int value);
extern const uint32_t TransitPlatformInfo_Type_internal_data_[];
constexpr TransitPlatformInfo_Type TransitPlatformInfo_Type_Type_MIN = static_cast<TransitPlatformInfo_Type>(0);
constexpr TransitPlatformInfo_Type TransitPlatformInfo_Type_Type_MAX = static_cast<TransitPlatformInfo_Type>(1);
constexpr int TransitPlatformInfo_Type_Type_ARRAYSIZE = 1 + 1;
const std::string& TransitPlatformInfo_Type_Name(TransitPlatformInfo_Type value);
template <typename T>
const std::string& TransitPlatformInfo_Type_Name(T value) {
  static_assert(std::is_same<T, TransitPlatformInfo_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return TransitPlatformInfo_Type_Name(static_cast<TransitPlatformInfo_Type>(value));
}
const std::string& TransitPlatformInfo_Type_Name(TransitPlatformInfo_Type value);
bool TransitPlatformInfo_Type_Parse(absl::string_view name, TransitPlatformInfo_Type* value);
enum Pronunciation_Alphabet : int {
  Pronunciation_Alphabet_kNone = 0,
  Pronunciation_Alphabet_kIpa = 1,
  Pronunciation_Alphabet_kKatakana = 2,
  Pronunciation_Alphabet_kJeita = 3,
  Pronunciation_Alphabet_kNtSampa = 4,
  Pronunciation_Alphabet_Pronunciation_Alphabet_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Pronunciation_Alphabet_Pronunciation_Alphabet_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Pronunciation_Alphabet_IsValid(int value);
extern const uint32_t Pronunciation_Alphabet_internal_data_[];
constexpr Pronunciation_Alphabet Pronunciation_Alphabet_Alphabet_MIN = static_cast<Pronunciation_Alphabet>(0);
constexpr Pronunciation_Alphabet Pronunciation_Alphabet_Alphabet_MAX = static_cast<Pronunciation_Alphabet>(4);
constexpr int Pronunciation_Alphabet_Alphabet_ARRAYSIZE = 4 + 1;
const std::string& Pronunciation_Alphabet_Name(Pronunciation_Alphabet value);
template <typename T>
const std::string& Pronunciation_Alphabet_Name(T value) {
  static_assert(std::is_same<T, Pronunciation_Alphabet>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Alphabet_Name().");
  return Pronunciation_Alphabet_Name(static_cast<Pronunciation_Alphabet>(value));
}
const std::string& Pronunciation_Alphabet_Name(Pronunciation_Alphabet value);
bool Pronunciation_Alphabet_Parse(absl::string_view name, Pronunciation_Alphabet* value);
enum TurnLane_State : int {
  TurnLane_State_kInvalid = 0,
  TurnLane_State_kValid = 1,
  TurnLane_State_kActive = 2,
  TurnLane_State_TurnLane_State_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TurnLane_State_TurnLane_State_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TurnLane_State_IsValid(int value);
extern const uint32_t TurnLane_State_internal_data_[];
constexpr TurnLane_State TurnLane_State_State_MIN = static_cast<TurnLane_State>(0);
constexpr TurnLane_State TurnLane_State_State_MAX = static_cast<TurnLane_State>(2);
constexpr int TurnLane_State_State_ARRAYSIZE = 2 + 1;
const std::string& TurnLane_State_Name(TurnLane_State value);
template <typename T>
const std::string& TurnLane_State_Name(T value) {
  static_assert(std::is_same<T, TurnLane_State>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to State_Name().");
  return TurnLane_State_Name(static_cast<TurnLane_State>(value));
}
const std::string& TurnLane_State_Name(TurnLane_State value);
bool TurnLane_State_Parse(absl::string_view name, TurnLane_State* value);
enum TaggedValue_Type : int {
  TaggedValue_Type_kNone = 0,
  TaggedValue_Type_kLayer = 1,
  TaggedValue_Type_kPronunciation = 2,
  TaggedValue_Type_kBssInfo = 3,
  TaggedValue_Type_kLevel = 4,
  TaggedValue_Type_kLevelRef = 5,
  TaggedValue_Type_kLandmark = 6,
  TaggedValue_Type_kConditionalSpeedLimits = 7,
  TaggedValue_Type_kLevels = 8,
  TaggedValue_Type_kTunnel = 49,
  TaggedValue_Type_kBridge = 50,
  TaggedValue_Type_TaggedValue_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TaggedValue_Type_TaggedValue_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TaggedValue_Type_IsValid(int value);
extern const uint32_t TaggedValue_Type_internal_data_[];
constexpr TaggedValue_Type TaggedValue_Type_Type_MIN = static_cast<TaggedValue_Type>(0);
constexpr TaggedValue_Type TaggedValue_Type_Type_MAX = static_cast<TaggedValue_Type>(50);
constexpr int TaggedValue_Type_Type_ARRAYSIZE = 50 + 1;
const std::string& TaggedValue_Type_Name(TaggedValue_Type value);
template <typename T>
const std::string& TaggedValue_Type_Name(T value) {
  static_assert(std::is_same<T, TaggedValue_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return TaggedValue_Type_Name(static_cast<TaggedValue_Type>(value));
}
const std::string& TaggedValue_Type_Name(TaggedValue_Type value);
bool TaggedValue_Type_Parse(absl::string_view name, TaggedValue_Type* value);
enum LanguageTag : int {
  kUnspecified = 0,
  kAb = 1,
  kAm = 2,
  kAr = 3,
  kAz = 4,
  kBe = 5,
  kBg = 6,
  kBn = 7,
  kBs = 8,
  kCa = 9,
  kCkb = 10,
  kCs = 11,
  kDa = 12,
  kDe = 13,
  kDv = 14,
  kDz = 15,
  kEl = 16,
  kEn = 17,
  kEs = 18,
  kEt = 19,
  kFa = 20,
  kFi = 21,
  kFr = 22,
  kFy = 23,
  kGl = 24,
  kHe = 25,
  kHr = 26,
  kHu = 27,
  kHy = 28,
  kId = 29,
  kIs = 30,
  kIt = 31,
  kJa = 32,
  kKa = 33,
  kKl = 34,
  kKm = 35,
  kKo = 36,
  kLo = 37,
  kLt = 38,
  kLv = 39,
  kMg = 40,
  kMk = 41,
  kMn = 42,
  kMo = 43,
  kMt = 44,
  kMy = 45,
  kNe = 46,
  kNl = 47,
  kNo = 48,
  kOc = 49,
  kPap = 50,
  kPl = 51,
  kPs = 52,
  kPt = 53,
  kRm = 54,
  kRo = 55,
  kRu = 56,
  kSk = 57,
  kSl = 58,
  kSq = 59,
  kSr = 60,
  kSrLatn = 61,
  kSv = 62,
  kTg = 63,
  kTh = 64,
  kTk = 65,
  kTr = 66,
  kUk = 67,
  kUr = 68,
  kUz = 69,
  kVi = 70,
  kZh = 71,
  kCy = 72,
  LanguageTag_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  LanguageTag_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool LanguageTag_IsValid(int value);
extern const uint32_t LanguageTag_internal_data_[];
constexpr LanguageTag LanguageTag_MIN = static_cast<LanguageTag>(0);
constexpr LanguageTag LanguageTag_MAX = static_cast<LanguageTag>(72);
constexpr int LanguageTag_ARRAYSIZE = 72 + 1;
const std::string& LanguageTag_Name(LanguageTag value);
template <typename T>
const std::string& LanguageTag_Name(T value) {
  static_assert(std::is_same<T, LanguageTag>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LanguageTag_Name().");
  return LanguageTag_Name(static_cast<LanguageTag>(value));
}
const std::string& LanguageTag_Name(LanguageTag value);
bool LanguageTag_Parse(absl::string_view name, LanguageTag* value);
enum RoadClass : int {
  kMotorway = 0,
  kTrunk = 1,
  kPrimary = 2,
  kSecondary = 3,
  kTertiary = 4,
  kUnclassified = 5,
  kResidential = 6,
  kServiceOther = 7,
  RoadClass_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RoadClass_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RoadClass_IsValid(int value);
extern const uint32_t RoadClass_internal_data_[];
constexpr RoadClass RoadClass_MIN = static_cast<RoadClass>(0);
constexpr RoadClass RoadClass_MAX = static_cast<RoadClass>(7);
constexpr int RoadClass_ARRAYSIZE = 7 + 1;
const std::string& RoadClass_Name(RoadClass value);
template <typename T>
const std::string& RoadClass_Name(T value) {
  static_assert(std::is_same<T, RoadClass>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RoadClass_Name().");
  return RoadClass_Name(static_cast<RoadClass>(value));
}
const std::string& RoadClass_Name(RoadClass value);
bool RoadClass_Parse(absl::string_view name, RoadClass* value);
enum TravelMode : int {
  kDrive = 0,
  kPedestrian = 1,
  kBicycle = 2,
  kTransit = 3,
  TravelMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TravelMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TravelMode_IsValid(int value);
extern const uint32_t TravelMode_internal_data_[];
constexpr TravelMode TravelMode_MIN = static_cast<TravelMode>(0);
constexpr TravelMode TravelMode_MAX = static_cast<TravelMode>(3);
constexpr int TravelMode_ARRAYSIZE = 3 + 1;
const std::string& TravelMode_Name(TravelMode value);
template <typename T>
const std::string& TravelMode_Name(T value) {
  static_assert(std::is_same<T, TravelMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TravelMode_Name().");
  return TravelMode_Name(static_cast<TravelMode>(value));
}
const std::string& TravelMode_Name(TravelMode value);
bool TravelMode_Parse(absl::string_view name, TravelMode* value);
enum VehicleType : int {
  kCar = 0,
  kMotorcycle = 1,
  kAutoBus = 2,
  kTruck = 3,
  kMotorScooter = 4,
  VehicleType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  VehicleType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool VehicleType_IsValid(int value);
extern const uint32_t VehicleType_internal_data_[];
constexpr VehicleType VehicleType_MIN = static_cast<VehicleType>(0);
constexpr VehicleType VehicleType_MAX = static_cast<VehicleType>(4);
constexpr int VehicleType_ARRAYSIZE = 4 + 1;
const std::string& VehicleType_Name(VehicleType value);
template <typename T>
const std::string& VehicleType_Name(T value) {
  static_assert(std::is_same<T, VehicleType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to VehicleType_Name().");
  return VehicleType_Name(static_cast<VehicleType>(value));
}
const std::string& VehicleType_Name(VehicleType value);
bool VehicleType_Parse(absl::string_view name, VehicleType* value);
enum PedestrianType : int {
  kFoot = 0,
  kWheelchair = 1,
  kBlind = 2,
  PedestrianType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PedestrianType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PedestrianType_IsValid(int value);
extern const uint32_t PedestrianType_internal_data_[];
constexpr PedestrianType PedestrianType_MIN = static_cast<PedestrianType>(0);
constexpr PedestrianType PedestrianType_MAX = static_cast<PedestrianType>(2);
constexpr int PedestrianType_ARRAYSIZE = 2 + 1;
const std::string& PedestrianType_Name(PedestrianType value);
template <typename T>
const std::string& PedestrianType_Name(T value) {
  static_assert(std::is_same<T, PedestrianType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PedestrianType_Name().");
  return PedestrianType_Name(static_cast<PedestrianType>(value));
}
const std::string& PedestrianType_Name(PedestrianType value);
bool PedestrianType_Parse(absl::string_view name, PedestrianType* value);
enum BicycleType : int {
  kRoad = 0,
  kCross = 1,
  kHybrid = 2,
  kMountain = 3,
  BicycleType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  BicycleType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool BicycleType_IsValid(int value);
extern const uint32_t BicycleType_internal_data_[];
constexpr BicycleType BicycleType_MIN = static_cast<BicycleType>(0);
constexpr BicycleType BicycleType_MAX = static_cast<BicycleType>(3);
constexpr int BicycleType_ARRAYSIZE = 3 + 1;
const std::string& BicycleType_Name(BicycleType value);
template <typename T>
const std::string& BicycleType_Name(T value) {
  static_assert(std::is_same<T, BicycleType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to BicycleType_Name().");
  return BicycleType_Name(static_cast<BicycleType>(value));
}
const std::string& BicycleType_Name(BicycleType value);
bool BicycleType_Parse(absl::string_view name, BicycleType* value);
enum TransitType : int {
  kTram = 0,
  kMetro = 1,
  kRail = 2,
  kBus = 3,
  kFerry = 4,
  kCableCar = 5,
  kGondola = 6,
  kFunicular = 7,
  TransitType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TransitType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TransitType_IsValid(int value);
extern const uint32_t TransitType_internal_data_[];
constexpr TransitType TransitType_MIN = static_cast<TransitType>(0);
constexpr TransitType TransitType_MAX = static_cast<TransitType>(7);
constexpr int TransitType_ARRAYSIZE = 7 + 1;
const std::string& TransitType_Name(TransitType value);
template <typename T>
const std::string& TransitType_Name(T value) {
  static_assert(std::is_same<T, TransitType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TransitType_Name().");
  return TransitType_Name(static_cast<TransitType>(value));
}
const std::string& TransitType_Name(TransitType value);
bool TransitType_Parse(absl::string_view name, TransitType* value);

// ===================================================================


// -------------------------------------------------------------------

class TurnLane final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TurnLane) */ {
 public:
  inline TurnLane() : TurnLane(nullptr) {}
  ~TurnLane() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TurnLane(::google::protobuf::internal::ConstantInitialized);

  inline TurnLane(const TurnLane& from)
      : TurnLane(nullptr, from) {}
  TurnLane(TurnLane&& from) noexcept
    : TurnLane() {
    *this = ::std::move(from);
  }

  inline TurnLane& operator=(const TurnLane& from) {
    CopyFrom(from);
    return *this;
  }
  inline TurnLane& operator=(TurnLane&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TurnLane& default_instance() {
    return *internal_default_instance();
  }
  static inline const TurnLane* internal_default_instance() {
    return reinterpret_cast<const TurnLane*>(
               &_TurnLane_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TurnLane& a, TurnLane& b) {
    a.Swap(&b);
  }
  inline void Swap(TurnLane* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TurnLane* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TurnLane* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TurnLane>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const TurnLane& from);
  void MergeFrom(const TurnLane& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TurnLane* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.TurnLane";
  }
  protected:
  explicit TurnLane(::google::protobuf::Arena* arena);
  TurnLane(::google::protobuf::Arena* arena, const TurnLane& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using State = TurnLane_State;
  static constexpr State kInvalid = TurnLane_State_kInvalid;
  static constexpr State kValid = TurnLane_State_kValid;
  static constexpr State kActive = TurnLane_State_kActive;
  static inline bool State_IsValid(int value) {
    return TurnLane_State_IsValid(value);
  }
  static constexpr State State_MIN = TurnLane_State_State_MIN;
  static constexpr State State_MAX = TurnLane_State_State_MAX;
  static constexpr int State_ARRAYSIZE = TurnLane_State_State_ARRAYSIZE;
  template <typename T>
  static inline const std::string& State_Name(T value) {
    return TurnLane_State_Name(value);
  }
  static inline bool State_Parse(absl::string_view name, State* value) {
    return TurnLane_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDirectionsMaskFieldNumber = 1,
    kStateFieldNumber = 2,
    kActiveDirectionFieldNumber = 3,
  };
  // uint32 directions_mask = 1;
  void clear_directions_mask() ;
  ::uint32_t directions_mask() const;
  void set_directions_mask(::uint32_t value);

  private:
  ::uint32_t _internal_directions_mask() const;
  void _internal_set_directions_mask(::uint32_t value);

  public:
  // .valhalla.TurnLane.State state = 2;
  void clear_state() ;
  ::valhalla::TurnLane_State state() const;
  void set_state(::valhalla::TurnLane_State value);

  private:
  ::valhalla::TurnLane_State _internal_state() const;
  void _internal_set_state(::valhalla::TurnLane_State value);

  public:
  // uint32 active_direction = 3;
  void clear_active_direction() ;
  ::uint32_t active_direction() const;
  void set_active_direction(::uint32_t value);

  private:
  ::uint32_t _internal_active_direction() const;
  void _internal_set_active_direction(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:valhalla.TurnLane)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint32_t directions_mask_;
    int state_;
    ::uint32_t active_direction_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};// -------------------------------------------------------------------

class TaggedValue final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TaggedValue) */ {
 public:
  inline TaggedValue() : TaggedValue(nullptr) {}
  ~TaggedValue() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TaggedValue(::google::protobuf::internal::ConstantInitialized);

  inline TaggedValue(const TaggedValue& from)
      : TaggedValue(nullptr, from) {}
  TaggedValue(TaggedValue&& from) noexcept
    : TaggedValue() {
    *this = ::std::move(from);
  }

  inline TaggedValue& operator=(const TaggedValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaggedValue& operator=(TaggedValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TaggedValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaggedValue* internal_default_instance() {
    return reinterpret_cast<const TaggedValue*>(
               &_TaggedValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(TaggedValue& a, TaggedValue& b) {
    a.Swap(&b);
  }
  inline void Swap(TaggedValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaggedValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaggedValue* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaggedValue>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const TaggedValue& from);
  void MergeFrom(const TaggedValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TaggedValue* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.TaggedValue";
  }
  protected:
  explicit TaggedValue(::google::protobuf::Arena* arena);
  TaggedValue(::google::protobuf::Arena* arena, const TaggedValue& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using Type = TaggedValue_Type;
  static constexpr Type kNone = TaggedValue_Type_kNone;
  static constexpr Type kLayer = TaggedValue_Type_kLayer;
  static constexpr Type kPronunciation = TaggedValue_Type_kPronunciation;
  static constexpr Type kBssInfo = TaggedValue_Type_kBssInfo;
  static constexpr Type kLevel = TaggedValue_Type_kLevel;
  static constexpr Type kLevelRef = TaggedValue_Type_kLevelRef;
  static constexpr Type kLandmark = TaggedValue_Type_kLandmark;
  static constexpr Type kConditionalSpeedLimits = TaggedValue_Type_kConditionalSpeedLimits;
  static constexpr Type kLevels = TaggedValue_Type_kLevels;
  static constexpr Type kTunnel = TaggedValue_Type_kTunnel;
  static constexpr Type kBridge = TaggedValue_Type_kBridge;
  static inline bool Type_IsValid(int value) {
    return TaggedValue_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = TaggedValue_Type_Type_MIN;
  static constexpr Type Type_MAX = TaggedValue_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = TaggedValue_Type_Type_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return TaggedValue_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return TaggedValue_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // bytes value = 1;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // .valhalla.TaggedValue.Type type = 2;
  void clear_type() ;
  ::valhalla::TaggedValue_Type type() const;
  void set_type(::valhalla::TaggedValue_Type value);

  private:
  ::valhalla::TaggedValue_Type _internal_type() const;
  void _internal_set_type(::valhalla::TaggedValue_Type value);

  public:
  // @@protoc_insertion_point(class_scope:valhalla.TaggedValue)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr value_;
    int type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};// -------------------------------------------------------------------

class SearchFilter final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.SearchFilter) */ {
 public:
  inline SearchFilter() : SearchFilter(nullptr) {}
  ~SearchFilter() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SearchFilter(::google::protobuf::internal::ConstantInitialized);

  inline SearchFilter(const SearchFilter& from)
      : SearchFilter(nullptr, from) {}
  SearchFilter(SearchFilter&& from) noexcept
    : SearchFilter() {
    *this = ::std::move(from);
  }

  inline SearchFilter& operator=(const SearchFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchFilter& operator=(SearchFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SearchFilter& default_instance() {
    return *internal_default_instance();
  }
  enum HasMinRoadClassCase {
    kMinRoadClass = 1,
    HAS_MIN_ROAD_CLASS_NOT_SET = 0,
  };

  enum HasMaxRoadClassCase {
    kMaxRoadClass = 2,
    HAS_MAX_ROAD_CLASS_NOT_SET = 0,
  };

  enum HasExcludeClosuresCase {
    kExcludeClosures = 6,
    HAS_EXCLUDE_CLOSURES_NOT_SET = 0,
  };

  static inline const SearchFilter* internal_default_instance() {
    return reinterpret_cast<const SearchFilter*>(
               &_SearchFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SearchFilter& a, SearchFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchFilter* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchFilter* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchFilter>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const SearchFilter& from);
  void MergeFrom(const SearchFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SearchFilter* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.SearchFilter";
  }
  protected:
  explicit SearchFilter(::google::protobuf::Arena* arena);
  SearchFilter(::google::protobuf::Arena* arena, const SearchFilter& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExcludeTunnelFieldNumber = 3,
    kExcludeBridgeFieldNumber = 4,
    kExcludeRampFieldNumber = 5,
    kMinRoadClassFieldNumber = 1,
    kMaxRoadClassFieldNumber = 2,
    kExcludeClosuresFieldNumber = 6,
  };
  // bool exclude_tunnel = 3;
  void clear_exclude_tunnel() ;
  bool exclude_tunnel() const;
  void set_exclude_tunnel(bool value);

  private:
  bool _internal_exclude_tunnel() const;
  void _internal_set_exclude_tunnel(bool value);

  public:
  // bool exclude_bridge = 4;
  void clear_exclude_bridge() ;
  bool exclude_bridge() const;
  void set_exclude_bridge(bool value);

  private:
  bool _internal_exclude_bridge() const;
  void _internal_set_exclude_bridge(bool value);

  public:
  // bool exclude_ramp = 5;
  void clear_exclude_ramp() ;
  bool exclude_ramp() const;
  void set_exclude_ramp(bool value);

  private:
  bool _internal_exclude_ramp() const;
  void _internal_set_exclude_ramp(bool value);

  public:
  // .valhalla.RoadClass min_road_class = 1;
  bool has_min_road_class() const;
  void clear_min_road_class() ;
  ::valhalla::RoadClass min_road_class() const;
  void set_min_road_class(::valhalla::RoadClass value);

  private:
  ::valhalla::RoadClass _internal_min_road_class() const;
  void _internal_set_min_road_class(::valhalla::RoadClass value);

  public:
  // .valhalla.RoadClass max_road_class = 2;
  bool has_max_road_class() const;
  void clear_max_road_class() ;
  ::valhalla::RoadClass max_road_class() const;
  void set_max_road_class(::valhalla::RoadClass value);

  private:
  ::valhalla::RoadClass _internal_max_road_class() const;
  void _internal_set_max_road_class(::valhalla::RoadClass value);

  public:
  // bool exclude_closures = 6;
  bool has_exclude_closures() const;
  void clear_exclude_closures() ;
  bool exclude_closures() const;
  void set_exclude_closures(bool value);

  private:
  bool _internal_exclude_closures() const;
  void _internal_set_exclude_closures(bool value);

  public:
  void clear_has_min_road_class();
  HasMinRoadClassCase has_min_road_class_case() const;
  void clear_has_max_road_class();
  HasMaxRoadClassCase has_max_road_class_case() const;
  void clear_has_exclude_closures();
  HasExcludeClosuresCase has_exclude_closures_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.SearchFilter)
 private:
  class _Internal;
  void set_has_min_road_class();
  void set_has_max_road_class();
  void set_has_exclude_closures();

  inline bool has_has_min_road_class() const;
  inline void clear_has_has_min_road_class();

  inline bool has_has_max_road_class() const;
  inline void clear_has_has_max_road_class();

  inline bool has_has_exclude_closures() const;
  inline void clear_has_has_exclude_closures();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 6, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    bool exclude_tunnel_;
    bool exclude_bridge_;
    bool exclude_ramp_;
    union HasMinRoadClassUnion {
      constexpr HasMinRoadClassUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      int min_road_class_;
    } has_min_road_class_;
    union HasMaxRoadClassUnion {
      constexpr HasMaxRoadClassUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      int max_road_class_;
    } has_max_road_class_;
    union HasExcludeClosuresUnion {
      constexpr HasExcludeClosuresUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool exclude_closures_;
    } has_exclude_closures_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[3];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};// -------------------------------------------------------------------

class Pronunciation final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.Pronunciation) */ {
 public:
  inline Pronunciation() : Pronunciation(nullptr) {}
  ~Pronunciation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Pronunciation(::google::protobuf::internal::ConstantInitialized);

  inline Pronunciation(const Pronunciation& from)
      : Pronunciation(nullptr, from) {}
  Pronunciation(Pronunciation&& from) noexcept
    : Pronunciation() {
    *this = ::std::move(from);
  }

  inline Pronunciation& operator=(const Pronunciation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pronunciation& operator=(Pronunciation&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Pronunciation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pronunciation* internal_default_instance() {
    return reinterpret_cast<const Pronunciation*>(
               &_Pronunciation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Pronunciation& a, Pronunciation& b) {
    a.Swap(&b);
  }
  inline void Swap(Pronunciation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pronunciation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pronunciation* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Pronunciation>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Pronunciation& from);
  void MergeFrom(const Pronunciation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Pronunciation* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.Pronunciation";
  }
  protected:
  explicit Pronunciation(::google::protobuf::Arena* arena);
  Pronunciation(::google::protobuf::Arena* arena, const Pronunciation& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using Alphabet = Pronunciation_Alphabet;
  static constexpr Alphabet kNone = Pronunciation_Alphabet_kNone;
  static constexpr Alphabet kIpa = Pronunciation_Alphabet_kIpa;
  static constexpr Alphabet kKatakana = Pronunciation_Alphabet_kKatakana;
  static constexpr Alphabet kJeita = Pronunciation_Alphabet_kJeita;
  static constexpr Alphabet kNtSampa = Pronunciation_Alphabet_kNtSampa;
  static inline bool Alphabet_IsValid(int value) {
    return Pronunciation_Alphabet_IsValid(value);
  }
  static constexpr Alphabet Alphabet_MIN = Pronunciation_Alphabet_Alphabet_MIN;
  static constexpr Alphabet Alphabet_MAX = Pronunciation_Alphabet_Alphabet_MAX;
  static constexpr int Alphabet_ARRAYSIZE = Pronunciation_Alphabet_Alphabet_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Alphabet_Name(T value) {
    return Pronunciation_Alphabet_Name(value);
  }
  static inline bool Alphabet_Parse(absl::string_view name, Alphabet* value) {
    return Pronunciation_Alphabet_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kAlphabetFieldNumber = 1,
  };
  // string value = 2;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // .valhalla.Pronunciation.Alphabet alphabet = 1;
  void clear_alphabet() ;
  ::valhalla::Pronunciation_Alphabet alphabet() const;
  void set_alphabet(::valhalla::Pronunciation_Alphabet value);

  private:
  ::valhalla::Pronunciation_Alphabet _internal_alphabet() const;
  void _internal_set_alphabet(::valhalla::Pronunciation_Alphabet value);

  public:
  // @@protoc_insertion_point(class_scope:valhalla.Pronunciation)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      36, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr value_;
    int alphabet_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};// -------------------------------------------------------------------

class LatLng final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.LatLng) */ {
 public:
  inline LatLng() : LatLng(nullptr) {}
  ~LatLng() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LatLng(::google::protobuf::internal::ConstantInitialized);

  inline LatLng(const LatLng& from)
      : LatLng(nullptr, from) {}
  LatLng(LatLng&& from) noexcept
    : LatLng() {
    *this = ::std::move(from);
  }

  inline LatLng& operator=(const LatLng& from) {
    CopyFrom(from);
    return *this;
  }
  inline LatLng& operator=(LatLng&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LatLng& default_instance() {
    return *internal_default_instance();
  }
  enum HasLatCase {
    kLat = 1,
    HAS_LAT_NOT_SET = 0,
  };

  enum HasLngCase {
    kLng = 2,
    HAS_LNG_NOT_SET = 0,
  };

  static inline const LatLng* internal_default_instance() {
    return reinterpret_cast<const LatLng*>(
               &_LatLng_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LatLng& a, LatLng& b) {
    a.Swap(&b);
  }
  inline void Swap(LatLng* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LatLng* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LatLng* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LatLng>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const LatLng& from);
  void MergeFrom(const LatLng& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LatLng* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.LatLng";
  }
  protected:
  explicit LatLng(::google::protobuf::Arena* arena);
  LatLng(::google::protobuf::Arena* arena, const LatLng& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatFieldNumber = 1,
    kLngFieldNumber = 2,
  };
  // double lat = 1;
  bool has_lat() const;
  void clear_lat() ;
  double lat() const;
  void set_lat(double value);

  private:
  double _internal_lat() const;
  void _internal_set_lat(double value);

  public:
  // double lng = 2;
  bool has_lng() const;
  void clear_lng() ;
  double lng() const;
  void set_lng(double value);

  private:
  double _internal_lng() const;
  void _internal_set_lng(double value);

  public:
  void clear_has_lat();
  HasLatCase has_lat_case() const;
  void clear_has_lng();
  HasLngCase has_lng_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.LatLng)
 private:
  class _Internal;
  void set_has_lat();
  void set_has_lng();

  inline bool has_has_lat() const;
  inline void clear_has_has_lat();

  inline bool has_has_lng() const;
  inline void clear_has_has_lng();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union HasLatUnion {
      constexpr HasLatUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      double lat_;
    } has_lat_;
    union HasLngUnion {
      constexpr HasLngUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      double lng_;
    } has_lng_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[2];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};// -------------------------------------------------------------------

class BikeShareStationInfo final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.BikeShareStationInfo) */ {
 public:
  inline BikeShareStationInfo() : BikeShareStationInfo(nullptr) {}
  ~BikeShareStationInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BikeShareStationInfo(::google::protobuf::internal::ConstantInitialized);

  inline BikeShareStationInfo(const BikeShareStationInfo& from)
      : BikeShareStationInfo(nullptr, from) {}
  BikeShareStationInfo(BikeShareStationInfo&& from) noexcept
    : BikeShareStationInfo() {
    *this = ::std::move(from);
  }

  inline BikeShareStationInfo& operator=(const BikeShareStationInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BikeShareStationInfo& operator=(BikeShareStationInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BikeShareStationInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BikeShareStationInfo* internal_default_instance() {
    return reinterpret_cast<const BikeShareStationInfo*>(
               &_BikeShareStationInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(BikeShareStationInfo& a, BikeShareStationInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(BikeShareStationInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BikeShareStationInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BikeShareStationInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BikeShareStationInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const BikeShareStationInfo& from);
  void MergeFrom(const BikeShareStationInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BikeShareStationInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.BikeShareStationInfo";
  }
  protected:
  explicit BikeShareStationInfo(::google::protobuf::Arena* arena);
  BikeShareStationInfo(::google::protobuf::Arena* arena, const BikeShareStationInfo& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kRefFieldNumber = 2,
    kNetworkFieldNumber = 4,
    kOperatorFieldNumber = 5,
    kCapacityFieldNumber = 3,
    kRentCostFieldNumber = 6,
    kReturnCostFieldNumber = 7,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string ref = 2;
  void clear_ref() ;
  const std::string& ref() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ref(Arg_&& arg, Args_... args);
  std::string* mutable_ref();
  PROTOBUF_NODISCARD std::string* release_ref();
  void set_allocated_ref(std::string* value);

  private:
  const std::string& _internal_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ref(
      const std::string& value);
  std::string* _internal_mutable_ref();

  public:
  // string network = 4;
  void clear_network() ;
  const std::string& network() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_network(Arg_&& arg, Args_... args);
  std::string* mutable_network();
  PROTOBUF_NODISCARD std::string* release_network();
  void set_allocated_network(std::string* value);

  private:
  const std::string& _internal_network() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_network(
      const std::string& value);
  std::string* _internal_mutable_network();

  public:
  // string operator = 5;
  void clear_operator_() ;
  const std::string& operator_() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operator_(Arg_&& arg, Args_... args);
  std::string* mutable_operator_();
  PROTOBUF_NODISCARD std::string* release_operator_();
  void set_allocated_operator_(std::string* value);

  private:
  const std::string& _internal_operator_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operator_(
      const std::string& value);
  std::string* _internal_mutable_operator_();

  public:
  // uint32 capacity = 3;
  void clear_capacity() ;
  ::uint32_t capacity() const;
  void set_capacity(::uint32_t value);

  private:
  ::uint32_t _internal_capacity() const;
  void _internal_set_capacity(::uint32_t value);

  public:
  // float rent_cost = 6;
  void clear_rent_cost() ;
  float rent_cost() const;
  void set_rent_cost(float value);

  private:
  float _internal_rent_cost() const;
  void _internal_set_rent_cost(float value);

  public:
  // float return_cost = 7;
  void clear_return_cost() ;
  float return_cost() const;
  void set_return_cost(float value);

  private:
  float _internal_return_cost() const;
  void _internal_set_return_cost(float value);

  public:
  // @@protoc_insertion_point(class_scope:valhalla.BikeShareStationInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      60, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr ref_;
    ::google::protobuf::internal::ArenaStringPtr network_;
    ::google::protobuf::internal::ArenaStringPtr operator__;
    ::uint32_t capacity_;
    float rent_cost_;
    float return_cost_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};// -------------------------------------------------------------------

class TransitStationInfo final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TransitStationInfo) */ {
 public:
  inline TransitStationInfo() : TransitStationInfo(nullptr) {}
  ~TransitStationInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TransitStationInfo(::google::protobuf::internal::ConstantInitialized);

  inline TransitStationInfo(const TransitStationInfo& from)
      : TransitStationInfo(nullptr, from) {}
  TransitStationInfo(TransitStationInfo&& from) noexcept
    : TransitStationInfo() {
    *this = ::std::move(from);
  }

  inline TransitStationInfo& operator=(const TransitStationInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransitStationInfo& operator=(TransitStationInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TransitStationInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransitStationInfo* internal_default_instance() {
    return reinterpret_cast<const TransitStationInfo*>(
               &_TransitStationInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TransitStationInfo& a, TransitStationInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TransitStationInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransitStationInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransitStationInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransitStationInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const TransitStationInfo& from);
  void MergeFrom(const TransitStationInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TransitStationInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.TransitStationInfo";
  }
  protected:
  explicit TransitStationInfo(::google::protobuf::Arena* arena);
  TransitStationInfo(::google::protobuf::Arena* arena, const TransitStationInfo& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOnestopIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kLlFieldNumber = 3,
  };
  // string onestop_id = 1;
  void clear_onestop_id() ;
  const std::string& onestop_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_onestop_id(Arg_&& arg, Args_... args);
  std::string* mutable_onestop_id();
  PROTOBUF_NODISCARD std::string* release_onestop_id();
  void set_allocated_onestop_id(std::string* value);

  private:
  const std::string& _internal_onestop_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_onestop_id(
      const std::string& value);
  std::string* _internal_mutable_onestop_id();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .valhalla.LatLng ll = 3;
  bool has_ll() const;
  void clear_ll() ;
  const ::valhalla::LatLng& ll() const;
  PROTOBUF_NODISCARD ::valhalla::LatLng* release_ll();
  ::valhalla::LatLng* mutable_ll();
  void set_allocated_ll(::valhalla::LatLng* value);
  void unsafe_arena_set_allocated_ll(::valhalla::LatLng* value);
  ::valhalla::LatLng* unsafe_arena_release_ll();

  private:
  const ::valhalla::LatLng& _internal_ll() const;
  ::valhalla::LatLng* _internal_mutable_ll();

  public:
  // @@protoc_insertion_point(class_scope:valhalla.TransitStationInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      50, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr onestop_id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::valhalla::LatLng* ll_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};// -------------------------------------------------------------------

class TransitPlatformInfo final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TransitPlatformInfo) */ {
 public:
  inline TransitPlatformInfo() : TransitPlatformInfo(nullptr) {}
  ~TransitPlatformInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TransitPlatformInfo(::google::protobuf::internal::ConstantInitialized);

  inline TransitPlatformInfo(const TransitPlatformInfo& from)
      : TransitPlatformInfo(nullptr, from) {}
  TransitPlatformInfo(TransitPlatformInfo&& from) noexcept
    : TransitPlatformInfo() {
    *this = ::std::move(from);
  }

  inline TransitPlatformInfo& operator=(const TransitPlatformInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransitPlatformInfo& operator=(TransitPlatformInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TransitPlatformInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransitPlatformInfo* internal_default_instance() {
    return reinterpret_cast<const TransitPlatformInfo*>(
               &_TransitPlatformInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TransitPlatformInfo& a, TransitPlatformInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TransitPlatformInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransitPlatformInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransitPlatformInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransitPlatformInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const TransitPlatformInfo& from);
  void MergeFrom(const TransitPlatformInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TransitPlatformInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.TransitPlatformInfo";
  }
  protected:
  explicit TransitPlatformInfo(::google::protobuf::Arena* arena);
  TransitPlatformInfo(::google::protobuf::Arena* arena, const TransitPlatformInfo& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using Type = TransitPlatformInfo_Type;
  static constexpr Type kStop = TransitPlatformInfo_Type_kStop;
  static constexpr Type kStation = TransitPlatformInfo_Type_kStation;
  static inline bool Type_IsValid(int value) {
    return TransitPlatformInfo_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = TransitPlatformInfo_Type_Type_MIN;
  static constexpr Type Type_MAX = TransitPlatformInfo_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = TransitPlatformInfo_Type_Type_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return TransitPlatformInfo_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return TransitPlatformInfo_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kOnestopIdFieldNumber = 2,
    kNameFieldNumber = 3,
    kArrivalDateTimeFieldNumber = 4,
    kDepartureDateTimeFieldNumber = 5,
    kStationOnestopIdFieldNumber = 8,
    kStationNameFieldNumber = 9,
    kLlFieldNumber = 7,
    kTypeFieldNumber = 1,
    kAssumedScheduleFieldNumber = 6,
  };
  // string onestop_id = 2;
  void clear_onestop_id() ;
  const std::string& onestop_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_onestop_id(Arg_&& arg, Args_... args);
  std::string* mutable_onestop_id();
  PROTOBUF_NODISCARD std::string* release_onestop_id();
  void set_allocated_onestop_id(std::string* value);

  private:
  const std::string& _internal_onestop_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_onestop_id(
      const std::string& value);
  std::string* _internal_mutable_onestop_id();

  public:
  // string name = 3;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string arrival_date_time = 4;
  void clear_arrival_date_time() ;
  const std::string& arrival_date_time() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_arrival_date_time(Arg_&& arg, Args_... args);
  std::string* mutable_arrival_date_time();
  PROTOBUF_NODISCARD std::string* release_arrival_date_time();
  void set_allocated_arrival_date_time(std::string* value);

  private:
  const std::string& _internal_arrival_date_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_arrival_date_time(
      const std::string& value);
  std::string* _internal_mutable_arrival_date_time();

  public:
  // string departure_date_time = 5;
  void clear_departure_date_time() ;
  const std::string& departure_date_time() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_departure_date_time(Arg_&& arg, Args_... args);
  std::string* mutable_departure_date_time();
  PROTOBUF_NODISCARD std::string* release_departure_date_time();
  void set_allocated_departure_date_time(std::string* value);

  private:
  const std::string& _internal_departure_date_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_departure_date_time(
      const std::string& value);
  std::string* _internal_mutable_departure_date_time();

  public:
  // string station_onestop_id = 8;
  void clear_station_onestop_id() ;
  const std::string& station_onestop_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_station_onestop_id(Arg_&& arg, Args_... args);
  std::string* mutable_station_onestop_id();
  PROTOBUF_NODISCARD std::string* release_station_onestop_id();
  void set_allocated_station_onestop_id(std::string* value);

  private:
  const std::string& _internal_station_onestop_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_station_onestop_id(
      const std::string& value);
  std::string* _internal_mutable_station_onestop_id();

  public:
  // string station_name = 9;
  void clear_station_name() ;
  const std::string& station_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_station_name(Arg_&& arg, Args_... args);
  std::string* mutable_station_name();
  PROTOBUF_NODISCARD std::string* release_station_name();
  void set_allocated_station_name(std::string* value);

  private:
  const std::string& _internal_station_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_station_name(
      const std::string& value);
  std::string* _internal_mutable_station_name();

  public:
  // .valhalla.LatLng ll = 7;
  bool has_ll() const;
  void clear_ll() ;
  const ::valhalla::LatLng& ll() const;
  PROTOBUF_NODISCARD ::valhalla::LatLng* release_ll();
  ::valhalla::LatLng* mutable_ll();
  void set_allocated_ll(::valhalla::LatLng* value);
  void unsafe_arena_set_allocated_ll(::valhalla::LatLng* value);
  ::valhalla::LatLng* unsafe_arena_release_ll();

  private:
  const ::valhalla::LatLng& _internal_ll() const;
  ::valhalla::LatLng* _internal_mutable_ll();

  public:
  // .valhalla.TransitPlatformInfo.Type type = 1;
  void clear_type() ;
  ::valhalla::TransitPlatformInfo_Type type() const;
  void set_type(::valhalla::TransitPlatformInfo_Type value);

  private:
  ::valhalla::TransitPlatformInfo_Type _internal_type() const;
  void _internal_set_type(::valhalla::TransitPlatformInfo_Type value);

  public:
  // bool assumed_schedule = 6;
  void clear_assumed_schedule() ;
  bool assumed_schedule() const;
  void set_assumed_schedule(bool value);

  private:
  bool _internal_assumed_schedule() const;
  void _internal_set_assumed_schedule(bool value);

  public:
  // @@protoc_insertion_point(class_scope:valhalla.TransitPlatformInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 1,
      125, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr onestop_id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr arrival_date_time_;
    ::google::protobuf::internal::ArenaStringPtr departure_date_time_;
    ::google::protobuf::internal::ArenaStringPtr station_onestop_id_;
    ::google::protobuf::internal::ArenaStringPtr station_name_;
    ::valhalla::LatLng* ll_;
    int type_;
    bool assumed_schedule_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};// -------------------------------------------------------------------

class TransitEgressInfo final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TransitEgressInfo) */ {
 public:
  inline TransitEgressInfo() : TransitEgressInfo(nullptr) {}
  ~TransitEgressInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TransitEgressInfo(::google::protobuf::internal::ConstantInitialized);

  inline TransitEgressInfo(const TransitEgressInfo& from)
      : TransitEgressInfo(nullptr, from) {}
  TransitEgressInfo(TransitEgressInfo&& from) noexcept
    : TransitEgressInfo() {
    *this = ::std::move(from);
  }

  inline TransitEgressInfo& operator=(const TransitEgressInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransitEgressInfo& operator=(TransitEgressInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TransitEgressInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransitEgressInfo* internal_default_instance() {
    return reinterpret_cast<const TransitEgressInfo*>(
               &_TransitEgressInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TransitEgressInfo& a, TransitEgressInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TransitEgressInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransitEgressInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransitEgressInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransitEgressInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const TransitEgressInfo& from);
  void MergeFrom(const TransitEgressInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TransitEgressInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.TransitEgressInfo";
  }
  protected:
  explicit TransitEgressInfo(::google::protobuf::Arena* arena);
  TransitEgressInfo(::google::protobuf::Arena* arena, const TransitEgressInfo& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOnestopIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kLlFieldNumber = 3,
  };
  // string onestop_id = 1;
  void clear_onestop_id() ;
  const std::string& onestop_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_onestop_id(Arg_&& arg, Args_... args);
  std::string* mutable_onestop_id();
  PROTOBUF_NODISCARD std::string* release_onestop_id();
  void set_allocated_onestop_id(std::string* value);

  private:
  const std::string& _internal_onestop_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_onestop_id(
      const std::string& value);
  std::string* _internal_mutable_onestop_id();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .valhalla.LatLng ll = 3;
  bool has_ll() const;
  void clear_ll() ;
  const ::valhalla::LatLng& ll() const;
  PROTOBUF_NODISCARD ::valhalla::LatLng* release_ll();
  ::valhalla::LatLng* mutable_ll();
  void set_allocated_ll(::valhalla::LatLng* value);
  void unsafe_arena_set_allocated_ll(::valhalla::LatLng* value);
  ::valhalla::LatLng* unsafe_arena_release_ll();

  private:
  const ::valhalla::LatLng& _internal_ll() const;
  ::valhalla::LatLng* _internal_mutable_ll();

  public:
  // @@protoc_insertion_point(class_scope:valhalla.TransitEgressInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      49, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr onestop_id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::valhalla::LatLng* ll_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};// -------------------------------------------------------------------

class StreetName final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.StreetName) */ {
 public:
  inline StreetName() : StreetName(nullptr) {}
  ~StreetName() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StreetName(::google::protobuf::internal::ConstantInitialized);

  inline StreetName(const StreetName& from)
      : StreetName(nullptr, from) {}
  StreetName(StreetName&& from) noexcept
    : StreetName() {
    *this = ::std::move(from);
  }

  inline StreetName& operator=(const StreetName& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreetName& operator=(StreetName&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const StreetName& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreetName* internal_default_instance() {
    return reinterpret_cast<const StreetName*>(
               &_StreetName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(StreetName& a, StreetName& b) {
    a.Swap(&b);
  }
  inline void Swap(StreetName* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreetName* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreetName* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreetName>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const StreetName& from);
  void MergeFrom(const StreetName& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StreetName* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.StreetName";
  }
  protected:
  explicit StreetName(::google::protobuf::Arena* arena);
  StreetName(::google::protobuf::Arena* arena, const StreetName& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kPronunciationFieldNumber = 3,
    kIsRouteNumberFieldNumber = 2,
    kLanguageTagFieldNumber = 4,
  };
  // string value = 1;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // .valhalla.Pronunciation pronunciation = 3;
  bool has_pronunciation() const;
  void clear_pronunciation() ;
  const ::valhalla::Pronunciation& pronunciation() const;
  PROTOBUF_NODISCARD ::valhalla::Pronunciation* release_pronunciation();
  ::valhalla::Pronunciation* mutable_pronunciation();
  void set_allocated_pronunciation(::valhalla::Pronunciation* value);
  void unsafe_arena_set_allocated_pronunciation(::valhalla::Pronunciation* value);
  ::valhalla::Pronunciation* unsafe_arena_release_pronunciation();

  private:
  const ::valhalla::Pronunciation& _internal_pronunciation() const;
  ::valhalla::Pronunciation* _internal_mutable_pronunciation();

  public:
  // bool is_route_number = 2;
  void clear_is_route_number() ;
  bool is_route_number() const;
  void set_is_route_number(bool value);

  private:
  bool _internal_is_route_number() const;
  void _internal_set_is_route_number(bool value);

  public:
  // .valhalla.LanguageTag language_tag = 4;
  void clear_language_tag() ;
  ::valhalla::LanguageTag language_tag() const;
  void set_language_tag(::valhalla::LanguageTag value);

  private:
  ::valhalla::LanguageTag _internal_language_tag() const;
  void _internal_set_language_tag(::valhalla::LanguageTag value);

  public:
  // @@protoc_insertion_point(class_scope:valhalla.StreetName)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      33, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr value_;
    ::valhalla::Pronunciation* pronunciation_;
    bool is_route_number_;
    int language_tag_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};// -------------------------------------------------------------------

class RouteLandmark final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.RouteLandmark) */ {
 public:
  inline RouteLandmark() : RouteLandmark(nullptr) {}
  ~RouteLandmark() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RouteLandmark(::google::protobuf::internal::ConstantInitialized);

  inline RouteLandmark(const RouteLandmark& from)
      : RouteLandmark(nullptr, from) {}
  RouteLandmark(RouteLandmark&& from) noexcept
    : RouteLandmark() {
    *this = ::std::move(from);
  }

  inline RouteLandmark& operator=(const RouteLandmark& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteLandmark& operator=(RouteLandmark&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RouteLandmark& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteLandmark* internal_default_instance() {
    return reinterpret_cast<const RouteLandmark*>(
               &_RouteLandmark_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RouteLandmark& a, RouteLandmark& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteLandmark* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteLandmark* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteLandmark* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouteLandmark>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const RouteLandmark& from);
  void MergeFrom(const RouteLandmark& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RouteLandmark* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.RouteLandmark";
  }
  protected:
  explicit RouteLandmark(::google::protobuf::Arena* arena);
  RouteLandmark(::google::protobuf::Arena* arena, const RouteLandmark& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using Type = RouteLandmark_Type;
  static constexpr Type kUnused = RouteLandmark_Type_kUnused;
  static constexpr Type kFuel = RouteLandmark_Type_kFuel;
  static constexpr Type kPostOffice = RouteLandmark_Type_kPostOffice;
  static constexpr Type kPolice = RouteLandmark_Type_kPolice;
  static constexpr Type kFireStation = RouteLandmark_Type_kFireStation;
  static constexpr Type kCarWash = RouteLandmark_Type_kCarWash;
  static constexpr Type kRestaurant = RouteLandmark_Type_kRestaurant;
  static constexpr Type kFastFood = RouteLandmark_Type_kFastFood;
  static constexpr Type kCafe = RouteLandmark_Type_kCafe;
  static constexpr Type kBank = RouteLandmark_Type_kBank;
  static constexpr Type kPharmacy = RouteLandmark_Type_kPharmacy;
  static constexpr Type kKindergarten = RouteLandmark_Type_kKindergarten;
  static constexpr Type kBar = RouteLandmark_Type_kBar;
  static constexpr Type kHospital = RouteLandmark_Type_kHospital;
  static constexpr Type kPub = RouteLandmark_Type_kPub;
  static constexpr Type kClinic = RouteLandmark_Type_kClinic;
  static constexpr Type kTheatre = RouteLandmark_Type_kTheatre;
  static constexpr Type kCinema = RouteLandmark_Type_kCinema;
  static constexpr Type kCasino = RouteLandmark_Type_kCasino;
  static inline bool Type_IsValid(int value) {
    return RouteLandmark_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = RouteLandmark_Type_Type_MIN;
  static constexpr Type Type_MAX = RouteLandmark_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = RouteLandmark_Type_Type_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return RouteLandmark_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return RouteLandmark_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kLatLngFieldNumber = 3,
    kTypeFieldNumber = 2,
    kRightFieldNumber = 5,
    kDistanceFieldNumber = 4,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .valhalla.LatLng lat_lng = 3;
  bool has_lat_lng() const;
  void clear_lat_lng() ;
  const ::valhalla::LatLng& lat_lng() const;
  PROTOBUF_NODISCARD ::valhalla::LatLng* release_lat_lng();
  ::valhalla::LatLng* mutable_lat_lng();
  void set_allocated_lat_lng(::valhalla::LatLng* value);
  void unsafe_arena_set_allocated_lat_lng(::valhalla::LatLng* value);
  ::valhalla::LatLng* unsafe_arena_release_lat_lng();

  private:
  const ::valhalla::LatLng& _internal_lat_lng() const;
  ::valhalla::LatLng* _internal_mutable_lat_lng();

  public:
  // .valhalla.RouteLandmark.Type type = 2;
  void clear_type() ;
  ::valhalla::RouteLandmark_Type type() const;
  void set_type(::valhalla::RouteLandmark_Type value);

  private:
  ::valhalla::RouteLandmark_Type _internal_type() const;
  void _internal_set_type(::valhalla::RouteLandmark_Type value);

  public:
  // bool right = 5;
  void clear_right() ;
  bool right() const;
  void set_right(bool value);

  private:
  bool _internal_right() const;
  void _internal_set_right(bool value);

  public:
  // double distance = 4;
  void clear_distance() ;
  double distance() const;
  void set_distance(double value);

  private:
  double _internal_distance() const;
  void _internal_set_distance(double value);

  public:
  // @@protoc_insertion_point(class_scope:valhalla.RouteLandmark)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      35, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::valhalla::LatLng* lat_lng_;
    int type_;
    bool right_;
    double distance_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};// -------------------------------------------------------------------

class PathEdge final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.PathEdge) */ {
 public:
  inline PathEdge() : PathEdge(nullptr) {}
  ~PathEdge() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PathEdge(::google::protobuf::internal::ConstantInitialized);

  inline PathEdge(const PathEdge& from)
      : PathEdge(nullptr, from) {}
  PathEdge(PathEdge&& from) noexcept
    : PathEdge() {
    *this = ::std::move(from);
  }

  inline PathEdge& operator=(const PathEdge& from) {
    CopyFrom(from);
    return *this;
  }
  inline PathEdge& operator=(PathEdge&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PathEdge& default_instance() {
    return *internal_default_instance();
  }
  static inline const PathEdge* internal_default_instance() {
    return reinterpret_cast<const PathEdge*>(
               &_PathEdge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PathEdge& a, PathEdge& b) {
    a.Swap(&b);
  }
  inline void Swap(PathEdge* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PathEdge* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PathEdge* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PathEdge>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const PathEdge& from);
  void MergeFrom(const PathEdge& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PathEdge* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.PathEdge";
  }
  protected:
  explicit PathEdge(::google::protobuf::Arena* arena);
  PathEdge(::google::protobuf::Arena* arena, const PathEdge& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamesFieldNumber = 10,
    kLlFieldNumber = 3,
    kGraphIdFieldNumber = 1,
    kPercentAlongFieldNumber = 2,
    kDistanceFieldNumber = 5,
    kSideOfStreetFieldNumber = 4,
    kBeginNodeFieldNumber = 7,
    kEndNodeFieldNumber = 8,
    kOutboundReachFieldNumber = 11,
    kInboundReachFieldNumber = 12,
    kHeadingFieldNumber = 13,
  };
  // repeated string names = 10;
  int names_size() const;
  private:
  int _internal_names_size() const;

  public:
  void clear_names() ;
  const std::string& names(int index) const;
  std::string* mutable_names(int index);
  void set_names(int index, const std::string& value);
  void set_names(int index, std::string&& value);
  void set_names(int index, const char* value);
  void set_names(int index, const char* value, std::size_t size);
  void set_names(int index, absl::string_view value);
  std::string* add_names();
  void add_names(const std::string& value);
  void add_names(std::string&& value);
  void add_names(const char* value);
  void add_names(const char* value, std::size_t size);
  void add_names(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_names();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_names();

  public:
  // .valhalla.LatLng ll = 3;
  bool has_ll() const;
  void clear_ll() ;
  const ::valhalla::LatLng& ll() const;
  PROTOBUF_NODISCARD ::valhalla::LatLng* release_ll();
  ::valhalla::LatLng* mutable_ll();
  void set_allocated_ll(::valhalla::LatLng* value);
  void unsafe_arena_set_allocated_ll(::valhalla::LatLng* value);
  ::valhalla::LatLng* unsafe_arena_release_ll();

  private:
  const ::valhalla::LatLng& _internal_ll() const;
  ::valhalla::LatLng* _internal_mutable_ll();

  public:
  // uint64 graph_id = 1;
  void clear_graph_id() ;
  ::uint64_t graph_id() const;
  void set_graph_id(::uint64_t value);

  private:
  ::uint64_t _internal_graph_id() const;
  void _internal_set_graph_id(::uint64_t value);

  public:
  // double percent_along = 2;
  void clear_percent_along() ;
  double percent_along() const;
  void set_percent_along(double value);

  private:
  double _internal_percent_along() const;
  void _internal_set_percent_along(double value);

  public:
  // double distance = 5;
  void clear_distance() ;
  double distance() const;
  void set_distance(double value);

  private:
  double _internal_distance() const;
  void _internal_set_distance(double value);

  public:
  // .valhalla.Location.SideOfStreet side_of_street = 4;
  void clear_side_of_street() ;
  ::valhalla::Location_SideOfStreet side_of_street() const;
  void set_side_of_street(::valhalla::Location_SideOfStreet value);

  private:
  ::valhalla::Location_SideOfStreet _internal_side_of_street() const;
  void _internal_set_side_of_street(::valhalla::Location_SideOfStreet value);

  public:
  // bool begin_node = 7;
  void clear_begin_node() ;
  bool begin_node() const;
  void set_begin_node(bool value);

  private:
  bool _internal_begin_node() const;
  void _internal_set_begin_node(bool value);

  public:
  // bool end_node = 8;
  void clear_end_node() ;
  bool end_node() const;
  void set_end_node(bool value);

  private:
  bool _internal_end_node() const;
  void _internal_set_end_node(bool value);

  public:
  // int32 outbound_reach = 11;
  void clear_outbound_reach() ;
  ::int32_t outbound_reach() const;
  void set_outbound_reach(::int32_t value);

  private:
  ::int32_t _internal_outbound_reach() const;
  void _internal_set_outbound_reach(::int32_t value);

  public:
  // int32 inbound_reach = 12;
  void clear_inbound_reach() ;
  ::int32_t inbound_reach() const;
  void set_inbound_reach(::int32_t value);

  private:
  ::int32_t _internal_inbound_reach() const;
  void _internal_set_inbound_reach(::int32_t value);

  public:
  // float heading = 13;
  void clear_heading() ;
  float heading() const;
  void set_heading(float value);

  private:
  float _internal_heading() const;
  void _internal_set_heading(float value);

  public:
  // @@protoc_insertion_point(class_scope:valhalla.PathEdge)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 11, 1,
      39, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> names_;
    ::valhalla::LatLng* ll_;
    ::uint64_t graph_id_;
    double percent_along_;
    double distance_;
    int side_of_street_;
    bool begin_node_;
    bool end_node_;
    ::int32_t outbound_reach_;
    ::int32_t inbound_reach_;
    float heading_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};// -------------------------------------------------------------------

class BoundingBox final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.BoundingBox) */ {
 public:
  inline BoundingBox() : BoundingBox(nullptr) {}
  ~BoundingBox() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BoundingBox(::google::protobuf::internal::ConstantInitialized);

  inline BoundingBox(const BoundingBox& from)
      : BoundingBox(nullptr, from) {}
  BoundingBox(BoundingBox&& from) noexcept
    : BoundingBox() {
    *this = ::std::move(from);
  }

  inline BoundingBox& operator=(const BoundingBox& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoundingBox& operator=(BoundingBox&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BoundingBox& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoundingBox* internal_default_instance() {
    return reinterpret_cast<const BoundingBox*>(
               &_BoundingBox_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BoundingBox& a, BoundingBox& b) {
    a.Swap(&b);
  }
  inline void Swap(BoundingBox* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoundingBox* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoundingBox* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BoundingBox>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const BoundingBox& from);
  void MergeFrom(const BoundingBox& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BoundingBox* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.BoundingBox";
  }
  protected:
  explicit BoundingBox(::google::protobuf::Arena* arena);
  BoundingBox(::google::protobuf::Arena* arena, const BoundingBox& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinLlFieldNumber = 1,
    kMaxLlFieldNumber = 2,
  };
  // .valhalla.LatLng min_ll = 1;
  bool has_min_ll() const;
  void clear_min_ll() ;
  const ::valhalla::LatLng& min_ll() const;
  PROTOBUF_NODISCARD ::valhalla::LatLng* release_min_ll();
  ::valhalla::LatLng* mutable_min_ll();
  void set_allocated_min_ll(::valhalla::LatLng* value);
  void unsafe_arena_set_allocated_min_ll(::valhalla::LatLng* value);
  ::valhalla::LatLng* unsafe_arena_release_min_ll();

  private:
  const ::valhalla::LatLng& _internal_min_ll() const;
  ::valhalla::LatLng* _internal_mutable_min_ll();

  public:
  // .valhalla.LatLng max_ll = 2;
  bool has_max_ll() const;
  void clear_max_ll() ;
  const ::valhalla::LatLng& max_ll() const;
  PROTOBUF_NODISCARD ::valhalla::LatLng* release_max_ll();
  ::valhalla::LatLng* mutable_max_ll();
  void set_allocated_max_ll(::valhalla::LatLng* value);
  void unsafe_arena_set_allocated_max_ll(::valhalla::LatLng* value);
  ::valhalla::LatLng* unsafe_arena_release_max_ll();

  private:
  const ::valhalla::LatLng& _internal_max_ll() const;
  ::valhalla::LatLng* _internal_mutable_max_ll();

  public:
  // @@protoc_insertion_point(class_scope:valhalla.BoundingBox)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::valhalla::LatLng* min_ll_;
    ::valhalla::LatLng* max_ll_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};// -------------------------------------------------------------------

class TransitRouteInfo final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TransitRouteInfo) */ {
 public:
  inline TransitRouteInfo() : TransitRouteInfo(nullptr) {}
  ~TransitRouteInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TransitRouteInfo(::google::protobuf::internal::ConstantInitialized);

  inline TransitRouteInfo(const TransitRouteInfo& from)
      : TransitRouteInfo(nullptr, from) {}
  TransitRouteInfo(TransitRouteInfo&& from) noexcept
    : TransitRouteInfo() {
    *this = ::std::move(from);
  }

  inline TransitRouteInfo& operator=(const TransitRouteInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransitRouteInfo& operator=(TransitRouteInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TransitRouteInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransitRouteInfo* internal_default_instance() {
    return reinterpret_cast<const TransitRouteInfo*>(
               &_TransitRouteInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TransitRouteInfo& a, TransitRouteInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TransitRouteInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransitRouteInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransitRouteInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransitRouteInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const TransitRouteInfo& from);
  void MergeFrom(const TransitRouteInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TransitRouteInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.TransitRouteInfo";
  }
  protected:
  explicit TransitRouteInfo(::google::protobuf::Arena* arena);
  TransitRouteInfo(::google::protobuf::Arena* arena, const TransitRouteInfo& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransitStopsFieldNumber = 13,
    kOnestopIdFieldNumber = 1,
    kShortNameFieldNumber = 4,
    kLongNameFieldNumber = 5,
    kHeadsignFieldNumber = 6,
    kDescriptionFieldNumber = 9,
    kOperatorOnestopIdFieldNumber = 10,
    kOperatorNameFieldNumber = 11,
    kOperatorUrlFieldNumber = 12,
    kBlockIdFieldNumber = 2,
    kTripIdFieldNumber = 3,
    kColorFieldNumber = 7,
    kTextColorFieldNumber = 8,
  };
  // repeated .valhalla.TransitPlatformInfo transit_stops = 13;
  int transit_stops_size() const;
  private:
  int _internal_transit_stops_size() const;

  public:
  void clear_transit_stops() ;
  ::valhalla::TransitPlatformInfo* mutable_transit_stops(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::TransitPlatformInfo >*
      mutable_transit_stops();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::TransitPlatformInfo>& _internal_transit_stops() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::TransitPlatformInfo>* _internal_mutable_transit_stops();
  public:
  const ::valhalla::TransitPlatformInfo& transit_stops(int index) const;
  ::valhalla::TransitPlatformInfo* add_transit_stops();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::TransitPlatformInfo >&
      transit_stops() const;
  // string onestop_id = 1;
  void clear_onestop_id() ;
  const std::string& onestop_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_onestop_id(Arg_&& arg, Args_... args);
  std::string* mutable_onestop_id();
  PROTOBUF_NODISCARD std::string* release_onestop_id();
  void set_allocated_onestop_id(std::string* value);

  private:
  const std::string& _internal_onestop_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_onestop_id(
      const std::string& value);
  std::string* _internal_mutable_onestop_id();

  public:
  // string short_name = 4;
  void clear_short_name() ;
  const std::string& short_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_short_name(Arg_&& arg, Args_... args);
  std::string* mutable_short_name();
  PROTOBUF_NODISCARD std::string* release_short_name();
  void set_allocated_short_name(std::string* value);

  private:
  const std::string& _internal_short_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_short_name(
      const std::string& value);
  std::string* _internal_mutable_short_name();

  public:
  // string long_name = 5;
  void clear_long_name() ;
  const std::string& long_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_long_name(Arg_&& arg, Args_... args);
  std::string* mutable_long_name();
  PROTOBUF_NODISCARD std::string* release_long_name();
  void set_allocated_long_name(std::string* value);

  private:
  const std::string& _internal_long_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_long_name(
      const std::string& value);
  std::string* _internal_mutable_long_name();

  public:
  // string headsign = 6;
  void clear_headsign() ;
  const std::string& headsign() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_headsign(Arg_&& arg, Args_... args);
  std::string* mutable_headsign();
  PROTOBUF_NODISCARD std::string* release_headsign();
  void set_allocated_headsign(std::string* value);

  private:
  const std::string& _internal_headsign() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_headsign(
      const std::string& value);
  std::string* _internal_mutable_headsign();

  public:
  // string description = 9;
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* value);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string operator_onestop_id = 10;
  void clear_operator_onestop_id() ;
  const std::string& operator_onestop_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operator_onestop_id(Arg_&& arg, Args_... args);
  std::string* mutable_operator_onestop_id();
  PROTOBUF_NODISCARD std::string* release_operator_onestop_id();
  void set_allocated_operator_onestop_id(std::string* value);

  private:
  const std::string& _internal_operator_onestop_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operator_onestop_id(
      const std::string& value);
  std::string* _internal_mutable_operator_onestop_id();

  public:
  // string operator_name = 11;
  void clear_operator_name() ;
  const std::string& operator_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operator_name(Arg_&& arg, Args_... args);
  std::string* mutable_operator_name();
  PROTOBUF_NODISCARD std::string* release_operator_name();
  void set_allocated_operator_name(std::string* value);

  private:
  const std::string& _internal_operator_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operator_name(
      const std::string& value);
  std::string* _internal_mutable_operator_name();

  public:
  // string operator_url = 12;
  void clear_operator_url() ;
  const std::string& operator_url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operator_url(Arg_&& arg, Args_... args);
  std::string* mutable_operator_url();
  PROTOBUF_NODISCARD std::string* release_operator_url();
  void set_allocated_operator_url(std::string* value);

  private:
  const std::string& _internal_operator_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operator_url(
      const std::string& value);
  std::string* _internal_mutable_operator_url();

  public:
  // uint32 block_id = 2;
  void clear_block_id() ;
  ::uint32_t block_id() const;
  void set_block_id(::uint32_t value);

  private:
  ::uint32_t _internal_block_id() const;
  void _internal_set_block_id(::uint32_t value);

  public:
  // uint32 trip_id = 3;
  void clear_trip_id() ;
  ::uint32_t trip_id() const;
  void set_trip_id(::uint32_t value);

  private:
  ::uint32_t _internal_trip_id() const;
  void _internal_set_trip_id(::uint32_t value);

  public:
  // uint32 color = 7;
  void clear_color() ;
  ::uint32_t color() const;
  void set_color(::uint32_t value);

  private:
  ::uint32_t _internal_color() const;
  void _internal_set_color(::uint32_t value);

  public:
  // uint32 text_color = 8;
  void clear_text_color() ;
  ::uint32_t text_color() const;
  void set_text_color(::uint32_t value);

  private:
  ::uint32_t _internal_text_color() const;
  void _internal_set_text_color(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:valhalla.TransitRouteInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 13, 1,
      134, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::valhalla::TransitPlatformInfo > transit_stops_;
    ::google::protobuf::internal::ArenaStringPtr onestop_id_;
    ::google::protobuf::internal::ArenaStringPtr short_name_;
    ::google::protobuf::internal::ArenaStringPtr long_name_;
    ::google::protobuf::internal::ArenaStringPtr headsign_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::google::protobuf::internal::ArenaStringPtr operator_onestop_id_;
    ::google::protobuf::internal::ArenaStringPtr operator_name_;
    ::google::protobuf::internal::ArenaStringPtr operator_url_;
    ::uint32_t block_id_;
    ::uint32_t trip_id_;
    ::uint32_t color_;
    ::uint32_t text_color_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};// -------------------------------------------------------------------

class Summary final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.Summary) */ {
 public:
  inline Summary() : Summary(nullptr) {}
  ~Summary() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Summary(::google::protobuf::internal::ConstantInitialized);

  inline Summary(const Summary& from)
      : Summary(nullptr, from) {}
  Summary(Summary&& from) noexcept
    : Summary() {
    *this = ::std::move(from);
  }

  inline Summary& operator=(const Summary& from) {
    CopyFrom(from);
    return *this;
  }
  inline Summary& operator=(Summary&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Summary& default_instance() {
    return *internal_default_instance();
  }
  static inline const Summary* internal_default_instance() {
    return reinterpret_cast<const Summary*>(
               &_Summary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Summary& a, Summary& b) {
    a.Swap(&b);
  }
  inline void Swap(Summary* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Summary* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Summary* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Summary>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Summary& from);
  void MergeFrom(const Summary& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Summary* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.Summary";
  }
  protected:
  explicit Summary(::google::protobuf::Arena* arena);
  Summary(::google::protobuf::Arena* arena, const Summary& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBboxFieldNumber = 3,
    kTimeFieldNumber = 2,
    kLengthFieldNumber = 1,
    kHasTimeRestrictionsFieldNumber = 4,
    kHasTollFieldNumber = 5,
    kHasFerryFieldNumber = 6,
    kHasHighwayFieldNumber = 7,
  };
  // .valhalla.BoundingBox bbox = 3;
  bool has_bbox() const;
  void clear_bbox() ;
  const ::valhalla::BoundingBox& bbox() const;
  PROTOBUF_NODISCARD ::valhalla::BoundingBox* release_bbox();
  ::valhalla::BoundingBox* mutable_bbox();
  void set_allocated_bbox(::valhalla::BoundingBox* value);
  void unsafe_arena_set_allocated_bbox(::valhalla::BoundingBox* value);
  ::valhalla::BoundingBox* unsafe_arena_release_bbox();

  private:
  const ::valhalla::BoundingBox& _internal_bbox() const;
  ::valhalla::BoundingBox* _internal_mutable_bbox();

  public:
  // double time = 2;
  void clear_time() ;
  double time() const;
  void set_time(double value);

  private:
  double _internal_time() const;
  void _internal_set_time(double value);

  public:
  // float length = 1;
  void clear_length() ;
  float length() const;
  void set_length(float value);

  private:
  float _internal_length() const;
  void _internal_set_length(float value);

  public:
  // bool has_time_restrictions = 4;
  void clear_has_time_restrictions() ;
  bool has_time_restrictions() const;
  void set_has_time_restrictions(bool value);

  private:
  bool _internal_has_time_restrictions() const;
  void _internal_set_has_time_restrictions(bool value);

  public:
  // bool has_toll = 5;
  void clear_has_toll() ;
  bool has_toll() const;
  void set_has_toll(bool value);

  private:
  bool _internal_has_toll() const;
  void _internal_set_has_toll(bool value);

  public:
  // bool has_ferry = 6;
  void clear_has_ferry() ;
  bool has_ferry() const;
  void set_has_ferry(bool value);

  private:
  bool _internal_has_ferry() const;
  void _internal_set_has_ferry(bool value);

  public:
  // bool has_highway = 7;
  void clear_has_highway() ;
  bool has_highway() const;
  void set_has_highway(bool value);

  private:
  bool _internal_has_highway() const;
  void _internal_set_has_highway(bool value);

  public:
  // @@protoc_insertion_point(class_scope:valhalla.Summary)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::valhalla::BoundingBox* bbox_;
    double time_;
    float length_;
    bool has_time_restrictions_;
    bool has_toll_;
    bool has_ferry_;
    bool has_highway_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};// -------------------------------------------------------------------

class Correlation final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.Correlation) */ {
 public:
  inline Correlation() : Correlation(nullptr) {}
  ~Correlation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Correlation(::google::protobuf::internal::ConstantInitialized);

  inline Correlation(const Correlation& from)
      : Correlation(nullptr, from) {}
  Correlation(Correlation&& from) noexcept
    : Correlation() {
    *this = ::std::move(from);
  }

  inline Correlation& operator=(const Correlation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Correlation& operator=(Correlation&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Correlation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Correlation* internal_default_instance() {
    return reinterpret_cast<const Correlation*>(
               &_Correlation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Correlation& a, Correlation& b) {
    a.Swap(&b);
  }
  inline void Swap(Correlation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Correlation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Correlation* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Correlation>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Correlation& from);
  void MergeFrom(const Correlation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Correlation* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.Correlation";
  }
  protected:
  explicit Correlation(::google::protobuf::Arena* arena);
  Correlation(::google::protobuf::Arena* arena, const Correlation& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEdgesFieldNumber = 1,
    kFilteredEdgesFieldNumber = 2,
    kProjectedLlFieldNumber = 4,
    kOriginalIndexFieldNumber = 3,
    kLegShapeIndexFieldNumber = 5,
    kDistanceFromLegOriginFieldNumber = 6,
    kRouteIndexFieldNumber = 7,
    kWaypointIndexFieldNumber = 8,
  };
  // repeated .valhalla.PathEdge edges = 1;
  int edges_size() const;
  private:
  int _internal_edges_size() const;

  public:
  void clear_edges() ;
  ::valhalla::PathEdge* mutable_edges(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::PathEdge >*
      mutable_edges();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::PathEdge>& _internal_edges() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::PathEdge>* _internal_mutable_edges();
  public:
  const ::valhalla::PathEdge& edges(int index) const;
  ::valhalla::PathEdge* add_edges();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::PathEdge >&
      edges() const;
  // repeated .valhalla.PathEdge filtered_edges = 2;
  int filtered_edges_size() const;
  private:
  int _internal_filtered_edges_size() const;

  public:
  void clear_filtered_edges() ;
  ::valhalla::PathEdge* mutable_filtered_edges(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::PathEdge >*
      mutable_filtered_edges();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::PathEdge>& _internal_filtered_edges() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::PathEdge>* _internal_mutable_filtered_edges();
  public:
  const ::valhalla::PathEdge& filtered_edges(int index) const;
  ::valhalla::PathEdge* add_filtered_edges();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::PathEdge >&
      filtered_edges() const;
  // .valhalla.LatLng projected_ll = 4;
  bool has_projected_ll() const;
  void clear_projected_ll() ;
  const ::valhalla::LatLng& projected_ll() const;
  PROTOBUF_NODISCARD ::valhalla::LatLng* release_projected_ll();
  ::valhalla::LatLng* mutable_projected_ll();
  void set_allocated_projected_ll(::valhalla::LatLng* value);
  void unsafe_arena_set_allocated_projected_ll(::valhalla::LatLng* value);
  ::valhalla::LatLng* unsafe_arena_release_projected_ll();

  private:
  const ::valhalla::LatLng& _internal_projected_ll() const;
  ::valhalla::LatLng* _internal_mutable_projected_ll();

  public:
  // uint32 original_index = 3;
  void clear_original_index() ;
  ::uint32_t original_index() const;
  void set_original_index(::uint32_t value);

  private:
  ::uint32_t _internal_original_index() const;
  void _internal_set_original_index(::uint32_t value);

  public:
  // uint32 leg_shape_index = 5;
  void clear_leg_shape_index() ;
  ::uint32_t leg_shape_index() const;
  void set_leg_shape_index(::uint32_t value);

  private:
  ::uint32_t _internal_leg_shape_index() const;
  void _internal_set_leg_shape_index(::uint32_t value);

  public:
  // double distance_from_leg_origin = 6;
  void clear_distance_from_leg_origin() ;
  double distance_from_leg_origin() const;
  void set_distance_from_leg_origin(double value);

  private:
  double _internal_distance_from_leg_origin() const;
  void _internal_set_distance_from_leg_origin(double value);

  public:
  // uint32 route_index = 7;
  void clear_route_index() ;
  ::uint32_t route_index() const;
  void set_route_index(::uint32_t value);

  private:
  ::uint32_t _internal_route_index() const;
  void _internal_set_route_index(::uint32_t value);

  public:
  // uint32 waypoint_index = 8;
  void clear_waypoint_index() ;
  ::uint32_t waypoint_index() const;
  void set_waypoint_index(::uint32_t value);

  private:
  ::uint32_t _internal_waypoint_index() const;
  void _internal_set_waypoint_index(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:valhalla.Correlation)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::PathEdge > edges_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::PathEdge > filtered_edges_;
    ::valhalla::LatLng* projected_ll_;
    ::uint32_t original_index_;
    ::uint32_t leg_shape_index_;
    double distance_from_leg_origin_;
    ::uint32_t route_index_;
    ::uint32_t waypoint_index_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};// -------------------------------------------------------------------

class Location final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.Location) */ {
 public:
  inline Location() : Location(nullptr) {}
  ~Location() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Location(::google::protobuf::internal::ConstantInitialized);

  inline Location(const Location& from)
      : Location(nullptr, from) {}
  Location(Location&& from) noexcept
    : Location() {
    *this = ::std::move(from);
  }

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }
  inline Location& operator=(Location&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Location& default_instance() {
    return *internal_default_instance();
  }
  enum HasHeadingCase {
    kHeading = 3,
    HAS_HEADING_NOT_SET = 0,
  };

  enum HasHeadingToleranceCase {
    kHeadingTolerance = 14,
    HAS_HEADING_TOLERANCE_NOT_SET = 0,
  };

  enum HasNodeSnapToleranceCase {
    kNodeSnapTolerance = 15,
    HAS_NODE_SNAP_TOLERANCE_NOT_SET = 0,
  };

  enum HasMinimumReachabilityCase {
    kMinimumReachability = 17,
    HAS_MINIMUM_REACHABILITY_NOT_SET = 0,
  };

  enum HasRadiusCase {
    kRadius = 18,
    HAS_RADIUS_NOT_SET = 0,
  };

  enum HasAccuracyCase {
    kAccuracy = 19,
    HAS_ACCURACY_NOT_SET = 0,
  };

  enum HasTimeCase {
    kTime = 20,
    HAS_TIME_NOT_SET = 0,
  };

  enum HasSearchCutoffCase {
    kSearchCutoff = 24,
    HAS_SEARCH_CUTOFF_NOT_SET = 0,
  };

  enum HasStreetSideToleranceCase {
    kStreetSideTolerance = 25,
    HAS_STREET_SIDE_TOLERANCE_NOT_SET = 0,
  };

  enum HasStreetSideMaxDistanceCase {
    kStreetSideMaxDistance = 27,
    HAS_STREET_SIDE_MAX_DISTANCE_NOT_SET = 0,
  };

  enum HasPreferredLayerCase {
    kPreferredLayer = 28,
    HAS_PREFERRED_LAYER_NOT_SET = 0,
  };

  enum HasStreetSideCutoffCase {
    kStreetSideCutoff = 30,
    HAS_STREET_SIDE_CUTOFF_NOT_SET = 0,
  };

  static inline const Location* internal_default_instance() {
    return reinterpret_cast<const Location*>(
               &_Location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Location& a, Location& b) {
    a.Swap(&b);
  }
  inline void Swap(Location* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Location* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Location* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Location>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Location& from);
  void MergeFrom(const Location& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Location* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.Location";
  }
  protected:
  explicit Location(::google::protobuf::Arena* arena);
  Location(::google::protobuf::Arena* arena, const Location& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using Type = Location_Type;
  static constexpr Type kBreak = Location_Type_kBreak;
  static constexpr Type kThrough = Location_Type_kThrough;
  static constexpr Type kVia = Location_Type_kVia;
  static constexpr Type kBreakThrough = Location_Type_kBreakThrough;
  static inline bool Type_IsValid(int value) {
    return Location_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = Location_Type_Type_MIN;
  static constexpr Type Type_MAX = Location_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = Location_Type_Type_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return Location_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return Location_Type_Parse(name, value);
  }

  using PreferredSide = Location_PreferredSide;
  static constexpr PreferredSide either = Location_PreferredSide_either;
  static constexpr PreferredSide same = Location_PreferredSide_same;
  static constexpr PreferredSide opposite = Location_PreferredSide_opposite;
  static inline bool PreferredSide_IsValid(int value) {
    return Location_PreferredSide_IsValid(value);
  }
  static constexpr PreferredSide PreferredSide_MIN = Location_PreferredSide_PreferredSide_MIN;
  static constexpr PreferredSide PreferredSide_MAX = Location_PreferredSide_PreferredSide_MAX;
  static constexpr int PreferredSide_ARRAYSIZE = Location_PreferredSide_PreferredSide_ARRAYSIZE;
  template <typename T>
  static inline const std::string& PreferredSide_Name(T value) {
    return Location_PreferredSide_Name(value);
  }
  static inline bool PreferredSide_Parse(absl::string_view name, PreferredSide* value) {
    return Location_PreferredSide_Parse(name, value);
  }

  using SideOfStreet = Location_SideOfStreet;
  static constexpr SideOfStreet kNone = Location_SideOfStreet_kNone;
  static constexpr SideOfStreet kLeft = Location_SideOfStreet_kLeft;
  static constexpr SideOfStreet kRight = Location_SideOfStreet_kRight;
  static inline bool SideOfStreet_IsValid(int value) {
    return Location_SideOfStreet_IsValid(value);
  }
  static constexpr SideOfStreet SideOfStreet_MIN = Location_SideOfStreet_SideOfStreet_MIN;
  static constexpr SideOfStreet SideOfStreet_MAX = Location_SideOfStreet_SideOfStreet_MAX;
  static constexpr int SideOfStreet_ARRAYSIZE = Location_SideOfStreet_SideOfStreet_ARRAYSIZE;
  template <typename T>
  static inline const std::string& SideOfStreet_Name(T value) {
    return Location_SideOfStreet_Name(value);
  }
  static inline bool SideOfStreet_Parse(absl::string_view name, SideOfStreet* value) {
    return Location_SideOfStreet_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 4,
    kStreetFieldNumber = 5,
    kDateTimeFieldNumber = 12,
    kTimeZoneOffsetFieldNumber = 91,
    kTimeZoneNameFieldNumber = 92,
    kLlFieldNumber = 1,
    kDisplayLlFieldNumber = 23,
    kSearchFilterFieldNumber = 26,
    kCorrelationFieldNumber = 90,
    kTypeFieldNumber = 2,
    kSideOfStreetFieldNumber = 13,
    kSkipRankingCandidatesFieldNumber = 21,
    kPreferredSideFieldNumber = 22,
    kWaitingSecsFieldNumber = 29,
    kHeadingFieldNumber = 3,
    kHeadingToleranceFieldNumber = 14,
    kNodeSnapToleranceFieldNumber = 15,
    kMinimumReachabilityFieldNumber = 17,
    kRadiusFieldNumber = 18,
    kAccuracyFieldNumber = 19,
    kTimeFieldNumber = 20,
    kSearchCutoffFieldNumber = 24,
    kStreetSideToleranceFieldNumber = 25,
    kStreetSideMaxDistanceFieldNumber = 27,
    kPreferredLayerFieldNumber = 28,
    kStreetSideCutoffFieldNumber = 30,
  };
  // string name = 4;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string street = 5;
  void clear_street() ;
  const std::string& street() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_street(Arg_&& arg, Args_... args);
  std::string* mutable_street();
  PROTOBUF_NODISCARD std::string* release_street();
  void set_allocated_street(std::string* value);

  private:
  const std::string& _internal_street() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_street(
      const std::string& value);
  std::string* _internal_mutable_street();

  public:
  // string date_time = 12;
  void clear_date_time() ;
  const std::string& date_time() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_date_time(Arg_&& arg, Args_... args);
  std::string* mutable_date_time();
  PROTOBUF_NODISCARD std::string* release_date_time();
  void set_allocated_date_time(std::string* value);

  private:
  const std::string& _internal_date_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_date_time(
      const std::string& value);
  std::string* _internal_mutable_date_time();

  public:
  // string time_zone_offset = 91;
  void clear_time_zone_offset() ;
  const std::string& time_zone_offset() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_time_zone_offset(Arg_&& arg, Args_... args);
  std::string* mutable_time_zone_offset();
  PROTOBUF_NODISCARD std::string* release_time_zone_offset();
  void set_allocated_time_zone_offset(std::string* value);

  private:
  const std::string& _internal_time_zone_offset() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time_zone_offset(
      const std::string& value);
  std::string* _internal_mutable_time_zone_offset();

  public:
  // string time_zone_name = 92;
  void clear_time_zone_name() ;
  const std::string& time_zone_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_time_zone_name(Arg_&& arg, Args_... args);
  std::string* mutable_time_zone_name();
  PROTOBUF_NODISCARD std::string* release_time_zone_name();
  void set_allocated_time_zone_name(std::string* value);

  private:
  const std::string& _internal_time_zone_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time_zone_name(
      const std::string& value);
  std::string* _internal_mutable_time_zone_name();

  public:
  // .valhalla.LatLng ll = 1;
  bool has_ll() const;
  void clear_ll() ;
  const ::valhalla::LatLng& ll() const;
  PROTOBUF_NODISCARD ::valhalla::LatLng* release_ll();
  ::valhalla::LatLng* mutable_ll();
  void set_allocated_ll(::valhalla::LatLng* value);
  void unsafe_arena_set_allocated_ll(::valhalla::LatLng* value);
  ::valhalla::LatLng* unsafe_arena_release_ll();

  private:
  const ::valhalla::LatLng& _internal_ll() const;
  ::valhalla::LatLng* _internal_mutable_ll();

  public:
  // .valhalla.LatLng display_ll = 23;
  bool has_display_ll() const;
  void clear_display_ll() ;
  const ::valhalla::LatLng& display_ll() const;
  PROTOBUF_NODISCARD ::valhalla::LatLng* release_display_ll();
  ::valhalla::LatLng* mutable_display_ll();
  void set_allocated_display_ll(::valhalla::LatLng* value);
  void unsafe_arena_set_allocated_display_ll(::valhalla::LatLng* value);
  ::valhalla::LatLng* unsafe_arena_release_display_ll();

  private:
  const ::valhalla::LatLng& _internal_display_ll() const;
  ::valhalla::LatLng* _internal_mutable_display_ll();

  public:
  // .valhalla.SearchFilter search_filter = 26;
  bool has_search_filter() const;
  void clear_search_filter() ;
  const ::valhalla::SearchFilter& search_filter() const;
  PROTOBUF_NODISCARD ::valhalla::SearchFilter* release_search_filter();
  ::valhalla::SearchFilter* mutable_search_filter();
  void set_allocated_search_filter(::valhalla::SearchFilter* value);
  void unsafe_arena_set_allocated_search_filter(::valhalla::SearchFilter* value);
  ::valhalla::SearchFilter* unsafe_arena_release_search_filter();

  private:
  const ::valhalla::SearchFilter& _internal_search_filter() const;
  ::valhalla::SearchFilter* _internal_mutable_search_filter();

  public:
  // .valhalla.Correlation correlation = 90;
  bool has_correlation() const;
  void clear_correlation() ;
  const ::valhalla::Correlation& correlation() const;
  PROTOBUF_NODISCARD ::valhalla::Correlation* release_correlation();
  ::valhalla::Correlation* mutable_correlation();
  void set_allocated_correlation(::valhalla::Correlation* value);
  void unsafe_arena_set_allocated_correlation(::valhalla::Correlation* value);
  ::valhalla::Correlation* unsafe_arena_release_correlation();

  private:
  const ::valhalla::Correlation& _internal_correlation() const;
  ::valhalla::Correlation* _internal_mutable_correlation();

  public:
  // .valhalla.Location.Type type = 2;
  void clear_type() ;
  ::valhalla::Location_Type type() const;
  void set_type(::valhalla::Location_Type value);

  private:
  ::valhalla::Location_Type _internal_type() const;
  void _internal_set_type(::valhalla::Location_Type value);

  public:
  // .valhalla.Location.SideOfStreet side_of_street = 13;
  void clear_side_of_street() ;
  ::valhalla::Location_SideOfStreet side_of_street() const;
  void set_side_of_street(::valhalla::Location_SideOfStreet value);

  private:
  ::valhalla::Location_SideOfStreet _internal_side_of_street() const;
  void _internal_set_side_of_street(::valhalla::Location_SideOfStreet value);

  public:
  // bool skip_ranking_candidates = 21;
  void clear_skip_ranking_candidates() ;
  bool skip_ranking_candidates() const;
  void set_skip_ranking_candidates(bool value);

  private:
  bool _internal_skip_ranking_candidates() const;
  void _internal_set_skip_ranking_candidates(bool value);

  public:
  // .valhalla.Location.PreferredSide preferred_side = 22;
  void clear_preferred_side() ;
  ::valhalla::Location_PreferredSide preferred_side() const;
  void set_preferred_side(::valhalla::Location_PreferredSide value);

  private:
  ::valhalla::Location_PreferredSide _internal_preferred_side() const;
  void _internal_set_preferred_side(::valhalla::Location_PreferredSide value);

  public:
  // float waiting_secs = 29;
  void clear_waiting_secs() ;
  float waiting_secs() const;
  void set_waiting_secs(float value);

  private:
  float _internal_waiting_secs() const;
  void _internal_set_waiting_secs(float value);

  public:
  // uint32 heading = 3;
  bool has_heading() const;
  void clear_heading() ;
  ::uint32_t heading() const;
  void set_heading(::uint32_t value);

  private:
  ::uint32_t _internal_heading() const;
  void _internal_set_heading(::uint32_t value);

  public:
  // uint32 heading_tolerance = 14;
  bool has_heading_tolerance() const;
  void clear_heading_tolerance() ;
  ::uint32_t heading_tolerance() const;
  void set_heading_tolerance(::uint32_t value);

  private:
  ::uint32_t _internal_heading_tolerance() const;
  void _internal_set_heading_tolerance(::uint32_t value);

  public:
  // uint32 node_snap_tolerance = 15;
  bool has_node_snap_tolerance() const;
  void clear_node_snap_tolerance() ;
  ::uint32_t node_snap_tolerance() const;
  void set_node_snap_tolerance(::uint32_t value);

  private:
  ::uint32_t _internal_node_snap_tolerance() const;
  void _internal_set_node_snap_tolerance(::uint32_t value);

  public:
  // uint32 minimum_reachability = 17;
  bool has_minimum_reachability() const;
  void clear_minimum_reachability() ;
  ::uint32_t minimum_reachability() const;
  void set_minimum_reachability(::uint32_t value);

  private:
  ::uint32_t _internal_minimum_reachability() const;
  void _internal_set_minimum_reachability(::uint32_t value);

  public:
  // uint32 radius = 18;
  bool has_radius() const;
  void clear_radius() ;
  ::uint32_t radius() const;
  void set_radius(::uint32_t value);

  private:
  ::uint32_t _internal_radius() const;
  void _internal_set_radius(::uint32_t value);

  public:
  // uint32 accuracy = 19;
  bool has_accuracy() const;
  void clear_accuracy() ;
  ::uint32_t accuracy() const;
  void set_accuracy(::uint32_t value);

  private:
  ::uint32_t _internal_accuracy() const;
  void _internal_set_accuracy(::uint32_t value);

  public:
  // double time = 20;
  bool has_time() const;
  void clear_time() ;
  double time() const;
  void set_time(double value);

  private:
  double _internal_time() const;
  void _internal_set_time(double value);

  public:
  // uint32 search_cutoff = 24;
  bool has_search_cutoff() const;
  void clear_search_cutoff() ;
  ::uint32_t search_cutoff() const;
  void set_search_cutoff(::uint32_t value);

  private:
  ::uint32_t _internal_search_cutoff() const;
  void _internal_set_search_cutoff(::uint32_t value);

  public:
  // uint32 street_side_tolerance = 25;
  bool has_street_side_tolerance() const;
  void clear_street_side_tolerance() ;
  ::uint32_t street_side_tolerance() const;
  void set_street_side_tolerance(::uint32_t value);

  private:
  ::uint32_t _internal_street_side_tolerance() const;
  void _internal_set_street_side_tolerance(::uint32_t value);

  public:
  // uint32 street_side_max_distance = 27;
  bool has_street_side_max_distance() const;
  void clear_street_side_max_distance() ;
  ::uint32_t street_side_max_distance() const;
  void set_street_side_max_distance(::uint32_t value);

  private:
  ::uint32_t _internal_street_side_max_distance() const;
  void _internal_set_street_side_max_distance(::uint32_t value);

  public:
  // int32 preferred_layer = 28;
  bool has_preferred_layer() const;
  void clear_preferred_layer() ;
  ::int32_t preferred_layer() const;
  void set_preferred_layer(::int32_t value);

  private:
  ::int32_t _internal_preferred_layer() const;
  void _internal_set_preferred_layer(::int32_t value);

  public:
  // .valhalla.RoadClass street_side_cutoff = 30;
  bool has_street_side_cutoff() const;
  void clear_street_side_cutoff() ;
  ::valhalla::RoadClass street_side_cutoff() const;
  void set_street_side_cutoff(::valhalla::RoadClass value);

  private:
  ::valhalla::RoadClass _internal_street_side_cutoff() const;
  void _internal_set_street_side_cutoff(::valhalla::RoadClass value);

  public:
  void clear_has_heading();
  HasHeadingCase has_heading_case() const;
  void clear_has_heading_tolerance();
  HasHeadingToleranceCase has_heading_tolerance_case() const;
  void clear_has_node_snap_tolerance();
  HasNodeSnapToleranceCase has_node_snap_tolerance_case() const;
  void clear_has_minimum_reachability();
  HasMinimumReachabilityCase has_minimum_reachability_case() const;
  void clear_has_radius();
  HasRadiusCase has_radius_case() const;
  void clear_has_accuracy();
  HasAccuracyCase has_accuracy_case() const;
  void clear_has_time();
  HasTimeCase has_time_case() const;
  void clear_has_search_cutoff();
  HasSearchCutoffCase has_search_cutoff_case() const;
  void clear_has_street_side_tolerance();
  HasStreetSideToleranceCase has_street_side_tolerance_case() const;
  void clear_has_street_side_max_distance();
  HasStreetSideMaxDistanceCase has_street_side_max_distance_case() const;
  void clear_has_preferred_layer();
  HasPreferredLayerCase has_preferred_layer_case() const;
  void clear_has_street_side_cutoff();
  HasStreetSideCutoffCase has_street_side_cutoff_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.Location)
 private:
  class _Internal;
  void set_has_heading();
  void set_has_heading_tolerance();
  void set_has_node_snap_tolerance();
  void set_has_minimum_reachability();
  void set_has_radius();
  void set_has_accuracy();
  void set_has_time();
  void set_has_search_cutoff();
  void set_has_street_side_tolerance();
  void set_has_street_side_max_distance();
  void set_has_preferred_layer();
  void set_has_street_side_cutoff();

  inline bool has_has_heading() const;
  inline void clear_has_has_heading();

  inline bool has_has_heading_tolerance() const;
  inline void clear_has_has_heading_tolerance();

  inline bool has_has_node_snap_tolerance() const;
  inline void clear_has_has_node_snap_tolerance();

  inline bool has_has_minimum_reachability() const;
  inline void clear_has_has_minimum_reachability();

  inline bool has_has_radius() const;
  inline void clear_has_has_radius();

  inline bool has_has_accuracy() const;
  inline void clear_has_has_accuracy();

  inline bool has_has_time() const;
  inline void clear_has_has_time();

  inline bool has_has_search_cutoff() const;
  inline void clear_has_has_search_cutoff();

  inline bool has_has_street_side_tolerance() const;
  inline void clear_has_has_street_side_tolerance();

  inline bool has_has_street_side_max_distance() const;
  inline void clear_has_has_street_side_max_distance();

  inline bool has_has_preferred_layer() const;
  inline void clear_has_has_preferred_layer();

  inline bool has_has_street_side_cutoff() const;
  inline void clear_has_has_street_side_cutoff();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 26, 4,
      99, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr street_;
    ::google::protobuf::internal::ArenaStringPtr date_time_;
    ::google::protobuf::internal::ArenaStringPtr time_zone_offset_;
    ::google::protobuf::internal::ArenaStringPtr time_zone_name_;
    ::valhalla::LatLng* ll_;
    ::valhalla::LatLng* display_ll_;
    ::valhalla::SearchFilter* search_filter_;
    ::valhalla::Correlation* correlation_;
    int type_;
    int side_of_street_;
    bool skip_ranking_candidates_;
    int preferred_side_;
    float waiting_secs_;
    union HasHeadingUnion {
      constexpr HasHeadingUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint32_t heading_;
    } has_heading_;
    union HasHeadingToleranceUnion {
      constexpr HasHeadingToleranceUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint32_t heading_tolerance_;
    } has_heading_tolerance_;
    union HasNodeSnapToleranceUnion {
      constexpr HasNodeSnapToleranceUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint32_t node_snap_tolerance_;
    } has_node_snap_tolerance_;
    union HasMinimumReachabilityUnion {
      constexpr HasMinimumReachabilityUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint32_t minimum_reachability_;
    } has_minimum_reachability_;
    union HasRadiusUnion {
      constexpr HasRadiusUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint32_t radius_;
    } has_radius_;
    union HasAccuracyUnion {
      constexpr HasAccuracyUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint32_t accuracy_;
    } has_accuracy_;
    union HasTimeUnion {
      constexpr HasTimeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      double time_;
    } has_time_;
    union HasSearchCutoffUnion {
      constexpr HasSearchCutoffUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint32_t search_cutoff_;
    } has_search_cutoff_;
    union HasStreetSideToleranceUnion {
      constexpr HasStreetSideToleranceUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint32_t street_side_tolerance_;
    } has_street_side_tolerance_;
    union HasStreetSideMaxDistanceUnion {
      constexpr HasStreetSideMaxDistanceUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint32_t street_side_max_distance_;
    } has_street_side_max_distance_;
    union HasPreferredLayerUnion {
      constexpr HasPreferredLayerUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int32_t preferred_layer_;
    } has_preferred_layer_;
    union HasStreetSideCutoffUnion {
      constexpr HasStreetSideCutoffUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      int street_side_cutoff_;
    } has_street_side_cutoff_;
    ::uint32_t _oneof_case_[12];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// LatLng

// double lat = 1;
inline bool LatLng::has_lat() const {
  return has_lat_case() == kLat;
}
inline void LatLng::set_has_lat() {
  _impl_._oneof_case_[0] = kLat;
}
inline void LatLng::clear_lat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_lat_case() == kLat) {
    _impl_.has_lat_.lat_ = 0;
    clear_has_has_lat();
  }
}
inline double LatLng::lat() const {
  // @@protoc_insertion_point(field_get:valhalla.LatLng.lat)
  return _internal_lat();
}
inline void LatLng::set_lat(double value) {
  _internal_set_lat(value);
  // @@protoc_insertion_point(field_set:valhalla.LatLng.lat)
}
inline double LatLng::_internal_lat() const {
  if (has_lat_case() == kLat) {
    return _impl_.has_lat_.lat_;
  }
  return 0;
}
inline void LatLng::_internal_set_lat(double value) {
  if (has_lat_case() != kLat) {
    clear_has_lat();
    set_has_lat();
  }
  _impl_.has_lat_.lat_ = value;
}

// double lng = 2;
inline bool LatLng::has_lng() const {
  return has_lng_case() == kLng;
}
inline void LatLng::set_has_lng() {
  _impl_._oneof_case_[1] = kLng;
}
inline void LatLng::clear_lng() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_lng_case() == kLng) {
    _impl_.has_lng_.lng_ = 0;
    clear_has_has_lng();
  }
}
inline double LatLng::lng() const {
  // @@protoc_insertion_point(field_get:valhalla.LatLng.lng)
  return _internal_lng();
}
inline void LatLng::set_lng(double value) {
  _internal_set_lng(value);
  // @@protoc_insertion_point(field_set:valhalla.LatLng.lng)
}
inline double LatLng::_internal_lng() const {
  if (has_lng_case() == kLng) {
    return _impl_.has_lng_.lng_;
  }
  return 0;
}
inline void LatLng::_internal_set_lng(double value) {
  if (has_lng_case() != kLng) {
    clear_has_lng();
    set_has_lng();
  }
  _impl_.has_lng_.lng_ = value;
}

inline bool LatLng::has_has_lat() const {
  return has_lat_case() != HAS_LAT_NOT_SET;
}
inline void LatLng::clear_has_has_lat() {
  _impl_._oneof_case_[0] = HAS_LAT_NOT_SET;
}
inline bool LatLng::has_has_lng() const {
  return has_lng_case() != HAS_LNG_NOT_SET;
}
inline void LatLng::clear_has_has_lng() {
  _impl_._oneof_case_[1] = HAS_LNG_NOT_SET;
}
inline LatLng::HasLatCase LatLng::has_lat_case() const {
  return LatLng::HasLatCase(_impl_._oneof_case_[0]);
}
inline LatLng::HasLngCase LatLng::has_lng_case() const {
  return LatLng::HasLngCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// RouteLandmark

// string name = 1;
inline void RouteLandmark::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RouteLandmark::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.RouteLandmark.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouteLandmark::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.RouteLandmark.name)
}
inline std::string* RouteLandmark::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:valhalla.RouteLandmark.name)
  return _s;
}
inline const std::string& RouteLandmark::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void RouteLandmark::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* RouteLandmark::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* RouteLandmark::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.RouteLandmark.name)
  return _impl_.name_.Release();
}
inline void RouteLandmark::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.RouteLandmark.name)
}

// .valhalla.RouteLandmark.Type type = 2;
inline void RouteLandmark::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::valhalla::RouteLandmark_Type RouteLandmark::type() const {
  // @@protoc_insertion_point(field_get:valhalla.RouteLandmark.type)
  return _internal_type();
}
inline void RouteLandmark::set_type(::valhalla::RouteLandmark_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:valhalla.RouteLandmark.type)
}
inline ::valhalla::RouteLandmark_Type RouteLandmark::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::RouteLandmark_Type>(_impl_.type_);
}
inline void RouteLandmark::_internal_set_type(::valhalla::RouteLandmark_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// .valhalla.LatLng lat_lng = 3;
inline bool RouteLandmark::has_lat_lng() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lat_lng_ != nullptr);
  return value;
}
inline void RouteLandmark::clear_lat_lng() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.lat_lng_ != nullptr) _impl_.lat_lng_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::valhalla::LatLng& RouteLandmark::_internal_lat_lng() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::LatLng* p = _impl_.lat_lng_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::LatLng&>(::valhalla::_LatLng_default_instance_);
}
inline const ::valhalla::LatLng& RouteLandmark::lat_lng() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.RouteLandmark.lat_lng)
  return _internal_lat_lng();
}
inline void RouteLandmark::unsafe_arena_set_allocated_lat_lng(::valhalla::LatLng* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lat_lng_);
  }
  _impl_.lat_lng_ = reinterpret_cast<::valhalla::LatLng*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.RouteLandmark.lat_lng)
}
inline ::valhalla::LatLng* RouteLandmark::release_lat_lng() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::LatLng* released = _impl_.lat_lng_;
  _impl_.lat_lng_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::LatLng* RouteLandmark::unsafe_arena_release_lat_lng() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.RouteLandmark.lat_lng)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::LatLng* temp = _impl_.lat_lng_;
  _impl_.lat_lng_ = nullptr;
  return temp;
}
inline ::valhalla::LatLng* RouteLandmark::_internal_mutable_lat_lng() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.lat_lng_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::LatLng>(GetArena());
    _impl_.lat_lng_ = reinterpret_cast<::valhalla::LatLng*>(p);
  }
  return _impl_.lat_lng_;
}
inline ::valhalla::LatLng* RouteLandmark::mutable_lat_lng() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::LatLng* _msg = _internal_mutable_lat_lng();
  // @@protoc_insertion_point(field_mutable:valhalla.RouteLandmark.lat_lng)
  return _msg;
}
inline void RouteLandmark::set_allocated_lat_lng(::valhalla::LatLng* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::valhalla::LatLng*>(_impl_.lat_lng_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::valhalla::LatLng*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.lat_lng_ = reinterpret_cast<::valhalla::LatLng*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.RouteLandmark.lat_lng)
}

// double distance = 4;
inline void RouteLandmark::clear_distance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.distance_ = 0;
}
inline double RouteLandmark::distance() const {
  // @@protoc_insertion_point(field_get:valhalla.RouteLandmark.distance)
  return _internal_distance();
}
inline void RouteLandmark::set_distance(double value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:valhalla.RouteLandmark.distance)
}
inline double RouteLandmark::_internal_distance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.distance_;
}
inline void RouteLandmark::_internal_set_distance(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.distance_ = value;
}

// bool right = 5;
inline void RouteLandmark::clear_right() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.right_ = false;
}
inline bool RouteLandmark::right() const {
  // @@protoc_insertion_point(field_get:valhalla.RouteLandmark.right)
  return _internal_right();
}
inline void RouteLandmark::set_right(bool value) {
  _internal_set_right(value);
  // @@protoc_insertion_point(field_set:valhalla.RouteLandmark.right)
}
inline bool RouteLandmark::_internal_right() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.right_;
}
inline void RouteLandmark::_internal_set_right(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.right_ = value;
}

// -------------------------------------------------------------------

// BoundingBox

// .valhalla.LatLng min_ll = 1;
inline bool BoundingBox::has_min_ll() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.min_ll_ != nullptr);
  return value;
}
inline void BoundingBox::clear_min_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.min_ll_ != nullptr) _impl_.min_ll_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::valhalla::LatLng& BoundingBox::_internal_min_ll() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::LatLng* p = _impl_.min_ll_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::LatLng&>(::valhalla::_LatLng_default_instance_);
}
inline const ::valhalla::LatLng& BoundingBox::min_ll() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.BoundingBox.min_ll)
  return _internal_min_ll();
}
inline void BoundingBox::unsafe_arena_set_allocated_min_ll(::valhalla::LatLng* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.min_ll_);
  }
  _impl_.min_ll_ = reinterpret_cast<::valhalla::LatLng*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.BoundingBox.min_ll)
}
inline ::valhalla::LatLng* BoundingBox::release_min_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::LatLng* released = _impl_.min_ll_;
  _impl_.min_ll_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::LatLng* BoundingBox::unsafe_arena_release_min_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.BoundingBox.min_ll)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::LatLng* temp = _impl_.min_ll_;
  _impl_.min_ll_ = nullptr;
  return temp;
}
inline ::valhalla::LatLng* BoundingBox::_internal_mutable_min_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.min_ll_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::LatLng>(GetArena());
    _impl_.min_ll_ = reinterpret_cast<::valhalla::LatLng*>(p);
  }
  return _impl_.min_ll_;
}
inline ::valhalla::LatLng* BoundingBox::mutable_min_ll() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::LatLng* _msg = _internal_mutable_min_ll();
  // @@protoc_insertion_point(field_mutable:valhalla.BoundingBox.min_ll)
  return _msg;
}
inline void BoundingBox::set_allocated_min_ll(::valhalla::LatLng* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::valhalla::LatLng*>(_impl_.min_ll_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::valhalla::LatLng*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.min_ll_ = reinterpret_cast<::valhalla::LatLng*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.BoundingBox.min_ll)
}

// .valhalla.LatLng max_ll = 2;
inline bool BoundingBox::has_max_ll() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.max_ll_ != nullptr);
  return value;
}
inline void BoundingBox::clear_max_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.max_ll_ != nullptr) _impl_.max_ll_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::valhalla::LatLng& BoundingBox::_internal_max_ll() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::LatLng* p = _impl_.max_ll_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::LatLng&>(::valhalla::_LatLng_default_instance_);
}
inline const ::valhalla::LatLng& BoundingBox::max_ll() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.BoundingBox.max_ll)
  return _internal_max_ll();
}
inline void BoundingBox::unsafe_arena_set_allocated_max_ll(::valhalla::LatLng* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.max_ll_);
  }
  _impl_.max_ll_ = reinterpret_cast<::valhalla::LatLng*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.BoundingBox.max_ll)
}
inline ::valhalla::LatLng* BoundingBox::release_max_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::valhalla::LatLng* released = _impl_.max_ll_;
  _impl_.max_ll_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::LatLng* BoundingBox::unsafe_arena_release_max_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.BoundingBox.max_ll)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::valhalla::LatLng* temp = _impl_.max_ll_;
  _impl_.max_ll_ = nullptr;
  return temp;
}
inline ::valhalla::LatLng* BoundingBox::_internal_mutable_max_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.max_ll_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::LatLng>(GetArena());
    _impl_.max_ll_ = reinterpret_cast<::valhalla::LatLng*>(p);
  }
  return _impl_.max_ll_;
}
inline ::valhalla::LatLng* BoundingBox::mutable_max_ll() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::LatLng* _msg = _internal_mutable_max_ll();
  // @@protoc_insertion_point(field_mutable:valhalla.BoundingBox.max_ll)
  return _msg;
}
inline void BoundingBox::set_allocated_max_ll(::valhalla::LatLng* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::valhalla::LatLng*>(_impl_.max_ll_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::valhalla::LatLng*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.max_ll_ = reinterpret_cast<::valhalla::LatLng*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.BoundingBox.max_ll)
}

// -------------------------------------------------------------------

// SearchFilter

// .valhalla.RoadClass min_road_class = 1;
inline bool SearchFilter::has_min_road_class() const {
  return has_min_road_class_case() == kMinRoadClass;
}
inline void SearchFilter::set_has_min_road_class() {
  _impl_._oneof_case_[0] = kMinRoadClass;
}
inline void SearchFilter::clear_min_road_class() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_min_road_class_case() == kMinRoadClass) {
    _impl_.has_min_road_class_.min_road_class_ = 0;
    clear_has_has_min_road_class();
  }
}
inline ::valhalla::RoadClass SearchFilter::min_road_class() const {
  // @@protoc_insertion_point(field_get:valhalla.SearchFilter.min_road_class)
  return _internal_min_road_class();
}
inline void SearchFilter::set_min_road_class(::valhalla::RoadClass value) {
  _internal_set_min_road_class(value);
  // @@protoc_insertion_point(field_set:valhalla.SearchFilter.min_road_class)
}
inline ::valhalla::RoadClass SearchFilter::_internal_min_road_class() const {
  if (has_min_road_class_case() == kMinRoadClass) {
    return static_cast<::valhalla::RoadClass>(_impl_.has_min_road_class_.min_road_class_);
  }
  return static_cast<::valhalla::RoadClass>(0);
}
inline void SearchFilter::_internal_set_min_road_class(::valhalla::RoadClass value) {
  if (has_min_road_class_case() != kMinRoadClass) {
    clear_has_min_road_class();
    set_has_min_road_class();
  }
  _impl_.has_min_road_class_.min_road_class_ = value;
}

// .valhalla.RoadClass max_road_class = 2;
inline bool SearchFilter::has_max_road_class() const {
  return has_max_road_class_case() == kMaxRoadClass;
}
inline void SearchFilter::set_has_max_road_class() {
  _impl_._oneof_case_[1] = kMaxRoadClass;
}
inline void SearchFilter::clear_max_road_class() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_max_road_class_case() == kMaxRoadClass) {
    _impl_.has_max_road_class_.max_road_class_ = 0;
    clear_has_has_max_road_class();
  }
}
inline ::valhalla::RoadClass SearchFilter::max_road_class() const {
  // @@protoc_insertion_point(field_get:valhalla.SearchFilter.max_road_class)
  return _internal_max_road_class();
}
inline void SearchFilter::set_max_road_class(::valhalla::RoadClass value) {
  _internal_set_max_road_class(value);
  // @@protoc_insertion_point(field_set:valhalla.SearchFilter.max_road_class)
}
inline ::valhalla::RoadClass SearchFilter::_internal_max_road_class() const {
  if (has_max_road_class_case() == kMaxRoadClass) {
    return static_cast<::valhalla::RoadClass>(_impl_.has_max_road_class_.max_road_class_);
  }
  return static_cast<::valhalla::RoadClass>(0);
}
inline void SearchFilter::_internal_set_max_road_class(::valhalla::RoadClass value) {
  if (has_max_road_class_case() != kMaxRoadClass) {
    clear_has_max_road_class();
    set_has_max_road_class();
  }
  _impl_.has_max_road_class_.max_road_class_ = value;
}

// bool exclude_tunnel = 3;
inline void SearchFilter::clear_exclude_tunnel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.exclude_tunnel_ = false;
}
inline bool SearchFilter::exclude_tunnel() const {
  // @@protoc_insertion_point(field_get:valhalla.SearchFilter.exclude_tunnel)
  return _internal_exclude_tunnel();
}
inline void SearchFilter::set_exclude_tunnel(bool value) {
  _internal_set_exclude_tunnel(value);
  // @@protoc_insertion_point(field_set:valhalla.SearchFilter.exclude_tunnel)
}
inline bool SearchFilter::_internal_exclude_tunnel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.exclude_tunnel_;
}
inline void SearchFilter::_internal_set_exclude_tunnel(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.exclude_tunnel_ = value;
}

// bool exclude_bridge = 4;
inline void SearchFilter::clear_exclude_bridge() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.exclude_bridge_ = false;
}
inline bool SearchFilter::exclude_bridge() const {
  // @@protoc_insertion_point(field_get:valhalla.SearchFilter.exclude_bridge)
  return _internal_exclude_bridge();
}
inline void SearchFilter::set_exclude_bridge(bool value) {
  _internal_set_exclude_bridge(value);
  // @@protoc_insertion_point(field_set:valhalla.SearchFilter.exclude_bridge)
}
inline bool SearchFilter::_internal_exclude_bridge() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.exclude_bridge_;
}
inline void SearchFilter::_internal_set_exclude_bridge(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.exclude_bridge_ = value;
}

// bool exclude_ramp = 5;
inline void SearchFilter::clear_exclude_ramp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.exclude_ramp_ = false;
}
inline bool SearchFilter::exclude_ramp() const {
  // @@protoc_insertion_point(field_get:valhalla.SearchFilter.exclude_ramp)
  return _internal_exclude_ramp();
}
inline void SearchFilter::set_exclude_ramp(bool value) {
  _internal_set_exclude_ramp(value);
  // @@protoc_insertion_point(field_set:valhalla.SearchFilter.exclude_ramp)
}
inline bool SearchFilter::_internal_exclude_ramp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.exclude_ramp_;
}
inline void SearchFilter::_internal_set_exclude_ramp(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.exclude_ramp_ = value;
}

// bool exclude_closures = 6;
inline bool SearchFilter::has_exclude_closures() const {
  return has_exclude_closures_case() == kExcludeClosures;
}
inline void SearchFilter::set_has_exclude_closures() {
  _impl_._oneof_case_[2] = kExcludeClosures;
}
inline void SearchFilter::clear_exclude_closures() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_exclude_closures_case() == kExcludeClosures) {
    _impl_.has_exclude_closures_.exclude_closures_ = false;
    clear_has_has_exclude_closures();
  }
}
inline bool SearchFilter::exclude_closures() const {
  // @@protoc_insertion_point(field_get:valhalla.SearchFilter.exclude_closures)
  return _internal_exclude_closures();
}
inline void SearchFilter::set_exclude_closures(bool value) {
  _internal_set_exclude_closures(value);
  // @@protoc_insertion_point(field_set:valhalla.SearchFilter.exclude_closures)
}
inline bool SearchFilter::_internal_exclude_closures() const {
  if (has_exclude_closures_case() == kExcludeClosures) {
    return _impl_.has_exclude_closures_.exclude_closures_;
  }
  return false;
}
inline void SearchFilter::_internal_set_exclude_closures(bool value) {
  if (has_exclude_closures_case() != kExcludeClosures) {
    clear_has_exclude_closures();
    set_has_exclude_closures();
  }
  _impl_.has_exclude_closures_.exclude_closures_ = value;
}

inline bool SearchFilter::has_has_min_road_class() const {
  return has_min_road_class_case() != HAS_MIN_ROAD_CLASS_NOT_SET;
}
inline void SearchFilter::clear_has_has_min_road_class() {
  _impl_._oneof_case_[0] = HAS_MIN_ROAD_CLASS_NOT_SET;
}
inline bool SearchFilter::has_has_max_road_class() const {
  return has_max_road_class_case() != HAS_MAX_ROAD_CLASS_NOT_SET;
}
inline void SearchFilter::clear_has_has_max_road_class() {
  _impl_._oneof_case_[1] = HAS_MAX_ROAD_CLASS_NOT_SET;
}
inline bool SearchFilter::has_has_exclude_closures() const {
  return has_exclude_closures_case() != HAS_EXCLUDE_CLOSURES_NOT_SET;
}
inline void SearchFilter::clear_has_has_exclude_closures() {
  _impl_._oneof_case_[2] = HAS_EXCLUDE_CLOSURES_NOT_SET;
}
inline SearchFilter::HasMinRoadClassCase SearchFilter::has_min_road_class_case() const {
  return SearchFilter::HasMinRoadClassCase(_impl_._oneof_case_[0]);
}
inline SearchFilter::HasMaxRoadClassCase SearchFilter::has_max_road_class_case() const {
  return SearchFilter::HasMaxRoadClassCase(_impl_._oneof_case_[1]);
}
inline SearchFilter::HasExcludeClosuresCase SearchFilter::has_exclude_closures_case() const {
  return SearchFilter::HasExcludeClosuresCase(_impl_._oneof_case_[2]);
}
// -------------------------------------------------------------------

// PathEdge

// uint64 graph_id = 1;
inline void PathEdge::clear_graph_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.graph_id_ = ::uint64_t{0u};
}
inline ::uint64_t PathEdge::graph_id() const {
  // @@protoc_insertion_point(field_get:valhalla.PathEdge.graph_id)
  return _internal_graph_id();
}
inline void PathEdge::set_graph_id(::uint64_t value) {
  _internal_set_graph_id(value);
  // @@protoc_insertion_point(field_set:valhalla.PathEdge.graph_id)
}
inline ::uint64_t PathEdge::_internal_graph_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.graph_id_;
}
inline void PathEdge::_internal_set_graph_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.graph_id_ = value;
}

// double percent_along = 2;
inline void PathEdge::clear_percent_along() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.percent_along_ = 0;
}
inline double PathEdge::percent_along() const {
  // @@protoc_insertion_point(field_get:valhalla.PathEdge.percent_along)
  return _internal_percent_along();
}
inline void PathEdge::set_percent_along(double value) {
  _internal_set_percent_along(value);
  // @@protoc_insertion_point(field_set:valhalla.PathEdge.percent_along)
}
inline double PathEdge::_internal_percent_along() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.percent_along_;
}
inline void PathEdge::_internal_set_percent_along(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.percent_along_ = value;
}

// .valhalla.LatLng ll = 3;
inline bool PathEdge::has_ll() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ll_ != nullptr);
  return value;
}
inline void PathEdge::clear_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.ll_ != nullptr) _impl_.ll_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::valhalla::LatLng& PathEdge::_internal_ll() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::LatLng* p = _impl_.ll_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::LatLng&>(::valhalla::_LatLng_default_instance_);
}
inline const ::valhalla::LatLng& PathEdge::ll() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.PathEdge.ll)
  return _internal_ll();
}
inline void PathEdge::unsafe_arena_set_allocated_ll(::valhalla::LatLng* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ll_);
  }
  _impl_.ll_ = reinterpret_cast<::valhalla::LatLng*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.PathEdge.ll)
}
inline ::valhalla::LatLng* PathEdge::release_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::LatLng* released = _impl_.ll_;
  _impl_.ll_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::LatLng* PathEdge::unsafe_arena_release_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.PathEdge.ll)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::LatLng* temp = _impl_.ll_;
  _impl_.ll_ = nullptr;
  return temp;
}
inline ::valhalla::LatLng* PathEdge::_internal_mutable_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.ll_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::LatLng>(GetArena());
    _impl_.ll_ = reinterpret_cast<::valhalla::LatLng*>(p);
  }
  return _impl_.ll_;
}
inline ::valhalla::LatLng* PathEdge::mutable_ll() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::LatLng* _msg = _internal_mutable_ll();
  // @@protoc_insertion_point(field_mutable:valhalla.PathEdge.ll)
  return _msg;
}
inline void PathEdge::set_allocated_ll(::valhalla::LatLng* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::valhalla::LatLng*>(_impl_.ll_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::valhalla::LatLng*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.ll_ = reinterpret_cast<::valhalla::LatLng*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.PathEdge.ll)
}

// .valhalla.Location.SideOfStreet side_of_street = 4;
inline void PathEdge::clear_side_of_street() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.side_of_street_ = 0;
}
inline ::valhalla::Location_SideOfStreet PathEdge::side_of_street() const {
  // @@protoc_insertion_point(field_get:valhalla.PathEdge.side_of_street)
  return _internal_side_of_street();
}
inline void PathEdge::set_side_of_street(::valhalla::Location_SideOfStreet value) {
  _internal_set_side_of_street(value);
  // @@protoc_insertion_point(field_set:valhalla.PathEdge.side_of_street)
}
inline ::valhalla::Location_SideOfStreet PathEdge::_internal_side_of_street() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::Location_SideOfStreet>(_impl_.side_of_street_);
}
inline void PathEdge::_internal_set_side_of_street(::valhalla::Location_SideOfStreet value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.side_of_street_ = value;
}

// double distance = 5;
inline void PathEdge::clear_distance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.distance_ = 0;
}
inline double PathEdge::distance() const {
  // @@protoc_insertion_point(field_get:valhalla.PathEdge.distance)
  return _internal_distance();
}
inline void PathEdge::set_distance(double value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:valhalla.PathEdge.distance)
}
inline double PathEdge::_internal_distance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.distance_;
}
inline void PathEdge::_internal_set_distance(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.distance_ = value;
}

// bool begin_node = 7;
inline void PathEdge::clear_begin_node() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.begin_node_ = false;
}
inline bool PathEdge::begin_node() const {
  // @@protoc_insertion_point(field_get:valhalla.PathEdge.begin_node)
  return _internal_begin_node();
}
inline void PathEdge::set_begin_node(bool value) {
  _internal_set_begin_node(value);
  // @@protoc_insertion_point(field_set:valhalla.PathEdge.begin_node)
}
inline bool PathEdge::_internal_begin_node() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.begin_node_;
}
inline void PathEdge::_internal_set_begin_node(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.begin_node_ = value;
}

// bool end_node = 8;
inline void PathEdge::clear_end_node() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_node_ = false;
}
inline bool PathEdge::end_node() const {
  // @@protoc_insertion_point(field_get:valhalla.PathEdge.end_node)
  return _internal_end_node();
}
inline void PathEdge::set_end_node(bool value) {
  _internal_set_end_node(value);
  // @@protoc_insertion_point(field_set:valhalla.PathEdge.end_node)
}
inline bool PathEdge::_internal_end_node() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_node_;
}
inline void PathEdge::_internal_set_end_node(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.end_node_ = value;
}

// repeated string names = 10;
inline int PathEdge::_internal_names_size() const {
  return _internal_names().size();
}
inline int PathEdge::names_size() const {
  return _internal_names_size();
}
inline void PathEdge::clear_names() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.names_.Clear();
}
inline std::string* PathEdge::add_names()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_names()->Add();
  // @@protoc_insertion_point(field_add_mutable:valhalla.PathEdge.names)
  return _s;
}
inline const std::string& PathEdge::names(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.PathEdge.names)
  return _internal_names().Get(index);
}
inline std::string* PathEdge::mutable_names(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.PathEdge.names)
  return _internal_mutable_names()->Mutable(index);
}
inline void PathEdge::set_names(int index, const std::string& value) {
  _internal_mutable_names()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.PathEdge.names)
}
inline void PathEdge::set_names(int index, std::string&& value) {
  _internal_mutable_names()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:valhalla.PathEdge.names)
}
inline void PathEdge::set_names(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_names()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.PathEdge.names)
}
inline void PathEdge::set_names(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_names()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.PathEdge.names)
}
inline void PathEdge::set_names(int index, absl::string_view value) {
  _internal_mutable_names()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:valhalla.PathEdge.names)
}
inline void PathEdge::add_names(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_names()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:valhalla.PathEdge.names)
}
inline void PathEdge::add_names(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_names()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:valhalla.PathEdge.names)
}
inline void PathEdge::add_names(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_names()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:valhalla.PathEdge.names)
}
inline void PathEdge::add_names(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_names()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:valhalla.PathEdge.names)
}
inline void PathEdge::add_names(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_names()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:valhalla.PathEdge.names)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
PathEdge::names() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.PathEdge.names)
  return _internal_names();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
PathEdge::mutable_names() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.PathEdge.names)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_names();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
PathEdge::_internal_names() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.names_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
PathEdge::_internal_mutable_names() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.names_;
}

// int32 outbound_reach = 11;
inline void PathEdge::clear_outbound_reach() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.outbound_reach_ = 0;
}
inline ::int32_t PathEdge::outbound_reach() const {
  // @@protoc_insertion_point(field_get:valhalla.PathEdge.outbound_reach)
  return _internal_outbound_reach();
}
inline void PathEdge::set_outbound_reach(::int32_t value) {
  _internal_set_outbound_reach(value);
  // @@protoc_insertion_point(field_set:valhalla.PathEdge.outbound_reach)
}
inline ::int32_t PathEdge::_internal_outbound_reach() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.outbound_reach_;
}
inline void PathEdge::_internal_set_outbound_reach(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.outbound_reach_ = value;
}

// int32 inbound_reach = 12;
inline void PathEdge::clear_inbound_reach() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.inbound_reach_ = 0;
}
inline ::int32_t PathEdge::inbound_reach() const {
  // @@protoc_insertion_point(field_get:valhalla.PathEdge.inbound_reach)
  return _internal_inbound_reach();
}
inline void PathEdge::set_inbound_reach(::int32_t value) {
  _internal_set_inbound_reach(value);
  // @@protoc_insertion_point(field_set:valhalla.PathEdge.inbound_reach)
}
inline ::int32_t PathEdge::_internal_inbound_reach() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.inbound_reach_;
}
inline void PathEdge::_internal_set_inbound_reach(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.inbound_reach_ = value;
}

// float heading = 13;
inline void PathEdge::clear_heading() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heading_ = 0;
}
inline float PathEdge::heading() const {
  // @@protoc_insertion_point(field_get:valhalla.PathEdge.heading)
  return _internal_heading();
}
inline void PathEdge::set_heading(float value) {
  _internal_set_heading(value);
  // @@protoc_insertion_point(field_set:valhalla.PathEdge.heading)
}
inline float PathEdge::_internal_heading() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.heading_;
}
inline void PathEdge::_internal_set_heading(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.heading_ = value;
}

// -------------------------------------------------------------------

// Correlation

// repeated .valhalla.PathEdge edges = 1;
inline int Correlation::_internal_edges_size() const {
  return _internal_edges().size();
}
inline int Correlation::edges_size() const {
  return _internal_edges_size();
}
inline void Correlation::clear_edges() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.edges_.Clear();
}
inline ::valhalla::PathEdge* Correlation::mutable_edges(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.Correlation.edges)
  return _internal_mutable_edges()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::PathEdge>* Correlation::mutable_edges()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Correlation.edges)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_edges();
}
inline const ::valhalla::PathEdge& Correlation::edges(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Correlation.edges)
  return _internal_edges().Get(index);
}
inline ::valhalla::PathEdge* Correlation::add_edges() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::PathEdge* _add = _internal_mutable_edges()->Add();
  // @@protoc_insertion_point(field_add:valhalla.Correlation.edges)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::PathEdge>& Correlation::edges() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.Correlation.edges)
  return _internal_edges();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::PathEdge>&
Correlation::_internal_edges() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.edges_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::PathEdge>*
Correlation::_internal_mutable_edges() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.edges_;
}

// repeated .valhalla.PathEdge filtered_edges = 2;
inline int Correlation::_internal_filtered_edges_size() const {
  return _internal_filtered_edges().size();
}
inline int Correlation::filtered_edges_size() const {
  return _internal_filtered_edges_size();
}
inline void Correlation::clear_filtered_edges() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filtered_edges_.Clear();
}
inline ::valhalla::PathEdge* Correlation::mutable_filtered_edges(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.Correlation.filtered_edges)
  return _internal_mutable_filtered_edges()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::PathEdge>* Correlation::mutable_filtered_edges()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Correlation.filtered_edges)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_filtered_edges();
}
inline const ::valhalla::PathEdge& Correlation::filtered_edges(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Correlation.filtered_edges)
  return _internal_filtered_edges().Get(index);
}
inline ::valhalla::PathEdge* Correlation::add_filtered_edges() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::PathEdge* _add = _internal_mutable_filtered_edges()->Add();
  // @@protoc_insertion_point(field_add:valhalla.Correlation.filtered_edges)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::PathEdge>& Correlation::filtered_edges() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.Correlation.filtered_edges)
  return _internal_filtered_edges();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::PathEdge>&
Correlation::_internal_filtered_edges() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.filtered_edges_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::PathEdge>*
Correlation::_internal_mutable_filtered_edges() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.filtered_edges_;
}

// uint32 original_index = 3;
inline void Correlation::clear_original_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.original_index_ = 0u;
}
inline ::uint32_t Correlation::original_index() const {
  // @@protoc_insertion_point(field_get:valhalla.Correlation.original_index)
  return _internal_original_index();
}
inline void Correlation::set_original_index(::uint32_t value) {
  _internal_set_original_index(value);
  // @@protoc_insertion_point(field_set:valhalla.Correlation.original_index)
}
inline ::uint32_t Correlation::_internal_original_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.original_index_;
}
inline void Correlation::_internal_set_original_index(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.original_index_ = value;
}

// .valhalla.LatLng projected_ll = 4;
inline bool Correlation::has_projected_ll() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.projected_ll_ != nullptr);
  return value;
}
inline void Correlation::clear_projected_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.projected_ll_ != nullptr) _impl_.projected_ll_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::valhalla::LatLng& Correlation::_internal_projected_ll() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::LatLng* p = _impl_.projected_ll_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::LatLng&>(::valhalla::_LatLng_default_instance_);
}
inline const ::valhalla::LatLng& Correlation::projected_ll() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Correlation.projected_ll)
  return _internal_projected_ll();
}
inline void Correlation::unsafe_arena_set_allocated_projected_ll(::valhalla::LatLng* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.projected_ll_);
  }
  _impl_.projected_ll_ = reinterpret_cast<::valhalla::LatLng*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.Correlation.projected_ll)
}
inline ::valhalla::LatLng* Correlation::release_projected_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::LatLng* released = _impl_.projected_ll_;
  _impl_.projected_ll_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::LatLng* Correlation::unsafe_arena_release_projected_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.Correlation.projected_ll)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::LatLng* temp = _impl_.projected_ll_;
  _impl_.projected_ll_ = nullptr;
  return temp;
}
inline ::valhalla::LatLng* Correlation::_internal_mutable_projected_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.projected_ll_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::LatLng>(GetArena());
    _impl_.projected_ll_ = reinterpret_cast<::valhalla::LatLng*>(p);
  }
  return _impl_.projected_ll_;
}
inline ::valhalla::LatLng* Correlation::mutable_projected_ll() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::LatLng* _msg = _internal_mutable_projected_ll();
  // @@protoc_insertion_point(field_mutable:valhalla.Correlation.projected_ll)
  return _msg;
}
inline void Correlation::set_allocated_projected_ll(::valhalla::LatLng* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::valhalla::LatLng*>(_impl_.projected_ll_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::valhalla::LatLng*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.projected_ll_ = reinterpret_cast<::valhalla::LatLng*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.Correlation.projected_ll)
}

// uint32 leg_shape_index = 5;
inline void Correlation::clear_leg_shape_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.leg_shape_index_ = 0u;
}
inline ::uint32_t Correlation::leg_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.Correlation.leg_shape_index)
  return _internal_leg_shape_index();
}
inline void Correlation::set_leg_shape_index(::uint32_t value) {
  _internal_set_leg_shape_index(value);
  // @@protoc_insertion_point(field_set:valhalla.Correlation.leg_shape_index)
}
inline ::uint32_t Correlation::_internal_leg_shape_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.leg_shape_index_;
}
inline void Correlation::_internal_set_leg_shape_index(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.leg_shape_index_ = value;
}

// double distance_from_leg_origin = 6;
inline void Correlation::clear_distance_from_leg_origin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.distance_from_leg_origin_ = 0;
}
inline double Correlation::distance_from_leg_origin() const {
  // @@protoc_insertion_point(field_get:valhalla.Correlation.distance_from_leg_origin)
  return _internal_distance_from_leg_origin();
}
inline void Correlation::set_distance_from_leg_origin(double value) {
  _internal_set_distance_from_leg_origin(value);
  // @@protoc_insertion_point(field_set:valhalla.Correlation.distance_from_leg_origin)
}
inline double Correlation::_internal_distance_from_leg_origin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.distance_from_leg_origin_;
}
inline void Correlation::_internal_set_distance_from_leg_origin(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.distance_from_leg_origin_ = value;
}

// uint32 route_index = 7;
inline void Correlation::clear_route_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.route_index_ = 0u;
}
inline ::uint32_t Correlation::route_index() const {
  // @@protoc_insertion_point(field_get:valhalla.Correlation.route_index)
  return _internal_route_index();
}
inline void Correlation::set_route_index(::uint32_t value) {
  _internal_set_route_index(value);
  // @@protoc_insertion_point(field_set:valhalla.Correlation.route_index)
}
inline ::uint32_t Correlation::_internal_route_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.route_index_;
}
inline void Correlation::_internal_set_route_index(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.route_index_ = value;
}

// uint32 waypoint_index = 8;
inline void Correlation::clear_waypoint_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.waypoint_index_ = 0u;
}
inline ::uint32_t Correlation::waypoint_index() const {
  // @@protoc_insertion_point(field_get:valhalla.Correlation.waypoint_index)
  return _internal_waypoint_index();
}
inline void Correlation::set_waypoint_index(::uint32_t value) {
  _internal_set_waypoint_index(value);
  // @@protoc_insertion_point(field_set:valhalla.Correlation.waypoint_index)
}
inline ::uint32_t Correlation::_internal_waypoint_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.waypoint_index_;
}
inline void Correlation::_internal_set_waypoint_index(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.waypoint_index_ = value;
}

// -------------------------------------------------------------------

// Location

// .valhalla.LatLng ll = 1;
inline bool Location::has_ll() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ll_ != nullptr);
  return value;
}
inline void Location::clear_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.ll_ != nullptr) _impl_.ll_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::valhalla::LatLng& Location::_internal_ll() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::LatLng* p = _impl_.ll_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::LatLng&>(::valhalla::_LatLng_default_instance_);
}
inline const ::valhalla::LatLng& Location::ll() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Location.ll)
  return _internal_ll();
}
inline void Location::unsafe_arena_set_allocated_ll(::valhalla::LatLng* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ll_);
  }
  _impl_.ll_ = reinterpret_cast<::valhalla::LatLng*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.Location.ll)
}
inline ::valhalla::LatLng* Location::release_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::LatLng* released = _impl_.ll_;
  _impl_.ll_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::LatLng* Location::unsafe_arena_release_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.Location.ll)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::LatLng* temp = _impl_.ll_;
  _impl_.ll_ = nullptr;
  return temp;
}
inline ::valhalla::LatLng* Location::_internal_mutable_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.ll_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::LatLng>(GetArena());
    _impl_.ll_ = reinterpret_cast<::valhalla::LatLng*>(p);
  }
  return _impl_.ll_;
}
inline ::valhalla::LatLng* Location::mutable_ll() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::LatLng* _msg = _internal_mutable_ll();
  // @@protoc_insertion_point(field_mutable:valhalla.Location.ll)
  return _msg;
}
inline void Location::set_allocated_ll(::valhalla::LatLng* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::valhalla::LatLng*>(_impl_.ll_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::valhalla::LatLng*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.ll_ = reinterpret_cast<::valhalla::LatLng*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.Location.ll)
}

// .valhalla.Location.Type type = 2;
inline void Location::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::valhalla::Location_Type Location::type() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.type)
  return _internal_type();
}
inline void Location::set_type(::valhalla::Location_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.type)
}
inline ::valhalla::Location_Type Location::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::Location_Type>(_impl_.type_);
}
inline void Location::_internal_set_type(::valhalla::Location_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// uint32 heading = 3;
inline bool Location::has_heading() const {
  return has_heading_case() == kHeading;
}
inline void Location::set_has_heading() {
  _impl_._oneof_case_[0] = kHeading;
}
inline void Location::clear_heading() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_heading_case() == kHeading) {
    _impl_.has_heading_.heading_ = 0u;
    clear_has_has_heading();
  }
}
inline ::uint32_t Location::heading() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.heading)
  return _internal_heading();
}
inline void Location::set_heading(::uint32_t value) {
  _internal_set_heading(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.heading)
}
inline ::uint32_t Location::_internal_heading() const {
  if (has_heading_case() == kHeading) {
    return _impl_.has_heading_.heading_;
  }
  return 0u;
}
inline void Location::_internal_set_heading(::uint32_t value) {
  if (has_heading_case() != kHeading) {
    clear_has_heading();
    set_has_heading();
  }
  _impl_.has_heading_.heading_ = value;
}

// string name = 4;
inline void Location::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Location::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Location.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Location::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.Location.name)
}
inline std::string* Location::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:valhalla.Location.name)
  return _s;
}
inline const std::string& Location::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Location::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Location::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Location::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.Location.name)
  return _impl_.name_.Release();
}
inline void Location::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.Location.name)
}

// string street = 5;
inline void Location::clear_street() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.street_.ClearToEmpty();
}
inline const std::string& Location::street() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Location.street)
  return _internal_street();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Location::set_street(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.street_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.Location.street)
}
inline std::string* Location::mutable_street() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_street();
  // @@protoc_insertion_point(field_mutable:valhalla.Location.street)
  return _s;
}
inline const std::string& Location::_internal_street() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.street_.Get();
}
inline void Location::_internal_set_street(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.street_.Set(value, GetArena());
}
inline std::string* Location::_internal_mutable_street() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.street_.Mutable( GetArena());
}
inline std::string* Location::release_street() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.Location.street)
  return _impl_.street_.Release();
}
inline void Location::set_allocated_street(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.street_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.street_.IsDefault()) {
          _impl_.street_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.Location.street)
}

// string date_time = 12;
inline void Location::clear_date_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.date_time_.ClearToEmpty();
}
inline const std::string& Location::date_time() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Location.date_time)
  return _internal_date_time();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Location::set_date_time(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.date_time_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.Location.date_time)
}
inline std::string* Location::mutable_date_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_date_time();
  // @@protoc_insertion_point(field_mutable:valhalla.Location.date_time)
  return _s;
}
inline const std::string& Location::_internal_date_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.date_time_.Get();
}
inline void Location::_internal_set_date_time(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.date_time_.Set(value, GetArena());
}
inline std::string* Location::_internal_mutable_date_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.date_time_.Mutable( GetArena());
}
inline std::string* Location::release_date_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.Location.date_time)
  return _impl_.date_time_.Release();
}
inline void Location::set_allocated_date_time(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.date_time_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.date_time_.IsDefault()) {
          _impl_.date_time_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.Location.date_time)
}

// .valhalla.Location.SideOfStreet side_of_street = 13;
inline void Location::clear_side_of_street() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.side_of_street_ = 0;
}
inline ::valhalla::Location_SideOfStreet Location::side_of_street() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.side_of_street)
  return _internal_side_of_street();
}
inline void Location::set_side_of_street(::valhalla::Location_SideOfStreet value) {
  _internal_set_side_of_street(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.side_of_street)
}
inline ::valhalla::Location_SideOfStreet Location::_internal_side_of_street() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::Location_SideOfStreet>(_impl_.side_of_street_);
}
inline void Location::_internal_set_side_of_street(::valhalla::Location_SideOfStreet value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.side_of_street_ = value;
}

// uint32 heading_tolerance = 14;
inline bool Location::has_heading_tolerance() const {
  return has_heading_tolerance_case() == kHeadingTolerance;
}
inline void Location::set_has_heading_tolerance() {
  _impl_._oneof_case_[1] = kHeadingTolerance;
}
inline void Location::clear_heading_tolerance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_heading_tolerance_case() == kHeadingTolerance) {
    _impl_.has_heading_tolerance_.heading_tolerance_ = 0u;
    clear_has_has_heading_tolerance();
  }
}
inline ::uint32_t Location::heading_tolerance() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.heading_tolerance)
  return _internal_heading_tolerance();
}
inline void Location::set_heading_tolerance(::uint32_t value) {
  _internal_set_heading_tolerance(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.heading_tolerance)
}
inline ::uint32_t Location::_internal_heading_tolerance() const {
  if (has_heading_tolerance_case() == kHeadingTolerance) {
    return _impl_.has_heading_tolerance_.heading_tolerance_;
  }
  return 0u;
}
inline void Location::_internal_set_heading_tolerance(::uint32_t value) {
  if (has_heading_tolerance_case() != kHeadingTolerance) {
    clear_has_heading_tolerance();
    set_has_heading_tolerance();
  }
  _impl_.has_heading_tolerance_.heading_tolerance_ = value;
}

// uint32 node_snap_tolerance = 15;
inline bool Location::has_node_snap_tolerance() const {
  return has_node_snap_tolerance_case() == kNodeSnapTolerance;
}
inline void Location::set_has_node_snap_tolerance() {
  _impl_._oneof_case_[2] = kNodeSnapTolerance;
}
inline void Location::clear_node_snap_tolerance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_node_snap_tolerance_case() == kNodeSnapTolerance) {
    _impl_.has_node_snap_tolerance_.node_snap_tolerance_ = 0u;
    clear_has_has_node_snap_tolerance();
  }
}
inline ::uint32_t Location::node_snap_tolerance() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.node_snap_tolerance)
  return _internal_node_snap_tolerance();
}
inline void Location::set_node_snap_tolerance(::uint32_t value) {
  _internal_set_node_snap_tolerance(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.node_snap_tolerance)
}
inline ::uint32_t Location::_internal_node_snap_tolerance() const {
  if (has_node_snap_tolerance_case() == kNodeSnapTolerance) {
    return _impl_.has_node_snap_tolerance_.node_snap_tolerance_;
  }
  return 0u;
}
inline void Location::_internal_set_node_snap_tolerance(::uint32_t value) {
  if (has_node_snap_tolerance_case() != kNodeSnapTolerance) {
    clear_has_node_snap_tolerance();
    set_has_node_snap_tolerance();
  }
  _impl_.has_node_snap_tolerance_.node_snap_tolerance_ = value;
}

// uint32 minimum_reachability = 17;
inline bool Location::has_minimum_reachability() const {
  return has_minimum_reachability_case() == kMinimumReachability;
}
inline void Location::set_has_minimum_reachability() {
  _impl_._oneof_case_[3] = kMinimumReachability;
}
inline void Location::clear_minimum_reachability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_minimum_reachability_case() == kMinimumReachability) {
    _impl_.has_minimum_reachability_.minimum_reachability_ = 0u;
    clear_has_has_minimum_reachability();
  }
}
inline ::uint32_t Location::minimum_reachability() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.minimum_reachability)
  return _internal_minimum_reachability();
}
inline void Location::set_minimum_reachability(::uint32_t value) {
  _internal_set_minimum_reachability(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.minimum_reachability)
}
inline ::uint32_t Location::_internal_minimum_reachability() const {
  if (has_minimum_reachability_case() == kMinimumReachability) {
    return _impl_.has_minimum_reachability_.minimum_reachability_;
  }
  return 0u;
}
inline void Location::_internal_set_minimum_reachability(::uint32_t value) {
  if (has_minimum_reachability_case() != kMinimumReachability) {
    clear_has_minimum_reachability();
    set_has_minimum_reachability();
  }
  _impl_.has_minimum_reachability_.minimum_reachability_ = value;
}

// uint32 radius = 18;
inline bool Location::has_radius() const {
  return has_radius_case() == kRadius;
}
inline void Location::set_has_radius() {
  _impl_._oneof_case_[4] = kRadius;
}
inline void Location::clear_radius() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_radius_case() == kRadius) {
    _impl_.has_radius_.radius_ = 0u;
    clear_has_has_radius();
  }
}
inline ::uint32_t Location::radius() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.radius)
  return _internal_radius();
}
inline void Location::set_radius(::uint32_t value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.radius)
}
inline ::uint32_t Location::_internal_radius() const {
  if (has_radius_case() == kRadius) {
    return _impl_.has_radius_.radius_;
  }
  return 0u;
}
inline void Location::_internal_set_radius(::uint32_t value) {
  if (has_radius_case() != kRadius) {
    clear_has_radius();
    set_has_radius();
  }
  _impl_.has_radius_.radius_ = value;
}

// uint32 accuracy = 19;
inline bool Location::has_accuracy() const {
  return has_accuracy_case() == kAccuracy;
}
inline void Location::set_has_accuracy() {
  _impl_._oneof_case_[5] = kAccuracy;
}
inline void Location::clear_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_accuracy_case() == kAccuracy) {
    _impl_.has_accuracy_.accuracy_ = 0u;
    clear_has_has_accuracy();
  }
}
inline ::uint32_t Location::accuracy() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.accuracy)
  return _internal_accuracy();
}
inline void Location::set_accuracy(::uint32_t value) {
  _internal_set_accuracy(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.accuracy)
}
inline ::uint32_t Location::_internal_accuracy() const {
  if (has_accuracy_case() == kAccuracy) {
    return _impl_.has_accuracy_.accuracy_;
  }
  return 0u;
}
inline void Location::_internal_set_accuracy(::uint32_t value) {
  if (has_accuracy_case() != kAccuracy) {
    clear_has_accuracy();
    set_has_accuracy();
  }
  _impl_.has_accuracy_.accuracy_ = value;
}

// double time = 20;
inline bool Location::has_time() const {
  return has_time_case() == kTime;
}
inline void Location::set_has_time() {
  _impl_._oneof_case_[6] = kTime;
}
inline void Location::clear_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_time_case() == kTime) {
    _impl_.has_time_.time_ = 0;
    clear_has_has_time();
  }
}
inline double Location::time() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.time)
  return _internal_time();
}
inline void Location::set_time(double value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.time)
}
inline double Location::_internal_time() const {
  if (has_time_case() == kTime) {
    return _impl_.has_time_.time_;
  }
  return 0;
}
inline void Location::_internal_set_time(double value) {
  if (has_time_case() != kTime) {
    clear_has_time();
    set_has_time();
  }
  _impl_.has_time_.time_ = value;
}

// bool skip_ranking_candidates = 21;
inline void Location::clear_skip_ranking_candidates() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skip_ranking_candidates_ = false;
}
inline bool Location::skip_ranking_candidates() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.skip_ranking_candidates)
  return _internal_skip_ranking_candidates();
}
inline void Location::set_skip_ranking_candidates(bool value) {
  _internal_set_skip_ranking_candidates(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.skip_ranking_candidates)
}
inline bool Location::_internal_skip_ranking_candidates() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.skip_ranking_candidates_;
}
inline void Location::_internal_set_skip_ranking_candidates(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.skip_ranking_candidates_ = value;
}

// .valhalla.Location.PreferredSide preferred_side = 22;
inline void Location::clear_preferred_side() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.preferred_side_ = 0;
}
inline ::valhalla::Location_PreferredSide Location::preferred_side() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.preferred_side)
  return _internal_preferred_side();
}
inline void Location::set_preferred_side(::valhalla::Location_PreferredSide value) {
  _internal_set_preferred_side(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.preferred_side)
}
inline ::valhalla::Location_PreferredSide Location::_internal_preferred_side() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::Location_PreferredSide>(_impl_.preferred_side_);
}
inline void Location::_internal_set_preferred_side(::valhalla::Location_PreferredSide value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.preferred_side_ = value;
}

// .valhalla.LatLng display_ll = 23;
inline bool Location::has_display_ll() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.display_ll_ != nullptr);
  return value;
}
inline void Location::clear_display_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.display_ll_ != nullptr) _impl_.display_ll_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::valhalla::LatLng& Location::_internal_display_ll() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::LatLng* p = _impl_.display_ll_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::LatLng&>(::valhalla::_LatLng_default_instance_);
}
inline const ::valhalla::LatLng& Location::display_ll() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Location.display_ll)
  return _internal_display_ll();
}
inline void Location::unsafe_arena_set_allocated_display_ll(::valhalla::LatLng* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.display_ll_);
  }
  _impl_.display_ll_ = reinterpret_cast<::valhalla::LatLng*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.Location.display_ll)
}
inline ::valhalla::LatLng* Location::release_display_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::valhalla::LatLng* released = _impl_.display_ll_;
  _impl_.display_ll_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::LatLng* Location::unsafe_arena_release_display_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.Location.display_ll)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::valhalla::LatLng* temp = _impl_.display_ll_;
  _impl_.display_ll_ = nullptr;
  return temp;
}
inline ::valhalla::LatLng* Location::_internal_mutable_display_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.display_ll_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::LatLng>(GetArena());
    _impl_.display_ll_ = reinterpret_cast<::valhalla::LatLng*>(p);
  }
  return _impl_.display_ll_;
}
inline ::valhalla::LatLng* Location::mutable_display_ll() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::LatLng* _msg = _internal_mutable_display_ll();
  // @@protoc_insertion_point(field_mutable:valhalla.Location.display_ll)
  return _msg;
}
inline void Location::set_allocated_display_ll(::valhalla::LatLng* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::valhalla::LatLng*>(_impl_.display_ll_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::valhalla::LatLng*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.display_ll_ = reinterpret_cast<::valhalla::LatLng*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.Location.display_ll)
}

// uint32 search_cutoff = 24;
inline bool Location::has_search_cutoff() const {
  return has_search_cutoff_case() == kSearchCutoff;
}
inline void Location::set_has_search_cutoff() {
  _impl_._oneof_case_[7] = kSearchCutoff;
}
inline void Location::clear_search_cutoff() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_search_cutoff_case() == kSearchCutoff) {
    _impl_.has_search_cutoff_.search_cutoff_ = 0u;
    clear_has_has_search_cutoff();
  }
}
inline ::uint32_t Location::search_cutoff() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.search_cutoff)
  return _internal_search_cutoff();
}
inline void Location::set_search_cutoff(::uint32_t value) {
  _internal_set_search_cutoff(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.search_cutoff)
}
inline ::uint32_t Location::_internal_search_cutoff() const {
  if (has_search_cutoff_case() == kSearchCutoff) {
    return _impl_.has_search_cutoff_.search_cutoff_;
  }
  return 0u;
}
inline void Location::_internal_set_search_cutoff(::uint32_t value) {
  if (has_search_cutoff_case() != kSearchCutoff) {
    clear_has_search_cutoff();
    set_has_search_cutoff();
  }
  _impl_.has_search_cutoff_.search_cutoff_ = value;
}

// uint32 street_side_tolerance = 25;
inline bool Location::has_street_side_tolerance() const {
  return has_street_side_tolerance_case() == kStreetSideTolerance;
}
inline void Location::set_has_street_side_tolerance() {
  _impl_._oneof_case_[8] = kStreetSideTolerance;
}
inline void Location::clear_street_side_tolerance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_street_side_tolerance_case() == kStreetSideTolerance) {
    _impl_.has_street_side_tolerance_.street_side_tolerance_ = 0u;
    clear_has_has_street_side_tolerance();
  }
}
inline ::uint32_t Location::street_side_tolerance() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.street_side_tolerance)
  return _internal_street_side_tolerance();
}
inline void Location::set_street_side_tolerance(::uint32_t value) {
  _internal_set_street_side_tolerance(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.street_side_tolerance)
}
inline ::uint32_t Location::_internal_street_side_tolerance() const {
  if (has_street_side_tolerance_case() == kStreetSideTolerance) {
    return _impl_.has_street_side_tolerance_.street_side_tolerance_;
  }
  return 0u;
}
inline void Location::_internal_set_street_side_tolerance(::uint32_t value) {
  if (has_street_side_tolerance_case() != kStreetSideTolerance) {
    clear_has_street_side_tolerance();
    set_has_street_side_tolerance();
  }
  _impl_.has_street_side_tolerance_.street_side_tolerance_ = value;
}

// .valhalla.SearchFilter search_filter = 26;
inline bool Location::has_search_filter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.search_filter_ != nullptr);
  return value;
}
inline void Location::clear_search_filter() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.search_filter_ != nullptr) _impl_.search_filter_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::valhalla::SearchFilter& Location::_internal_search_filter() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::SearchFilter* p = _impl_.search_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::SearchFilter&>(::valhalla::_SearchFilter_default_instance_);
}
inline const ::valhalla::SearchFilter& Location::search_filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Location.search_filter)
  return _internal_search_filter();
}
inline void Location::unsafe_arena_set_allocated_search_filter(::valhalla::SearchFilter* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.search_filter_);
  }
  _impl_.search_filter_ = reinterpret_cast<::valhalla::SearchFilter*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.Location.search_filter)
}
inline ::valhalla::SearchFilter* Location::release_search_filter() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::valhalla::SearchFilter* released = _impl_.search_filter_;
  _impl_.search_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::SearchFilter* Location::unsafe_arena_release_search_filter() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.Location.search_filter)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::valhalla::SearchFilter* temp = _impl_.search_filter_;
  _impl_.search_filter_ = nullptr;
  return temp;
}
inline ::valhalla::SearchFilter* Location::_internal_mutable_search_filter() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.search_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::SearchFilter>(GetArena());
    _impl_.search_filter_ = reinterpret_cast<::valhalla::SearchFilter*>(p);
  }
  return _impl_.search_filter_;
}
inline ::valhalla::SearchFilter* Location::mutable_search_filter() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::SearchFilter* _msg = _internal_mutable_search_filter();
  // @@protoc_insertion_point(field_mutable:valhalla.Location.search_filter)
  return _msg;
}
inline void Location::set_allocated_search_filter(::valhalla::SearchFilter* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::valhalla::SearchFilter*>(_impl_.search_filter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::valhalla::SearchFilter*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.search_filter_ = reinterpret_cast<::valhalla::SearchFilter*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.Location.search_filter)
}

// uint32 street_side_max_distance = 27;
inline bool Location::has_street_side_max_distance() const {
  return has_street_side_max_distance_case() == kStreetSideMaxDistance;
}
inline void Location::set_has_street_side_max_distance() {
  _impl_._oneof_case_[9] = kStreetSideMaxDistance;
}
inline void Location::clear_street_side_max_distance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_street_side_max_distance_case() == kStreetSideMaxDistance) {
    _impl_.has_street_side_max_distance_.street_side_max_distance_ = 0u;
    clear_has_has_street_side_max_distance();
  }
}
inline ::uint32_t Location::street_side_max_distance() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.street_side_max_distance)
  return _internal_street_side_max_distance();
}
inline void Location::set_street_side_max_distance(::uint32_t value) {
  _internal_set_street_side_max_distance(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.street_side_max_distance)
}
inline ::uint32_t Location::_internal_street_side_max_distance() const {
  if (has_street_side_max_distance_case() == kStreetSideMaxDistance) {
    return _impl_.has_street_side_max_distance_.street_side_max_distance_;
  }
  return 0u;
}
inline void Location::_internal_set_street_side_max_distance(::uint32_t value) {
  if (has_street_side_max_distance_case() != kStreetSideMaxDistance) {
    clear_has_street_side_max_distance();
    set_has_street_side_max_distance();
  }
  _impl_.has_street_side_max_distance_.street_side_max_distance_ = value;
}

// int32 preferred_layer = 28;
inline bool Location::has_preferred_layer() const {
  return has_preferred_layer_case() == kPreferredLayer;
}
inline void Location::set_has_preferred_layer() {
  _impl_._oneof_case_[10] = kPreferredLayer;
}
inline void Location::clear_preferred_layer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_preferred_layer_case() == kPreferredLayer) {
    _impl_.has_preferred_layer_.preferred_layer_ = 0;
    clear_has_has_preferred_layer();
  }
}
inline ::int32_t Location::preferred_layer() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.preferred_layer)
  return _internal_preferred_layer();
}
inline void Location::set_preferred_layer(::int32_t value) {
  _internal_set_preferred_layer(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.preferred_layer)
}
inline ::int32_t Location::_internal_preferred_layer() const {
  if (has_preferred_layer_case() == kPreferredLayer) {
    return _impl_.has_preferred_layer_.preferred_layer_;
  }
  return 0;
}
inline void Location::_internal_set_preferred_layer(::int32_t value) {
  if (has_preferred_layer_case() != kPreferredLayer) {
    clear_has_preferred_layer();
    set_has_preferred_layer();
  }
  _impl_.has_preferred_layer_.preferred_layer_ = value;
}

// float waiting_secs = 29;
inline void Location::clear_waiting_secs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.waiting_secs_ = 0;
}
inline float Location::waiting_secs() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.waiting_secs)
  return _internal_waiting_secs();
}
inline void Location::set_waiting_secs(float value) {
  _internal_set_waiting_secs(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.waiting_secs)
}
inline float Location::_internal_waiting_secs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.waiting_secs_;
}
inline void Location::_internal_set_waiting_secs(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.waiting_secs_ = value;
}

// .valhalla.RoadClass street_side_cutoff = 30;
inline bool Location::has_street_side_cutoff() const {
  return has_street_side_cutoff_case() == kStreetSideCutoff;
}
inline void Location::set_has_street_side_cutoff() {
  _impl_._oneof_case_[11] = kStreetSideCutoff;
}
inline void Location::clear_street_side_cutoff() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_street_side_cutoff_case() == kStreetSideCutoff) {
    _impl_.has_street_side_cutoff_.street_side_cutoff_ = 0;
    clear_has_has_street_side_cutoff();
  }
}
inline ::valhalla::RoadClass Location::street_side_cutoff() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.street_side_cutoff)
  return _internal_street_side_cutoff();
}
inline void Location::set_street_side_cutoff(::valhalla::RoadClass value) {
  _internal_set_street_side_cutoff(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.street_side_cutoff)
}
inline ::valhalla::RoadClass Location::_internal_street_side_cutoff() const {
  if (has_street_side_cutoff_case() == kStreetSideCutoff) {
    return static_cast<::valhalla::RoadClass>(_impl_.has_street_side_cutoff_.street_side_cutoff_);
  }
  return static_cast<::valhalla::RoadClass>(0);
}
inline void Location::_internal_set_street_side_cutoff(::valhalla::RoadClass value) {
  if (has_street_side_cutoff_case() != kStreetSideCutoff) {
    clear_has_street_side_cutoff();
    set_has_street_side_cutoff();
  }
  _impl_.has_street_side_cutoff_.street_side_cutoff_ = value;
}

// .valhalla.Correlation correlation = 90;
inline bool Location::has_correlation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.correlation_ != nullptr);
  return value;
}
inline void Location::clear_correlation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.correlation_ != nullptr) _impl_.correlation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::valhalla::Correlation& Location::_internal_correlation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::Correlation* p = _impl_.correlation_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::Correlation&>(::valhalla::_Correlation_default_instance_);
}
inline const ::valhalla::Correlation& Location::correlation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Location.correlation)
  return _internal_correlation();
}
inline void Location::unsafe_arena_set_allocated_correlation(::valhalla::Correlation* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.correlation_);
  }
  _impl_.correlation_ = reinterpret_cast<::valhalla::Correlation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.Location.correlation)
}
inline ::valhalla::Correlation* Location::release_correlation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::valhalla::Correlation* released = _impl_.correlation_;
  _impl_.correlation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::Correlation* Location::unsafe_arena_release_correlation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.Location.correlation)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::valhalla::Correlation* temp = _impl_.correlation_;
  _impl_.correlation_ = nullptr;
  return temp;
}
inline ::valhalla::Correlation* Location::_internal_mutable_correlation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.correlation_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::Correlation>(GetArena());
    _impl_.correlation_ = reinterpret_cast<::valhalla::Correlation*>(p);
  }
  return _impl_.correlation_;
}
inline ::valhalla::Correlation* Location::mutable_correlation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::Correlation* _msg = _internal_mutable_correlation();
  // @@protoc_insertion_point(field_mutable:valhalla.Location.correlation)
  return _msg;
}
inline void Location::set_allocated_correlation(::valhalla::Correlation* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::valhalla::Correlation*>(_impl_.correlation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::valhalla::Correlation*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.correlation_ = reinterpret_cast<::valhalla::Correlation*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.Location.correlation)
}

// string time_zone_offset = 91;
inline void Location::clear_time_zone_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.time_zone_offset_.ClearToEmpty();
}
inline const std::string& Location::time_zone_offset() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Location.time_zone_offset)
  return _internal_time_zone_offset();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Location::set_time_zone_offset(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.time_zone_offset_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.Location.time_zone_offset)
}
inline std::string* Location::mutable_time_zone_offset() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_time_zone_offset();
  // @@protoc_insertion_point(field_mutable:valhalla.Location.time_zone_offset)
  return _s;
}
inline const std::string& Location::_internal_time_zone_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.time_zone_offset_.Get();
}
inline void Location::_internal_set_time_zone_offset(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.time_zone_offset_.Set(value, GetArena());
}
inline std::string* Location::_internal_mutable_time_zone_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.time_zone_offset_.Mutable( GetArena());
}
inline std::string* Location::release_time_zone_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.Location.time_zone_offset)
  return _impl_.time_zone_offset_.Release();
}
inline void Location::set_allocated_time_zone_offset(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.time_zone_offset_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.time_zone_offset_.IsDefault()) {
          _impl_.time_zone_offset_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.Location.time_zone_offset)
}

// string time_zone_name = 92;
inline void Location::clear_time_zone_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.time_zone_name_.ClearToEmpty();
}
inline const std::string& Location::time_zone_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Location.time_zone_name)
  return _internal_time_zone_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Location::set_time_zone_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.time_zone_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.Location.time_zone_name)
}
inline std::string* Location::mutable_time_zone_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_time_zone_name();
  // @@protoc_insertion_point(field_mutable:valhalla.Location.time_zone_name)
  return _s;
}
inline const std::string& Location::_internal_time_zone_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.time_zone_name_.Get();
}
inline void Location::_internal_set_time_zone_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.time_zone_name_.Set(value, GetArena());
}
inline std::string* Location::_internal_mutable_time_zone_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.time_zone_name_.Mutable( GetArena());
}
inline std::string* Location::release_time_zone_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.Location.time_zone_name)
  return _impl_.time_zone_name_.Release();
}
inline void Location::set_allocated_time_zone_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.time_zone_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.time_zone_name_.IsDefault()) {
          _impl_.time_zone_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.Location.time_zone_name)
}

inline bool Location::has_has_heading() const {
  return has_heading_case() != HAS_HEADING_NOT_SET;
}
inline void Location::clear_has_has_heading() {
  _impl_._oneof_case_[0] = HAS_HEADING_NOT_SET;
}
inline bool Location::has_has_heading_tolerance() const {
  return has_heading_tolerance_case() != HAS_HEADING_TOLERANCE_NOT_SET;
}
inline void Location::clear_has_has_heading_tolerance() {
  _impl_._oneof_case_[1] = HAS_HEADING_TOLERANCE_NOT_SET;
}
inline bool Location::has_has_node_snap_tolerance() const {
  return has_node_snap_tolerance_case() != HAS_NODE_SNAP_TOLERANCE_NOT_SET;
}
inline void Location::clear_has_has_node_snap_tolerance() {
  _impl_._oneof_case_[2] = HAS_NODE_SNAP_TOLERANCE_NOT_SET;
}
inline bool Location::has_has_minimum_reachability() const {
  return has_minimum_reachability_case() != HAS_MINIMUM_REACHABILITY_NOT_SET;
}
inline void Location::clear_has_has_minimum_reachability() {
  _impl_._oneof_case_[3] = HAS_MINIMUM_REACHABILITY_NOT_SET;
}
inline bool Location::has_has_radius() const {
  return has_radius_case() != HAS_RADIUS_NOT_SET;
}
inline void Location::clear_has_has_radius() {
  _impl_._oneof_case_[4] = HAS_RADIUS_NOT_SET;
}
inline bool Location::has_has_accuracy() const {
  return has_accuracy_case() != HAS_ACCURACY_NOT_SET;
}
inline void Location::clear_has_has_accuracy() {
  _impl_._oneof_case_[5] = HAS_ACCURACY_NOT_SET;
}
inline bool Location::has_has_time() const {
  return has_time_case() != HAS_TIME_NOT_SET;
}
inline void Location::clear_has_has_time() {
  _impl_._oneof_case_[6] = HAS_TIME_NOT_SET;
}
inline bool Location::has_has_search_cutoff() const {
  return has_search_cutoff_case() != HAS_SEARCH_CUTOFF_NOT_SET;
}
inline void Location::clear_has_has_search_cutoff() {
  _impl_._oneof_case_[7] = HAS_SEARCH_CUTOFF_NOT_SET;
}
inline bool Location::has_has_street_side_tolerance() const {
  return has_street_side_tolerance_case() != HAS_STREET_SIDE_TOLERANCE_NOT_SET;
}
inline void Location::clear_has_has_street_side_tolerance() {
  _impl_._oneof_case_[8] = HAS_STREET_SIDE_TOLERANCE_NOT_SET;
}
inline bool Location::has_has_street_side_max_distance() const {
  return has_street_side_max_distance_case() != HAS_STREET_SIDE_MAX_DISTANCE_NOT_SET;
}
inline void Location::clear_has_has_street_side_max_distance() {
  _impl_._oneof_case_[9] = HAS_STREET_SIDE_MAX_DISTANCE_NOT_SET;
}
inline bool Location::has_has_preferred_layer() const {
  return has_preferred_layer_case() != HAS_PREFERRED_LAYER_NOT_SET;
}
inline void Location::clear_has_has_preferred_layer() {
  _impl_._oneof_case_[10] = HAS_PREFERRED_LAYER_NOT_SET;
}
inline bool Location::has_has_street_side_cutoff() const {
  return has_street_side_cutoff_case() != HAS_STREET_SIDE_CUTOFF_NOT_SET;
}
inline void Location::clear_has_has_street_side_cutoff() {
  _impl_._oneof_case_[11] = HAS_STREET_SIDE_CUTOFF_NOT_SET;
}
inline Location::HasHeadingCase Location::has_heading_case() const {
  return Location::HasHeadingCase(_impl_._oneof_case_[0]);
}
inline Location::HasHeadingToleranceCase Location::has_heading_tolerance_case() const {
  return Location::HasHeadingToleranceCase(_impl_._oneof_case_[1]);
}
inline Location::HasNodeSnapToleranceCase Location::has_node_snap_tolerance_case() const {
  return Location::HasNodeSnapToleranceCase(_impl_._oneof_case_[2]);
}
inline Location::HasMinimumReachabilityCase Location::has_minimum_reachability_case() const {
  return Location::HasMinimumReachabilityCase(_impl_._oneof_case_[3]);
}
inline Location::HasRadiusCase Location::has_radius_case() const {
  return Location::HasRadiusCase(_impl_._oneof_case_[4]);
}
inline Location::HasAccuracyCase Location::has_accuracy_case() const {
  return Location::HasAccuracyCase(_impl_._oneof_case_[5]);
}
inline Location::HasTimeCase Location::has_time_case() const {
  return Location::HasTimeCase(_impl_._oneof_case_[6]);
}
inline Location::HasSearchCutoffCase Location::has_search_cutoff_case() const {
  return Location::HasSearchCutoffCase(_impl_._oneof_case_[7]);
}
inline Location::HasStreetSideToleranceCase Location::has_street_side_tolerance_case() const {
  return Location::HasStreetSideToleranceCase(_impl_._oneof_case_[8]);
}
inline Location::HasStreetSideMaxDistanceCase Location::has_street_side_max_distance_case() const {
  return Location::HasStreetSideMaxDistanceCase(_impl_._oneof_case_[9]);
}
inline Location::HasPreferredLayerCase Location::has_preferred_layer_case() const {
  return Location::HasPreferredLayerCase(_impl_._oneof_case_[10]);
}
inline Location::HasStreetSideCutoffCase Location::has_street_side_cutoff_case() const {
  return Location::HasStreetSideCutoffCase(_impl_._oneof_case_[11]);
}
// -------------------------------------------------------------------

// TransitEgressInfo

// string onestop_id = 1;
inline void TransitEgressInfo::clear_onestop_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.onestop_id_.ClearToEmpty();
}
inline const std::string& TransitEgressInfo::onestop_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TransitEgressInfo.onestop_id)
  return _internal_onestop_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransitEgressInfo::set_onestop_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.onestop_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.TransitEgressInfo.onestop_id)
}
inline std::string* TransitEgressInfo::mutable_onestop_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_onestop_id();
  // @@protoc_insertion_point(field_mutable:valhalla.TransitEgressInfo.onestop_id)
  return _s;
}
inline const std::string& TransitEgressInfo::_internal_onestop_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.onestop_id_.Get();
}
inline void TransitEgressInfo::_internal_set_onestop_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.onestop_id_.Set(value, GetArena());
}
inline std::string* TransitEgressInfo::_internal_mutable_onestop_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.onestop_id_.Mutable( GetArena());
}
inline std::string* TransitEgressInfo::release_onestop_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TransitEgressInfo.onestop_id)
  return _impl_.onestop_id_.Release();
}
inline void TransitEgressInfo::set_allocated_onestop_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.onestop_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.onestop_id_.IsDefault()) {
          _impl_.onestop_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TransitEgressInfo.onestop_id)
}

// string name = 2;
inline void TransitEgressInfo::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& TransitEgressInfo::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TransitEgressInfo.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransitEgressInfo::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.TransitEgressInfo.name)
}
inline std::string* TransitEgressInfo::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:valhalla.TransitEgressInfo.name)
  return _s;
}
inline const std::string& TransitEgressInfo::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void TransitEgressInfo::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* TransitEgressInfo::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* TransitEgressInfo::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TransitEgressInfo.name)
  return _impl_.name_.Release();
}
inline void TransitEgressInfo::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TransitEgressInfo.name)
}

// .valhalla.LatLng ll = 3;
inline bool TransitEgressInfo::has_ll() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ll_ != nullptr);
  return value;
}
inline void TransitEgressInfo::clear_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.ll_ != nullptr) _impl_.ll_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::valhalla::LatLng& TransitEgressInfo::_internal_ll() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::LatLng* p = _impl_.ll_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::LatLng&>(::valhalla::_LatLng_default_instance_);
}
inline const ::valhalla::LatLng& TransitEgressInfo::ll() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TransitEgressInfo.ll)
  return _internal_ll();
}
inline void TransitEgressInfo::unsafe_arena_set_allocated_ll(::valhalla::LatLng* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ll_);
  }
  _impl_.ll_ = reinterpret_cast<::valhalla::LatLng*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TransitEgressInfo.ll)
}
inline ::valhalla::LatLng* TransitEgressInfo::release_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::LatLng* released = _impl_.ll_;
  _impl_.ll_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::LatLng* TransitEgressInfo::unsafe_arena_release_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TransitEgressInfo.ll)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::LatLng* temp = _impl_.ll_;
  _impl_.ll_ = nullptr;
  return temp;
}
inline ::valhalla::LatLng* TransitEgressInfo::_internal_mutable_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.ll_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::LatLng>(GetArena());
    _impl_.ll_ = reinterpret_cast<::valhalla::LatLng*>(p);
  }
  return _impl_.ll_;
}
inline ::valhalla::LatLng* TransitEgressInfo::mutable_ll() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::LatLng* _msg = _internal_mutable_ll();
  // @@protoc_insertion_point(field_mutable:valhalla.TransitEgressInfo.ll)
  return _msg;
}
inline void TransitEgressInfo::set_allocated_ll(::valhalla::LatLng* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::valhalla::LatLng*>(_impl_.ll_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::valhalla::LatLng*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.ll_ = reinterpret_cast<::valhalla::LatLng*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.TransitEgressInfo.ll)
}

// -------------------------------------------------------------------

// TransitStationInfo

// string onestop_id = 1;
inline void TransitStationInfo::clear_onestop_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.onestop_id_.ClearToEmpty();
}
inline const std::string& TransitStationInfo::onestop_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TransitStationInfo.onestop_id)
  return _internal_onestop_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransitStationInfo::set_onestop_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.onestop_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.TransitStationInfo.onestop_id)
}
inline std::string* TransitStationInfo::mutable_onestop_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_onestop_id();
  // @@protoc_insertion_point(field_mutable:valhalla.TransitStationInfo.onestop_id)
  return _s;
}
inline const std::string& TransitStationInfo::_internal_onestop_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.onestop_id_.Get();
}
inline void TransitStationInfo::_internal_set_onestop_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.onestop_id_.Set(value, GetArena());
}
inline std::string* TransitStationInfo::_internal_mutable_onestop_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.onestop_id_.Mutable( GetArena());
}
inline std::string* TransitStationInfo::release_onestop_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TransitStationInfo.onestop_id)
  return _impl_.onestop_id_.Release();
}
inline void TransitStationInfo::set_allocated_onestop_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.onestop_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.onestop_id_.IsDefault()) {
          _impl_.onestop_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TransitStationInfo.onestop_id)
}

// string name = 2;
inline void TransitStationInfo::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& TransitStationInfo::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TransitStationInfo.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransitStationInfo::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.TransitStationInfo.name)
}
inline std::string* TransitStationInfo::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:valhalla.TransitStationInfo.name)
  return _s;
}
inline const std::string& TransitStationInfo::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void TransitStationInfo::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* TransitStationInfo::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* TransitStationInfo::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TransitStationInfo.name)
  return _impl_.name_.Release();
}
inline void TransitStationInfo::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TransitStationInfo.name)
}

// .valhalla.LatLng ll = 3;
inline bool TransitStationInfo::has_ll() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ll_ != nullptr);
  return value;
}
inline void TransitStationInfo::clear_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.ll_ != nullptr) _impl_.ll_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::valhalla::LatLng& TransitStationInfo::_internal_ll() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::LatLng* p = _impl_.ll_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::LatLng&>(::valhalla::_LatLng_default_instance_);
}
inline const ::valhalla::LatLng& TransitStationInfo::ll() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TransitStationInfo.ll)
  return _internal_ll();
}
inline void TransitStationInfo::unsafe_arena_set_allocated_ll(::valhalla::LatLng* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ll_);
  }
  _impl_.ll_ = reinterpret_cast<::valhalla::LatLng*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TransitStationInfo.ll)
}
inline ::valhalla::LatLng* TransitStationInfo::release_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::LatLng* released = _impl_.ll_;
  _impl_.ll_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::LatLng* TransitStationInfo::unsafe_arena_release_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TransitStationInfo.ll)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::LatLng* temp = _impl_.ll_;
  _impl_.ll_ = nullptr;
  return temp;
}
inline ::valhalla::LatLng* TransitStationInfo::_internal_mutable_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.ll_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::LatLng>(GetArena());
    _impl_.ll_ = reinterpret_cast<::valhalla::LatLng*>(p);
  }
  return _impl_.ll_;
}
inline ::valhalla::LatLng* TransitStationInfo::mutable_ll() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::LatLng* _msg = _internal_mutable_ll();
  // @@protoc_insertion_point(field_mutable:valhalla.TransitStationInfo.ll)
  return _msg;
}
inline void TransitStationInfo::set_allocated_ll(::valhalla::LatLng* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::valhalla::LatLng*>(_impl_.ll_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::valhalla::LatLng*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.ll_ = reinterpret_cast<::valhalla::LatLng*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.TransitStationInfo.ll)
}

// -------------------------------------------------------------------

// BikeShareStationInfo

// string name = 1;
inline void BikeShareStationInfo::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& BikeShareStationInfo::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.BikeShareStationInfo.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BikeShareStationInfo::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.BikeShareStationInfo.name)
}
inline std::string* BikeShareStationInfo::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:valhalla.BikeShareStationInfo.name)
  return _s;
}
inline const std::string& BikeShareStationInfo::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void BikeShareStationInfo::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* BikeShareStationInfo::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* BikeShareStationInfo::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.BikeShareStationInfo.name)
  return _impl_.name_.Release();
}
inline void BikeShareStationInfo::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.BikeShareStationInfo.name)
}

// string ref = 2;
inline void BikeShareStationInfo::clear_ref() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ref_.ClearToEmpty();
}
inline const std::string& BikeShareStationInfo::ref() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.BikeShareStationInfo.ref)
  return _internal_ref();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BikeShareStationInfo::set_ref(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ref_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.BikeShareStationInfo.ref)
}
inline std::string* BikeShareStationInfo::mutable_ref() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ref();
  // @@protoc_insertion_point(field_mutable:valhalla.BikeShareStationInfo.ref)
  return _s;
}
inline const std::string& BikeShareStationInfo::_internal_ref() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ref_.Get();
}
inline void BikeShareStationInfo::_internal_set_ref(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ref_.Set(value, GetArena());
}
inline std::string* BikeShareStationInfo::_internal_mutable_ref() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.ref_.Mutable( GetArena());
}
inline std::string* BikeShareStationInfo::release_ref() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.BikeShareStationInfo.ref)
  return _impl_.ref_.Release();
}
inline void BikeShareStationInfo::set_allocated_ref(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ref_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ref_.IsDefault()) {
          _impl_.ref_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.BikeShareStationInfo.ref)
}

// uint32 capacity = 3;
inline void BikeShareStationInfo::clear_capacity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.capacity_ = 0u;
}
inline ::uint32_t BikeShareStationInfo::capacity() const {
  // @@protoc_insertion_point(field_get:valhalla.BikeShareStationInfo.capacity)
  return _internal_capacity();
}
inline void BikeShareStationInfo::set_capacity(::uint32_t value) {
  _internal_set_capacity(value);
  // @@protoc_insertion_point(field_set:valhalla.BikeShareStationInfo.capacity)
}
inline ::uint32_t BikeShareStationInfo::_internal_capacity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.capacity_;
}
inline void BikeShareStationInfo::_internal_set_capacity(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.capacity_ = value;
}

// string network = 4;
inline void BikeShareStationInfo::clear_network() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.network_.ClearToEmpty();
}
inline const std::string& BikeShareStationInfo::network() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.BikeShareStationInfo.network)
  return _internal_network();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BikeShareStationInfo::set_network(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.network_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.BikeShareStationInfo.network)
}
inline std::string* BikeShareStationInfo::mutable_network() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_network();
  // @@protoc_insertion_point(field_mutable:valhalla.BikeShareStationInfo.network)
  return _s;
}
inline const std::string& BikeShareStationInfo::_internal_network() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.network_.Get();
}
inline void BikeShareStationInfo::_internal_set_network(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.network_.Set(value, GetArena());
}
inline std::string* BikeShareStationInfo::_internal_mutable_network() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.network_.Mutable( GetArena());
}
inline std::string* BikeShareStationInfo::release_network() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.BikeShareStationInfo.network)
  return _impl_.network_.Release();
}
inline void BikeShareStationInfo::set_allocated_network(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.network_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.network_.IsDefault()) {
          _impl_.network_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.BikeShareStationInfo.network)
}

// string operator = 5;
inline void BikeShareStationInfo::clear_operator_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.operator__.ClearToEmpty();
}
inline const std::string& BikeShareStationInfo::operator_() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.BikeShareStationInfo.operator)
  return _internal_operator_();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BikeShareStationInfo::set_operator_(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.operator__.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.BikeShareStationInfo.operator)
}
inline std::string* BikeShareStationInfo::mutable_operator_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_operator_();
  // @@protoc_insertion_point(field_mutable:valhalla.BikeShareStationInfo.operator)
  return _s;
}
inline const std::string& BikeShareStationInfo::_internal_operator_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.operator__.Get();
}
inline void BikeShareStationInfo::_internal_set_operator_(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.operator__.Set(value, GetArena());
}
inline std::string* BikeShareStationInfo::_internal_mutable_operator_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.operator__.Mutable( GetArena());
}
inline std::string* BikeShareStationInfo::release_operator_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.BikeShareStationInfo.operator)
  return _impl_.operator__.Release();
}
inline void BikeShareStationInfo::set_allocated_operator_(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.operator__.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.operator__.IsDefault()) {
          _impl_.operator__.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.BikeShareStationInfo.operator)
}

// float rent_cost = 6;
inline void BikeShareStationInfo::clear_rent_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rent_cost_ = 0;
}
inline float BikeShareStationInfo::rent_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.BikeShareStationInfo.rent_cost)
  return _internal_rent_cost();
}
inline void BikeShareStationInfo::set_rent_cost(float value) {
  _internal_set_rent_cost(value);
  // @@protoc_insertion_point(field_set:valhalla.BikeShareStationInfo.rent_cost)
}
inline float BikeShareStationInfo::_internal_rent_cost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rent_cost_;
}
inline void BikeShareStationInfo::_internal_set_rent_cost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.rent_cost_ = value;
}

// float return_cost = 7;
inline void BikeShareStationInfo::clear_return_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.return_cost_ = 0;
}
inline float BikeShareStationInfo::return_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.BikeShareStationInfo.return_cost)
  return _internal_return_cost();
}
inline void BikeShareStationInfo::set_return_cost(float value) {
  _internal_set_return_cost(value);
  // @@protoc_insertion_point(field_set:valhalla.BikeShareStationInfo.return_cost)
}
inline float BikeShareStationInfo::_internal_return_cost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.return_cost_;
}
inline void BikeShareStationInfo::_internal_set_return_cost(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.return_cost_ = value;
}

// -------------------------------------------------------------------

// TransitPlatformInfo

// .valhalla.TransitPlatformInfo.Type type = 1;
inline void TransitPlatformInfo::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::valhalla::TransitPlatformInfo_Type TransitPlatformInfo::type() const {
  // @@protoc_insertion_point(field_get:valhalla.TransitPlatformInfo.type)
  return _internal_type();
}
inline void TransitPlatformInfo::set_type(::valhalla::TransitPlatformInfo_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:valhalla.TransitPlatformInfo.type)
}
inline ::valhalla::TransitPlatformInfo_Type TransitPlatformInfo::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::TransitPlatformInfo_Type>(_impl_.type_);
}
inline void TransitPlatformInfo::_internal_set_type(::valhalla::TransitPlatformInfo_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// string onestop_id = 2;
inline void TransitPlatformInfo::clear_onestop_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.onestop_id_.ClearToEmpty();
}
inline const std::string& TransitPlatformInfo::onestop_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TransitPlatformInfo.onestop_id)
  return _internal_onestop_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransitPlatformInfo::set_onestop_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.onestop_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.TransitPlatformInfo.onestop_id)
}
inline std::string* TransitPlatformInfo::mutable_onestop_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_onestop_id();
  // @@protoc_insertion_point(field_mutable:valhalla.TransitPlatformInfo.onestop_id)
  return _s;
}
inline const std::string& TransitPlatformInfo::_internal_onestop_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.onestop_id_.Get();
}
inline void TransitPlatformInfo::_internal_set_onestop_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.onestop_id_.Set(value, GetArena());
}
inline std::string* TransitPlatformInfo::_internal_mutable_onestop_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.onestop_id_.Mutable( GetArena());
}
inline std::string* TransitPlatformInfo::release_onestop_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TransitPlatformInfo.onestop_id)
  return _impl_.onestop_id_.Release();
}
inline void TransitPlatformInfo::set_allocated_onestop_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.onestop_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.onestop_id_.IsDefault()) {
          _impl_.onestop_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TransitPlatformInfo.onestop_id)
}

// string name = 3;
inline void TransitPlatformInfo::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& TransitPlatformInfo::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TransitPlatformInfo.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransitPlatformInfo::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.TransitPlatformInfo.name)
}
inline std::string* TransitPlatformInfo::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:valhalla.TransitPlatformInfo.name)
  return _s;
}
inline const std::string& TransitPlatformInfo::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void TransitPlatformInfo::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* TransitPlatformInfo::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* TransitPlatformInfo::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TransitPlatformInfo.name)
  return _impl_.name_.Release();
}
inline void TransitPlatformInfo::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TransitPlatformInfo.name)
}

// string arrival_date_time = 4;
inline void TransitPlatformInfo::clear_arrival_date_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.arrival_date_time_.ClearToEmpty();
}
inline const std::string& TransitPlatformInfo::arrival_date_time() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TransitPlatformInfo.arrival_date_time)
  return _internal_arrival_date_time();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransitPlatformInfo::set_arrival_date_time(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.arrival_date_time_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.TransitPlatformInfo.arrival_date_time)
}
inline std::string* TransitPlatformInfo::mutable_arrival_date_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_arrival_date_time();
  // @@protoc_insertion_point(field_mutable:valhalla.TransitPlatformInfo.arrival_date_time)
  return _s;
}
inline const std::string& TransitPlatformInfo::_internal_arrival_date_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.arrival_date_time_.Get();
}
inline void TransitPlatformInfo::_internal_set_arrival_date_time(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.arrival_date_time_.Set(value, GetArena());
}
inline std::string* TransitPlatformInfo::_internal_mutable_arrival_date_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.arrival_date_time_.Mutable( GetArena());
}
inline std::string* TransitPlatformInfo::release_arrival_date_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TransitPlatformInfo.arrival_date_time)
  return _impl_.arrival_date_time_.Release();
}
inline void TransitPlatformInfo::set_allocated_arrival_date_time(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.arrival_date_time_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.arrival_date_time_.IsDefault()) {
          _impl_.arrival_date_time_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TransitPlatformInfo.arrival_date_time)
}

// string departure_date_time = 5;
inline void TransitPlatformInfo::clear_departure_date_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.departure_date_time_.ClearToEmpty();
}
inline const std::string& TransitPlatformInfo::departure_date_time() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TransitPlatformInfo.departure_date_time)
  return _internal_departure_date_time();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransitPlatformInfo::set_departure_date_time(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.departure_date_time_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.TransitPlatformInfo.departure_date_time)
}
inline std::string* TransitPlatformInfo::mutable_departure_date_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_departure_date_time();
  // @@protoc_insertion_point(field_mutable:valhalla.TransitPlatformInfo.departure_date_time)
  return _s;
}
inline const std::string& TransitPlatformInfo::_internal_departure_date_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.departure_date_time_.Get();
}
inline void TransitPlatformInfo::_internal_set_departure_date_time(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.departure_date_time_.Set(value, GetArena());
}
inline std::string* TransitPlatformInfo::_internal_mutable_departure_date_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.departure_date_time_.Mutable( GetArena());
}
inline std::string* TransitPlatformInfo::release_departure_date_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TransitPlatformInfo.departure_date_time)
  return _impl_.departure_date_time_.Release();
}
inline void TransitPlatformInfo::set_allocated_departure_date_time(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.departure_date_time_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.departure_date_time_.IsDefault()) {
          _impl_.departure_date_time_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TransitPlatformInfo.departure_date_time)
}

// bool assumed_schedule = 6;
inline void TransitPlatformInfo::clear_assumed_schedule() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.assumed_schedule_ = false;
}
inline bool TransitPlatformInfo::assumed_schedule() const {
  // @@protoc_insertion_point(field_get:valhalla.TransitPlatformInfo.assumed_schedule)
  return _internal_assumed_schedule();
}
inline void TransitPlatformInfo::set_assumed_schedule(bool value) {
  _internal_set_assumed_schedule(value);
  // @@protoc_insertion_point(field_set:valhalla.TransitPlatformInfo.assumed_schedule)
}
inline bool TransitPlatformInfo::_internal_assumed_schedule() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.assumed_schedule_;
}
inline void TransitPlatformInfo::_internal_set_assumed_schedule(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.assumed_schedule_ = value;
}

// .valhalla.LatLng ll = 7;
inline bool TransitPlatformInfo::has_ll() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ll_ != nullptr);
  return value;
}
inline void TransitPlatformInfo::clear_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.ll_ != nullptr) _impl_.ll_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::valhalla::LatLng& TransitPlatformInfo::_internal_ll() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::LatLng* p = _impl_.ll_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::LatLng&>(::valhalla::_LatLng_default_instance_);
}
inline const ::valhalla::LatLng& TransitPlatformInfo::ll() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TransitPlatformInfo.ll)
  return _internal_ll();
}
inline void TransitPlatformInfo::unsafe_arena_set_allocated_ll(::valhalla::LatLng* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ll_);
  }
  _impl_.ll_ = reinterpret_cast<::valhalla::LatLng*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TransitPlatformInfo.ll)
}
inline ::valhalla::LatLng* TransitPlatformInfo::release_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::LatLng* released = _impl_.ll_;
  _impl_.ll_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::LatLng* TransitPlatformInfo::unsafe_arena_release_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TransitPlatformInfo.ll)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::LatLng* temp = _impl_.ll_;
  _impl_.ll_ = nullptr;
  return temp;
}
inline ::valhalla::LatLng* TransitPlatformInfo::_internal_mutable_ll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.ll_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::LatLng>(GetArena());
    _impl_.ll_ = reinterpret_cast<::valhalla::LatLng*>(p);
  }
  return _impl_.ll_;
}
inline ::valhalla::LatLng* TransitPlatformInfo::mutable_ll() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::LatLng* _msg = _internal_mutable_ll();
  // @@protoc_insertion_point(field_mutable:valhalla.TransitPlatformInfo.ll)
  return _msg;
}
inline void TransitPlatformInfo::set_allocated_ll(::valhalla::LatLng* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::valhalla::LatLng*>(_impl_.ll_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::valhalla::LatLng*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.ll_ = reinterpret_cast<::valhalla::LatLng*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.TransitPlatformInfo.ll)
}

// string station_onestop_id = 8;
inline void TransitPlatformInfo::clear_station_onestop_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.station_onestop_id_.ClearToEmpty();
}
inline const std::string& TransitPlatformInfo::station_onestop_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TransitPlatformInfo.station_onestop_id)
  return _internal_station_onestop_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransitPlatformInfo::set_station_onestop_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.station_onestop_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.TransitPlatformInfo.station_onestop_id)
}
inline std::string* TransitPlatformInfo::mutable_station_onestop_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_station_onestop_id();
  // @@protoc_insertion_point(field_mutable:valhalla.TransitPlatformInfo.station_onestop_id)
  return _s;
}
inline const std::string& TransitPlatformInfo::_internal_station_onestop_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.station_onestop_id_.Get();
}
inline void TransitPlatformInfo::_internal_set_station_onestop_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.station_onestop_id_.Set(value, GetArena());
}
inline std::string* TransitPlatformInfo::_internal_mutable_station_onestop_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.station_onestop_id_.Mutable( GetArena());
}
inline std::string* TransitPlatformInfo::release_station_onestop_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TransitPlatformInfo.station_onestop_id)
  return _impl_.station_onestop_id_.Release();
}
inline void TransitPlatformInfo::set_allocated_station_onestop_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.station_onestop_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.station_onestop_id_.IsDefault()) {
          _impl_.station_onestop_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TransitPlatformInfo.station_onestop_id)
}

// string station_name = 9;
inline void TransitPlatformInfo::clear_station_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.station_name_.ClearToEmpty();
}
inline const std::string& TransitPlatformInfo::station_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TransitPlatformInfo.station_name)
  return _internal_station_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransitPlatformInfo::set_station_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.station_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.TransitPlatformInfo.station_name)
}
inline std::string* TransitPlatformInfo::mutable_station_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_station_name();
  // @@protoc_insertion_point(field_mutable:valhalla.TransitPlatformInfo.station_name)
  return _s;
}
inline const std::string& TransitPlatformInfo::_internal_station_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.station_name_.Get();
}
inline void TransitPlatformInfo::_internal_set_station_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.station_name_.Set(value, GetArena());
}
inline std::string* TransitPlatformInfo::_internal_mutable_station_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.station_name_.Mutable( GetArena());
}
inline std::string* TransitPlatformInfo::release_station_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TransitPlatformInfo.station_name)
  return _impl_.station_name_.Release();
}
inline void TransitPlatformInfo::set_allocated_station_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.station_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.station_name_.IsDefault()) {
          _impl_.station_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TransitPlatformInfo.station_name)
}

// -------------------------------------------------------------------

// TransitRouteInfo

// string onestop_id = 1;
inline void TransitRouteInfo::clear_onestop_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.onestop_id_.ClearToEmpty();
}
inline const std::string& TransitRouteInfo::onestop_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TransitRouteInfo.onestop_id)
  return _internal_onestop_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransitRouteInfo::set_onestop_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.onestop_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.TransitRouteInfo.onestop_id)
}
inline std::string* TransitRouteInfo::mutable_onestop_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_onestop_id();
  // @@protoc_insertion_point(field_mutable:valhalla.TransitRouteInfo.onestop_id)
  return _s;
}
inline const std::string& TransitRouteInfo::_internal_onestop_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.onestop_id_.Get();
}
inline void TransitRouteInfo::_internal_set_onestop_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.onestop_id_.Set(value, GetArena());
}
inline std::string* TransitRouteInfo::_internal_mutable_onestop_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.onestop_id_.Mutable( GetArena());
}
inline std::string* TransitRouteInfo::release_onestop_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TransitRouteInfo.onestop_id)
  return _impl_.onestop_id_.Release();
}
inline void TransitRouteInfo::set_allocated_onestop_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.onestop_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.onestop_id_.IsDefault()) {
          _impl_.onestop_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TransitRouteInfo.onestop_id)
}

// uint32 block_id = 2;
inline void TransitRouteInfo::clear_block_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.block_id_ = 0u;
}
inline ::uint32_t TransitRouteInfo::block_id() const {
  // @@protoc_insertion_point(field_get:valhalla.TransitRouteInfo.block_id)
  return _internal_block_id();
}
inline void TransitRouteInfo::set_block_id(::uint32_t value) {
  _internal_set_block_id(value);
  // @@protoc_insertion_point(field_set:valhalla.TransitRouteInfo.block_id)
}
inline ::uint32_t TransitRouteInfo::_internal_block_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.block_id_;
}
inline void TransitRouteInfo::_internal_set_block_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.block_id_ = value;
}

// uint32 trip_id = 3;
inline void TransitRouteInfo::clear_trip_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.trip_id_ = 0u;
}
inline ::uint32_t TransitRouteInfo::trip_id() const {
  // @@protoc_insertion_point(field_get:valhalla.TransitRouteInfo.trip_id)
  return _internal_trip_id();
}
inline void TransitRouteInfo::set_trip_id(::uint32_t value) {
  _internal_set_trip_id(value);
  // @@protoc_insertion_point(field_set:valhalla.TransitRouteInfo.trip_id)
}
inline ::uint32_t TransitRouteInfo::_internal_trip_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.trip_id_;
}
inline void TransitRouteInfo::_internal_set_trip_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.trip_id_ = value;
}

// string short_name = 4;
inline void TransitRouteInfo::clear_short_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.short_name_.ClearToEmpty();
}
inline const std::string& TransitRouteInfo::short_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TransitRouteInfo.short_name)
  return _internal_short_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransitRouteInfo::set_short_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.short_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.TransitRouteInfo.short_name)
}
inline std::string* TransitRouteInfo::mutable_short_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_short_name();
  // @@protoc_insertion_point(field_mutable:valhalla.TransitRouteInfo.short_name)
  return _s;
}
inline const std::string& TransitRouteInfo::_internal_short_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.short_name_.Get();
}
inline void TransitRouteInfo::_internal_set_short_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.short_name_.Set(value, GetArena());
}
inline std::string* TransitRouteInfo::_internal_mutable_short_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.short_name_.Mutable( GetArena());
}
inline std::string* TransitRouteInfo::release_short_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TransitRouteInfo.short_name)
  return _impl_.short_name_.Release();
}
inline void TransitRouteInfo::set_allocated_short_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.short_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.short_name_.IsDefault()) {
          _impl_.short_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TransitRouteInfo.short_name)
}

// string long_name = 5;
inline void TransitRouteInfo::clear_long_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.long_name_.ClearToEmpty();
}
inline const std::string& TransitRouteInfo::long_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TransitRouteInfo.long_name)
  return _internal_long_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransitRouteInfo::set_long_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.long_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.TransitRouteInfo.long_name)
}
inline std::string* TransitRouteInfo::mutable_long_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_long_name();
  // @@protoc_insertion_point(field_mutable:valhalla.TransitRouteInfo.long_name)
  return _s;
}
inline const std::string& TransitRouteInfo::_internal_long_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.long_name_.Get();
}
inline void TransitRouteInfo::_internal_set_long_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.long_name_.Set(value, GetArena());
}
inline std::string* TransitRouteInfo::_internal_mutable_long_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.long_name_.Mutable( GetArena());
}
inline std::string* TransitRouteInfo::release_long_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TransitRouteInfo.long_name)
  return _impl_.long_name_.Release();
}
inline void TransitRouteInfo::set_allocated_long_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.long_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.long_name_.IsDefault()) {
          _impl_.long_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TransitRouteInfo.long_name)
}

// string headsign = 6;
inline void TransitRouteInfo::clear_headsign() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.headsign_.ClearToEmpty();
}
inline const std::string& TransitRouteInfo::headsign() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TransitRouteInfo.headsign)
  return _internal_headsign();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransitRouteInfo::set_headsign(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.headsign_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.TransitRouteInfo.headsign)
}
inline std::string* TransitRouteInfo::mutable_headsign() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_headsign();
  // @@protoc_insertion_point(field_mutable:valhalla.TransitRouteInfo.headsign)
  return _s;
}
inline const std::string& TransitRouteInfo::_internal_headsign() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.headsign_.Get();
}
inline void TransitRouteInfo::_internal_set_headsign(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.headsign_.Set(value, GetArena());
}
inline std::string* TransitRouteInfo::_internal_mutable_headsign() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.headsign_.Mutable( GetArena());
}
inline std::string* TransitRouteInfo::release_headsign() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TransitRouteInfo.headsign)
  return _impl_.headsign_.Release();
}
inline void TransitRouteInfo::set_allocated_headsign(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.headsign_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.headsign_.IsDefault()) {
          _impl_.headsign_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TransitRouteInfo.headsign)
}

// uint32 color = 7;
inline void TransitRouteInfo::clear_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.color_ = 0u;
}
inline ::uint32_t TransitRouteInfo::color() const {
  // @@protoc_insertion_point(field_get:valhalla.TransitRouteInfo.color)
  return _internal_color();
}
inline void TransitRouteInfo::set_color(::uint32_t value) {
  _internal_set_color(value);
  // @@protoc_insertion_point(field_set:valhalla.TransitRouteInfo.color)
}
inline ::uint32_t TransitRouteInfo::_internal_color() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.color_;
}
inline void TransitRouteInfo::_internal_set_color(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.color_ = value;
}

// uint32 text_color = 8;
inline void TransitRouteInfo::clear_text_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_color_ = 0u;
}
inline ::uint32_t TransitRouteInfo::text_color() const {
  // @@protoc_insertion_point(field_get:valhalla.TransitRouteInfo.text_color)
  return _internal_text_color();
}
inline void TransitRouteInfo::set_text_color(::uint32_t value) {
  _internal_set_text_color(value);
  // @@protoc_insertion_point(field_set:valhalla.TransitRouteInfo.text_color)
}
inline ::uint32_t TransitRouteInfo::_internal_text_color() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.text_color_;
}
inline void TransitRouteInfo::_internal_set_text_color(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.text_color_ = value;
}

// string description = 9;
inline void TransitRouteInfo::clear_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.ClearToEmpty();
}
inline const std::string& TransitRouteInfo::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TransitRouteInfo.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransitRouteInfo::set_description(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.TransitRouteInfo.description)
}
inline std::string* TransitRouteInfo::mutable_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:valhalla.TransitRouteInfo.description)
  return _s;
}
inline const std::string& TransitRouteInfo::_internal_description() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.description_.Get();
}
inline void TransitRouteInfo::_internal_set_description(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(value, GetArena());
}
inline std::string* TransitRouteInfo::_internal_mutable_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.description_.Mutable( GetArena());
}
inline std::string* TransitRouteInfo::release_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TransitRouteInfo.description)
  return _impl_.description_.Release();
}
inline void TransitRouteInfo::set_allocated_description(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TransitRouteInfo.description)
}

// string operator_onestop_id = 10;
inline void TransitRouteInfo::clear_operator_onestop_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.operator_onestop_id_.ClearToEmpty();
}
inline const std::string& TransitRouteInfo::operator_onestop_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TransitRouteInfo.operator_onestop_id)
  return _internal_operator_onestop_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransitRouteInfo::set_operator_onestop_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.operator_onestop_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.TransitRouteInfo.operator_onestop_id)
}
inline std::string* TransitRouteInfo::mutable_operator_onestop_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_operator_onestop_id();
  // @@protoc_insertion_point(field_mutable:valhalla.TransitRouteInfo.operator_onestop_id)
  return _s;
}
inline const std::string& TransitRouteInfo::_internal_operator_onestop_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.operator_onestop_id_.Get();
}
inline void TransitRouteInfo::_internal_set_operator_onestop_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.operator_onestop_id_.Set(value, GetArena());
}
inline std::string* TransitRouteInfo::_internal_mutable_operator_onestop_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.operator_onestop_id_.Mutable( GetArena());
}
inline std::string* TransitRouteInfo::release_operator_onestop_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TransitRouteInfo.operator_onestop_id)
  return _impl_.operator_onestop_id_.Release();
}
inline void TransitRouteInfo::set_allocated_operator_onestop_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.operator_onestop_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.operator_onestop_id_.IsDefault()) {
          _impl_.operator_onestop_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TransitRouteInfo.operator_onestop_id)
}

// string operator_name = 11;
inline void TransitRouteInfo::clear_operator_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.operator_name_.ClearToEmpty();
}
inline const std::string& TransitRouteInfo::operator_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TransitRouteInfo.operator_name)
  return _internal_operator_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransitRouteInfo::set_operator_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.operator_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.TransitRouteInfo.operator_name)
}
inline std::string* TransitRouteInfo::mutable_operator_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_operator_name();
  // @@protoc_insertion_point(field_mutable:valhalla.TransitRouteInfo.operator_name)
  return _s;
}
inline const std::string& TransitRouteInfo::_internal_operator_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.operator_name_.Get();
}
inline void TransitRouteInfo::_internal_set_operator_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.operator_name_.Set(value, GetArena());
}
inline std::string* TransitRouteInfo::_internal_mutable_operator_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.operator_name_.Mutable( GetArena());
}
inline std::string* TransitRouteInfo::release_operator_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TransitRouteInfo.operator_name)
  return _impl_.operator_name_.Release();
}
inline void TransitRouteInfo::set_allocated_operator_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.operator_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.operator_name_.IsDefault()) {
          _impl_.operator_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TransitRouteInfo.operator_name)
}

// string operator_url = 12;
inline void TransitRouteInfo::clear_operator_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.operator_url_.ClearToEmpty();
}
inline const std::string& TransitRouteInfo::operator_url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TransitRouteInfo.operator_url)
  return _internal_operator_url();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TransitRouteInfo::set_operator_url(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.operator_url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.TransitRouteInfo.operator_url)
}
inline std::string* TransitRouteInfo::mutable_operator_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_operator_url();
  // @@protoc_insertion_point(field_mutable:valhalla.TransitRouteInfo.operator_url)
  return _s;
}
inline const std::string& TransitRouteInfo::_internal_operator_url() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.operator_url_.Get();
}
inline void TransitRouteInfo::_internal_set_operator_url(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.operator_url_.Set(value, GetArena());
}
inline std::string* TransitRouteInfo::_internal_mutable_operator_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.operator_url_.Mutable( GetArena());
}
inline std::string* TransitRouteInfo::release_operator_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TransitRouteInfo.operator_url)
  return _impl_.operator_url_.Release();
}
inline void TransitRouteInfo::set_allocated_operator_url(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.operator_url_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.operator_url_.IsDefault()) {
          _impl_.operator_url_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TransitRouteInfo.operator_url)
}

// repeated .valhalla.TransitPlatformInfo transit_stops = 13;
inline int TransitRouteInfo::_internal_transit_stops_size() const {
  return _internal_transit_stops().size();
}
inline int TransitRouteInfo::transit_stops_size() const {
  return _internal_transit_stops_size();
}
inline void TransitRouteInfo::clear_transit_stops() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.transit_stops_.Clear();
}
inline ::valhalla::TransitPlatformInfo* TransitRouteInfo::mutable_transit_stops(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.TransitRouteInfo.transit_stops)
  return _internal_mutable_transit_stops()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::TransitPlatformInfo>* TransitRouteInfo::mutable_transit_stops()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TransitRouteInfo.transit_stops)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_transit_stops();
}
inline const ::valhalla::TransitPlatformInfo& TransitRouteInfo::transit_stops(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TransitRouteInfo.transit_stops)
  return _internal_transit_stops().Get(index);
}
inline ::valhalla::TransitPlatformInfo* TransitRouteInfo::add_transit_stops() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::TransitPlatformInfo* _add = _internal_mutable_transit_stops()->Add();
  // @@protoc_insertion_point(field_add:valhalla.TransitRouteInfo.transit_stops)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::TransitPlatformInfo>& TransitRouteInfo::transit_stops() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.TransitRouteInfo.transit_stops)
  return _internal_transit_stops();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::TransitPlatformInfo>&
TransitRouteInfo::_internal_transit_stops() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transit_stops_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::TransitPlatformInfo>*
TransitRouteInfo::_internal_mutable_transit_stops() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.transit_stops_;
}

// -------------------------------------------------------------------

// Pronunciation

// .valhalla.Pronunciation.Alphabet alphabet = 1;
inline void Pronunciation::clear_alphabet() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.alphabet_ = 0;
}
inline ::valhalla::Pronunciation_Alphabet Pronunciation::alphabet() const {
  // @@protoc_insertion_point(field_get:valhalla.Pronunciation.alphabet)
  return _internal_alphabet();
}
inline void Pronunciation::set_alphabet(::valhalla::Pronunciation_Alphabet value) {
  _internal_set_alphabet(value);
  // @@protoc_insertion_point(field_set:valhalla.Pronunciation.alphabet)
}
inline ::valhalla::Pronunciation_Alphabet Pronunciation::_internal_alphabet() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::Pronunciation_Alphabet>(_impl_.alphabet_);
}
inline void Pronunciation::_internal_set_alphabet(::valhalla::Pronunciation_Alphabet value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.alphabet_ = value;
}

// string value = 2;
inline void Pronunciation::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.ClearToEmpty();
}
inline const std::string& Pronunciation::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Pronunciation.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Pronunciation::set_value(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.Pronunciation.value)
}
inline std::string* Pronunciation::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:valhalla.Pronunciation.value)
  return _s;
}
inline const std::string& Pronunciation::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_.Get();
}
inline void Pronunciation::_internal_set_value(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_.Set(value, GetArena());
}
inline std::string* Pronunciation::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.value_.Mutable( GetArena());
}
inline std::string* Pronunciation::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.Pronunciation.value)
  return _impl_.value_.Release();
}
inline void Pronunciation::set_allocated_value(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.Pronunciation.value)
}

// -------------------------------------------------------------------

// StreetName

// string value = 1;
inline void StreetName::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.ClearToEmpty();
}
inline const std::string& StreetName::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.StreetName.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StreetName::set_value(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.StreetName.value)
}
inline std::string* StreetName::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:valhalla.StreetName.value)
  return _s;
}
inline const std::string& StreetName::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_.Get();
}
inline void StreetName::_internal_set_value(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_.Set(value, GetArena());
}
inline std::string* StreetName::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.value_.Mutable( GetArena());
}
inline std::string* StreetName::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.StreetName.value)
  return _impl_.value_.Release();
}
inline void StreetName::set_allocated_value(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.StreetName.value)
}

// bool is_route_number = 2;
inline void StreetName::clear_is_route_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_route_number_ = false;
}
inline bool StreetName::is_route_number() const {
  // @@protoc_insertion_point(field_get:valhalla.StreetName.is_route_number)
  return _internal_is_route_number();
}
inline void StreetName::set_is_route_number(bool value) {
  _internal_set_is_route_number(value);
  // @@protoc_insertion_point(field_set:valhalla.StreetName.is_route_number)
}
inline bool StreetName::_internal_is_route_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_route_number_;
}
inline void StreetName::_internal_set_is_route_number(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_route_number_ = value;
}

// .valhalla.Pronunciation pronunciation = 3;
inline bool StreetName::has_pronunciation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pronunciation_ != nullptr);
  return value;
}
inline void StreetName::clear_pronunciation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pronunciation_ != nullptr) _impl_.pronunciation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::valhalla::Pronunciation& StreetName::_internal_pronunciation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::Pronunciation* p = _impl_.pronunciation_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::Pronunciation&>(::valhalla::_Pronunciation_default_instance_);
}
inline const ::valhalla::Pronunciation& StreetName::pronunciation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.StreetName.pronunciation)
  return _internal_pronunciation();
}
inline void StreetName::unsafe_arena_set_allocated_pronunciation(::valhalla::Pronunciation* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pronunciation_);
  }
  _impl_.pronunciation_ = reinterpret_cast<::valhalla::Pronunciation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.StreetName.pronunciation)
}
inline ::valhalla::Pronunciation* StreetName::release_pronunciation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::Pronunciation* released = _impl_.pronunciation_;
  _impl_.pronunciation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::Pronunciation* StreetName::unsafe_arena_release_pronunciation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.StreetName.pronunciation)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::Pronunciation* temp = _impl_.pronunciation_;
  _impl_.pronunciation_ = nullptr;
  return temp;
}
inline ::valhalla::Pronunciation* StreetName::_internal_mutable_pronunciation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.pronunciation_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::Pronunciation>(GetArena());
    _impl_.pronunciation_ = reinterpret_cast<::valhalla::Pronunciation*>(p);
  }
  return _impl_.pronunciation_;
}
inline ::valhalla::Pronunciation* StreetName::mutable_pronunciation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::Pronunciation* _msg = _internal_mutable_pronunciation();
  // @@protoc_insertion_point(field_mutable:valhalla.StreetName.pronunciation)
  return _msg;
}
inline void StreetName::set_allocated_pronunciation(::valhalla::Pronunciation* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::valhalla::Pronunciation*>(_impl_.pronunciation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::valhalla::Pronunciation*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pronunciation_ = reinterpret_cast<::valhalla::Pronunciation*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.StreetName.pronunciation)
}

// .valhalla.LanguageTag language_tag = 4;
inline void StreetName::clear_language_tag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.language_tag_ = 0;
}
inline ::valhalla::LanguageTag StreetName::language_tag() const {
  // @@protoc_insertion_point(field_get:valhalla.StreetName.language_tag)
  return _internal_language_tag();
}
inline void StreetName::set_language_tag(::valhalla::LanguageTag value) {
  _internal_set_language_tag(value);
  // @@protoc_insertion_point(field_set:valhalla.StreetName.language_tag)
}
inline ::valhalla::LanguageTag StreetName::_internal_language_tag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::LanguageTag>(_impl_.language_tag_);
}
inline void StreetName::_internal_set_language_tag(::valhalla::LanguageTag value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.language_tag_ = value;
}

// -------------------------------------------------------------------

// TurnLane

// uint32 directions_mask = 1;
inline void TurnLane::clear_directions_mask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.directions_mask_ = 0u;
}
inline ::uint32_t TurnLane::directions_mask() const {
  // @@protoc_insertion_point(field_get:valhalla.TurnLane.directions_mask)
  return _internal_directions_mask();
}
inline void TurnLane::set_directions_mask(::uint32_t value) {
  _internal_set_directions_mask(value);
  // @@protoc_insertion_point(field_set:valhalla.TurnLane.directions_mask)
}
inline ::uint32_t TurnLane::_internal_directions_mask() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.directions_mask_;
}
inline void TurnLane::_internal_set_directions_mask(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.directions_mask_ = value;
}

// .valhalla.TurnLane.State state = 2;
inline void TurnLane::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = 0;
}
inline ::valhalla::TurnLane_State TurnLane::state() const {
  // @@protoc_insertion_point(field_get:valhalla.TurnLane.state)
  return _internal_state();
}
inline void TurnLane::set_state(::valhalla::TurnLane_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:valhalla.TurnLane.state)
}
inline ::valhalla::TurnLane_State TurnLane::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::TurnLane_State>(_impl_.state_);
}
inline void TurnLane::_internal_set_state(::valhalla::TurnLane_State value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.state_ = value;
}

// uint32 active_direction = 3;
inline void TurnLane::clear_active_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.active_direction_ = 0u;
}
inline ::uint32_t TurnLane::active_direction() const {
  // @@protoc_insertion_point(field_get:valhalla.TurnLane.active_direction)
  return _internal_active_direction();
}
inline void TurnLane::set_active_direction(::uint32_t value) {
  _internal_set_active_direction(value);
  // @@protoc_insertion_point(field_set:valhalla.TurnLane.active_direction)
}
inline ::uint32_t TurnLane::_internal_active_direction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.active_direction_;
}
inline void TurnLane::_internal_set_active_direction(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.active_direction_ = value;
}

// -------------------------------------------------------------------

// TaggedValue

// bytes value = 1;
inline void TaggedValue::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.ClearToEmpty();
}
inline const std::string& TaggedValue::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TaggedValue.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaggedValue::set_value(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.TaggedValue.value)
}
inline std::string* TaggedValue::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:valhalla.TaggedValue.value)
  return _s;
}
inline const std::string& TaggedValue::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_.Get();
}
inline void TaggedValue::_internal_set_value(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_.Set(value, GetArena());
}
inline std::string* TaggedValue::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.value_.Mutable( GetArena());
}
inline std::string* TaggedValue::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TaggedValue.value)
  return _impl_.value_.Release();
}
inline void TaggedValue::set_allocated_value(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TaggedValue.value)
}

// .valhalla.TaggedValue.Type type = 2;
inline void TaggedValue::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::valhalla::TaggedValue_Type TaggedValue::type() const {
  // @@protoc_insertion_point(field_get:valhalla.TaggedValue.type)
  return _internal_type();
}
inline void TaggedValue::set_type(::valhalla::TaggedValue_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:valhalla.TaggedValue.type)
}
inline ::valhalla::TaggedValue_Type TaggedValue::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::TaggedValue_Type>(_impl_.type_);
}
inline void TaggedValue::_internal_set_type(::valhalla::TaggedValue_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// Summary

// float length = 1;
inline void Summary::clear_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.length_ = 0;
}
inline float Summary::length() const {
  // @@protoc_insertion_point(field_get:valhalla.Summary.length)
  return _internal_length();
}
inline void Summary::set_length(float value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:valhalla.Summary.length)
}
inline float Summary::_internal_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.length_;
}
inline void Summary::_internal_set_length(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.length_ = value;
}

// double time = 2;
inline void Summary::clear_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.time_ = 0;
}
inline double Summary::time() const {
  // @@protoc_insertion_point(field_get:valhalla.Summary.time)
  return _internal_time();
}
inline void Summary::set_time(double value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:valhalla.Summary.time)
}
inline double Summary::_internal_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.time_;
}
inline void Summary::_internal_set_time(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.time_ = value;
}

// .valhalla.BoundingBox bbox = 3;
inline bool Summary::has_bbox() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bbox_ != nullptr);
  return value;
}
inline void Summary::clear_bbox() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.bbox_ != nullptr) _impl_.bbox_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::valhalla::BoundingBox& Summary::_internal_bbox() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::BoundingBox* p = _impl_.bbox_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::BoundingBox&>(::valhalla::_BoundingBox_default_instance_);
}
inline const ::valhalla::BoundingBox& Summary::bbox() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Summary.bbox)
  return _internal_bbox();
}
inline void Summary::unsafe_arena_set_allocated_bbox(::valhalla::BoundingBox* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bbox_);
  }
  _impl_.bbox_ = reinterpret_cast<::valhalla::BoundingBox*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.Summary.bbox)
}
inline ::valhalla::BoundingBox* Summary::release_bbox() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::BoundingBox* released = _impl_.bbox_;
  _impl_.bbox_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::BoundingBox* Summary::unsafe_arena_release_bbox() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.Summary.bbox)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::BoundingBox* temp = _impl_.bbox_;
  _impl_.bbox_ = nullptr;
  return temp;
}
inline ::valhalla::BoundingBox* Summary::_internal_mutable_bbox() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.bbox_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::BoundingBox>(GetArena());
    _impl_.bbox_ = reinterpret_cast<::valhalla::BoundingBox*>(p);
  }
  return _impl_.bbox_;
}
inline ::valhalla::BoundingBox* Summary::mutable_bbox() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::BoundingBox* _msg = _internal_mutable_bbox();
  // @@protoc_insertion_point(field_mutable:valhalla.Summary.bbox)
  return _msg;
}
inline void Summary::set_allocated_bbox(::valhalla::BoundingBox* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::valhalla::BoundingBox*>(_impl_.bbox_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::valhalla::BoundingBox*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.bbox_ = reinterpret_cast<::valhalla::BoundingBox*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.Summary.bbox)
}

// bool has_time_restrictions = 4;
inline void Summary::clear_has_time_restrictions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.has_time_restrictions_ = false;
}
inline bool Summary::has_time_restrictions() const {
  // @@protoc_insertion_point(field_get:valhalla.Summary.has_time_restrictions)
  return _internal_has_time_restrictions();
}
inline void Summary::set_has_time_restrictions(bool value) {
  _internal_set_has_time_restrictions(value);
  // @@protoc_insertion_point(field_set:valhalla.Summary.has_time_restrictions)
}
inline bool Summary::_internal_has_time_restrictions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.has_time_restrictions_;
}
inline void Summary::_internal_set_has_time_restrictions(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.has_time_restrictions_ = value;
}

// bool has_toll = 5;
inline void Summary::clear_has_toll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.has_toll_ = false;
}
inline bool Summary::has_toll() const {
  // @@protoc_insertion_point(field_get:valhalla.Summary.has_toll)
  return _internal_has_toll();
}
inline void Summary::set_has_toll(bool value) {
  _internal_set_has_toll(value);
  // @@protoc_insertion_point(field_set:valhalla.Summary.has_toll)
}
inline bool Summary::_internal_has_toll() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.has_toll_;
}
inline void Summary::_internal_set_has_toll(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.has_toll_ = value;
}

// bool has_ferry = 6;
inline void Summary::clear_has_ferry() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.has_ferry_ = false;
}
inline bool Summary::has_ferry() const {
  // @@protoc_insertion_point(field_get:valhalla.Summary.has_ferry)
  return _internal_has_ferry();
}
inline void Summary::set_has_ferry(bool value) {
  _internal_set_has_ferry(value);
  // @@protoc_insertion_point(field_set:valhalla.Summary.has_ferry)
}
inline bool Summary::_internal_has_ferry() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.has_ferry_;
}
inline void Summary::_internal_set_has_ferry(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.has_ferry_ = value;
}

// bool has_highway = 7;
inline void Summary::clear_has_highway() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.has_highway_ = false;
}
inline bool Summary::has_highway() const {
  // @@protoc_insertion_point(field_get:valhalla.Summary.has_highway)
  return _internal_has_highway();
}
inline void Summary::set_has_highway(bool value) {
  _internal_set_has_highway(value);
  // @@protoc_insertion_point(field_set:valhalla.Summary.has_highway)
}
inline bool Summary::_internal_has_highway() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.has_highway_;
}
inline void Summary::_internal_set_has_highway(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.has_highway_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace valhalla


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::valhalla::RouteLandmark_Type> : std::true_type {};
template <>
struct is_proto_enum<::valhalla::Location_Type> : std::true_type {};
template <>
struct is_proto_enum<::valhalla::Location_PreferredSide> : std::true_type {};
template <>
struct is_proto_enum<::valhalla::Location_SideOfStreet> : std::true_type {};
template <>
struct is_proto_enum<::valhalla::TransitPlatformInfo_Type> : std::true_type {};
template <>
struct is_proto_enum<::valhalla::Pronunciation_Alphabet> : std::true_type {};
template <>
struct is_proto_enum<::valhalla::TurnLane_State> : std::true_type {};
template <>
struct is_proto_enum<::valhalla::TaggedValue_Type> : std::true_type {};
template <>
struct is_proto_enum<::valhalla::LanguageTag> : std::true_type {};
template <>
struct is_proto_enum<::valhalla::RoadClass> : std::true_type {};
template <>
struct is_proto_enum<::valhalla::TravelMode> : std::true_type {};
template <>
struct is_proto_enum<::valhalla::VehicleType> : std::true_type {};
template <>
struct is_proto_enum<::valhalla::PedestrianType> : std::true_type {};
template <>
struct is_proto_enum<::valhalla::BicycleType> : std::true_type {};
template <>
struct is_proto_enum<::valhalla::TransitType> : std::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_common_2eproto_2epb_2eh
