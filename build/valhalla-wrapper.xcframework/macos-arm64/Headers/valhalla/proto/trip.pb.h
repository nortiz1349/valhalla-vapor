// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: trip.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_trip_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_trip_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_util.h"
#include "common.pb.h"
#include "sign.pb.h"
#include "incidents.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_trip_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_trip_2eproto {
  static const ::uint32_t offsets[];
};
namespace valhalla {
class Trip;
struct TripDefaultTypeInternal;
extern TripDefaultTypeInternal _Trip_default_instance_;
class TripLeg;
struct TripLegDefaultTypeInternal;
extern TripLegDefaultTypeInternal _TripLeg_default_instance_;
class TripLeg_Admin;
struct TripLeg_AdminDefaultTypeInternal;
extern TripLeg_AdminDefaultTypeInternal _TripLeg_Admin_default_instance_;
class TripLeg_Closure;
struct TripLeg_ClosureDefaultTypeInternal;
extern TripLeg_ClosureDefaultTypeInternal _TripLeg_Closure_default_instance_;
class TripLeg_ConditionalSpeedLimit;
struct TripLeg_ConditionalSpeedLimitDefaultTypeInternal;
extern TripLeg_ConditionalSpeedLimitDefaultTypeInternal _TripLeg_ConditionalSpeedLimit_default_instance_;
class TripLeg_Cost;
struct TripLeg_CostDefaultTypeInternal;
extern TripLeg_CostDefaultTypeInternal _TripLeg_Cost_default_instance_;
class TripLeg_Edge;
struct TripLeg_EdgeDefaultTypeInternal;
extern TripLeg_EdgeDefaultTypeInternal _TripLeg_Edge_default_instance_;
class TripLeg_Incident;
struct TripLeg_IncidentDefaultTypeInternal;
extern TripLeg_IncidentDefaultTypeInternal _TripLeg_Incident_default_instance_;
class TripLeg_IntersectingEdge;
struct TripLeg_IntersectingEdgeDefaultTypeInternal;
extern TripLeg_IntersectingEdgeDefaultTypeInternal _TripLeg_IntersectingEdge_default_instance_;
class TripLeg_LaneConnectivity;
struct TripLeg_LaneConnectivityDefaultTypeInternal;
extern TripLeg_LaneConnectivityDefaultTypeInternal _TripLeg_LaneConnectivity_default_instance_;
class TripLeg_Node;
struct TripLeg_NodeDefaultTypeInternal;
extern TripLeg_NodeDefaultTypeInternal _TripLeg_Node_default_instance_;
class TripLeg_PathCost;
struct TripLeg_PathCostDefaultTypeInternal;
extern TripLeg_PathCostDefaultTypeInternal _TripLeg_PathCost_default_instance_;
class TripLeg_Restriction;
struct TripLeg_RestrictionDefaultTypeInternal;
extern TripLeg_RestrictionDefaultTypeInternal _TripLeg_Restriction_default_instance_;
class TripLeg_ShapeAttributes;
struct TripLeg_ShapeAttributesDefaultTypeInternal;
extern TripLeg_ShapeAttributesDefaultTypeInternal _TripLeg_ShapeAttributes_default_instance_;
class TripLeg_TimeDomain;
struct TripLeg_TimeDomainDefaultTypeInternal;
extern TripLeg_TimeDomainDefaultTypeInternal _TripLeg_TimeDomain_default_instance_;
class TripLeg_TrafficSegment;
struct TripLeg_TrafficSegmentDefaultTypeInternal;
extern TripLeg_TrafficSegmentDefaultTypeInternal _TripLeg_TrafficSegment_default_instance_;
class TripRoute;
struct TripRouteDefaultTypeInternal;
extern TripRouteDefaultTypeInternal _TripRoute_default_instance_;
}  // namespace valhalla
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace valhalla {
enum TripLeg_TimeDomain_DayDowType : int {
  TripLeg_TimeDomain_DayDowType_kDayOfMonth = 0,
  TripLeg_TimeDomain_DayDowType_kNthDayOfWeek = 1,
  TripLeg_TimeDomain_DayDowType_TripLeg_TimeDomain_DayDowType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TripLeg_TimeDomain_DayDowType_TripLeg_TimeDomain_DayDowType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TripLeg_TimeDomain_DayDowType_IsValid(int value);
extern const uint32_t TripLeg_TimeDomain_DayDowType_internal_data_[];
constexpr TripLeg_TimeDomain_DayDowType TripLeg_TimeDomain_DayDowType_DayDowType_MIN = static_cast<TripLeg_TimeDomain_DayDowType>(0);
constexpr TripLeg_TimeDomain_DayDowType TripLeg_TimeDomain_DayDowType_DayDowType_MAX = static_cast<TripLeg_TimeDomain_DayDowType>(1);
constexpr int TripLeg_TimeDomain_DayDowType_DayDowType_ARRAYSIZE = 1 + 1;
const std::string& TripLeg_TimeDomain_DayDowType_Name(TripLeg_TimeDomain_DayDowType value);
template <typename T>
const std::string& TripLeg_TimeDomain_DayDowType_Name(T value) {
  static_assert(std::is_same<T, TripLeg_TimeDomain_DayDowType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DayDowType_Name().");
  return TripLeg_TimeDomain_DayDowType_Name(static_cast<TripLeg_TimeDomain_DayDowType>(value));
}
const std::string& TripLeg_TimeDomain_DayDowType_Name(TripLeg_TimeDomain_DayDowType value);
bool TripLeg_TimeDomain_DayDowType_Parse(absl::string_view name, TripLeg_TimeDomain_DayDowType* value);
enum TripLeg_Node_Type : int {
  TripLeg_Node_Type_kStreetIntersection = 0,
  TripLeg_Node_Type_kGate = 1,
  TripLeg_Node_Type_kBollard = 2,
  TripLeg_Node_Type_kTollBooth = 3,
  TripLeg_Node_Type_kTransitEgress = 4,
  TripLeg_Node_Type_kTransitStation = 5,
  TripLeg_Node_Type_kTransitPlatform = 6,
  TripLeg_Node_Type_kBikeShare = 7,
  TripLeg_Node_Type_kParking = 8,
  TripLeg_Node_Type_kMotorwayJunction = 9,
  TripLeg_Node_Type_kBorderControl = 10,
  TripLeg_Node_Type_kTollGantry = 11,
  TripLeg_Node_Type_kSumpBuster = 12,
  TripLeg_Node_Type_kBuildingEntrance = 13,
  TripLeg_Node_Type_kElevator = 14,
  TripLeg_Node_Type_TripLeg_Node_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TripLeg_Node_Type_TripLeg_Node_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TripLeg_Node_Type_IsValid(int value);
extern const uint32_t TripLeg_Node_Type_internal_data_[];
constexpr TripLeg_Node_Type TripLeg_Node_Type_Type_MIN = static_cast<TripLeg_Node_Type>(0);
constexpr TripLeg_Node_Type TripLeg_Node_Type_Type_MAX = static_cast<TripLeg_Node_Type>(14);
constexpr int TripLeg_Node_Type_Type_ARRAYSIZE = 14 + 1;
const std::string& TripLeg_Node_Type_Name(TripLeg_Node_Type value);
template <typename T>
const std::string& TripLeg_Node_Type_Name(T value) {
  static_assert(std::is_same<T, TripLeg_Node_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return TripLeg_Node_Type_Name(static_cast<TripLeg_Node_Type>(value));
}
const std::string& TripLeg_Node_Type_Name(TripLeg_Node_Type value);
bool TripLeg_Node_Type_Parse(absl::string_view name, TripLeg_Node_Type* value);
enum TripLeg_Traversability : int {
  TripLeg_Traversability_kNone = 0,
  TripLeg_Traversability_kForward = 1,
  TripLeg_Traversability_kBackward = 2,
  TripLeg_Traversability_kBoth = 3,
  TripLeg_Traversability_TripLeg_Traversability_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TripLeg_Traversability_TripLeg_Traversability_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TripLeg_Traversability_IsValid(int value);
extern const uint32_t TripLeg_Traversability_internal_data_[];
constexpr TripLeg_Traversability TripLeg_Traversability_Traversability_MIN = static_cast<TripLeg_Traversability>(0);
constexpr TripLeg_Traversability TripLeg_Traversability_Traversability_MAX = static_cast<TripLeg_Traversability>(3);
constexpr int TripLeg_Traversability_Traversability_ARRAYSIZE = 3 + 1;
const std::string& TripLeg_Traversability_Name(TripLeg_Traversability value);
template <typename T>
const std::string& TripLeg_Traversability_Name(T value) {
  static_assert(std::is_same<T, TripLeg_Traversability>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Traversability_Name().");
  return TripLeg_Traversability_Name(static_cast<TripLeg_Traversability>(value));
}
const std::string& TripLeg_Traversability_Name(TripLeg_Traversability value);
bool TripLeg_Traversability_Parse(absl::string_view name, TripLeg_Traversability* value);
enum TripLeg_Use : int {
  TripLeg_Use_kRoadUse = 0,
  TripLeg_Use_kRampUse = 1,
  TripLeg_Use_kTurnChannelUse = 2,
  TripLeg_Use_kTrackUse = 3,
  TripLeg_Use_kDrivewayUse = 4,
  TripLeg_Use_kAlleyUse = 5,
  TripLeg_Use_kParkingAisleUse = 6,
  TripLeg_Use_kEmergencyAccessUse = 7,
  TripLeg_Use_kDriveThruUse = 8,
  TripLeg_Use_kCuldesacUse = 9,
  TripLeg_Use_kLivingStreetUse = 10,
  TripLeg_Use_kServiceRoadUse = 11,
  TripLeg_Use_kCyclewayUse = 20,
  TripLeg_Use_kMountainBikeUse = 21,
  TripLeg_Use_kSidewalkUse = 24,
  TripLeg_Use_kFootwayUse = 25,
  TripLeg_Use_kStepsUse = 26,
  TripLeg_Use_kPathUse = 27,
  TripLeg_Use_kPedestrianUse = 28,
  TripLeg_Use_kBridlewayUse = 29,
  TripLeg_Use_kPedestrianCrossingUse = 32,
  TripLeg_Use_kElevatorUse = 33,
  TripLeg_Use_kEscalatorUse = 34,
  TripLeg_Use_kRestAreaUse = 30,
  TripLeg_Use_kServiceAreaUse = 31,
  TripLeg_Use_kOtherUse = 40,
  TripLeg_Use_kFerryUse = 41,
  TripLeg_Use_kRailFerryUse = 42,
  TripLeg_Use_kConstructionUse = 43,
  TripLeg_Use_kRailUse = 50,
  TripLeg_Use_kBusUse = 51,
  TripLeg_Use_kEgressConnectionUse = 52,
  TripLeg_Use_kPlatformConnectionUse = 53,
  TripLeg_Use_kTransitConnectionUse = 54,
  TripLeg_Use_TripLeg_Use_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TripLeg_Use_TripLeg_Use_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TripLeg_Use_IsValid(int value);
extern const uint32_t TripLeg_Use_internal_data_[];
constexpr TripLeg_Use TripLeg_Use_Use_MIN = static_cast<TripLeg_Use>(0);
constexpr TripLeg_Use TripLeg_Use_Use_MAX = static_cast<TripLeg_Use>(54);
constexpr int TripLeg_Use_Use_ARRAYSIZE = 54 + 1;
const std::string& TripLeg_Use_Name(TripLeg_Use value);
template <typename T>
const std::string& TripLeg_Use_Name(T value) {
  static_assert(std::is_same<T, TripLeg_Use>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Use_Name().");
  return TripLeg_Use_Name(static_cast<TripLeg_Use>(value));
}
const std::string& TripLeg_Use_Name(TripLeg_Use value);
bool TripLeg_Use_Parse(absl::string_view name, TripLeg_Use* value);
enum TripLeg_Surface : int {
  TripLeg_Surface_kPavedSmooth = 0,
  TripLeg_Surface_kPaved = 1,
  TripLeg_Surface_kPavedRough = 2,
  TripLeg_Surface_kCompacted = 3,
  TripLeg_Surface_kDirt = 4,
  TripLeg_Surface_kGravel = 5,
  TripLeg_Surface_kPath = 6,
  TripLeg_Surface_kImpassable = 7,
  TripLeg_Surface_TripLeg_Surface_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TripLeg_Surface_TripLeg_Surface_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TripLeg_Surface_IsValid(int value);
extern const uint32_t TripLeg_Surface_internal_data_[];
constexpr TripLeg_Surface TripLeg_Surface_Surface_MIN = static_cast<TripLeg_Surface>(0);
constexpr TripLeg_Surface TripLeg_Surface_Surface_MAX = static_cast<TripLeg_Surface>(7);
constexpr int TripLeg_Surface_Surface_ARRAYSIZE = 7 + 1;
const std::string& TripLeg_Surface_Name(TripLeg_Surface value);
template <typename T>
const std::string& TripLeg_Surface_Name(T value) {
  static_assert(std::is_same<T, TripLeg_Surface>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Surface_Name().");
  return TripLeg_Surface_Name(static_cast<TripLeg_Surface>(value));
}
const std::string& TripLeg_Surface_Name(TripLeg_Surface value);
bool TripLeg_Surface_Parse(absl::string_view name, TripLeg_Surface* value);
enum TripLeg_CycleLane : int {
  TripLeg_CycleLane_kNoCycleLane = 0,
  TripLeg_CycleLane_kShared = 1,
  TripLeg_CycleLane_kDedicated = 2,
  TripLeg_CycleLane_kSeparated = 3,
  TripLeg_CycleLane_TripLeg_CycleLane_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TripLeg_CycleLane_TripLeg_CycleLane_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TripLeg_CycleLane_IsValid(int value);
extern const uint32_t TripLeg_CycleLane_internal_data_[];
constexpr TripLeg_CycleLane TripLeg_CycleLane_CycleLane_MIN = static_cast<TripLeg_CycleLane>(0);
constexpr TripLeg_CycleLane TripLeg_CycleLane_CycleLane_MAX = static_cast<TripLeg_CycleLane>(3);
constexpr int TripLeg_CycleLane_CycleLane_ARRAYSIZE = 3 + 1;
const std::string& TripLeg_CycleLane_Name(TripLeg_CycleLane value);
template <typename T>
const std::string& TripLeg_CycleLane_Name(T value) {
  static_assert(std::is_same<T, TripLeg_CycleLane>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CycleLane_Name().");
  return TripLeg_CycleLane_Name(static_cast<TripLeg_CycleLane>(value));
}
const std::string& TripLeg_CycleLane_Name(TripLeg_CycleLane value);
bool TripLeg_CycleLane_Parse(absl::string_view name, TripLeg_CycleLane* value);
enum TripLeg_SacScale : int {
  TripLeg_SacScale_kNoSacScale = 0,
  TripLeg_SacScale_kHiking = 1,
  TripLeg_SacScale_kMountainHiking = 2,
  TripLeg_SacScale_kDemandingMountainHiking = 3,
  TripLeg_SacScale_kAlpineHiking = 4,
  TripLeg_SacScale_kDemandingAlpineHiking = 5,
  TripLeg_SacScale_kDifficultAlpineHiking = 6,
  TripLeg_SacScale_TripLeg_SacScale_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TripLeg_SacScale_TripLeg_SacScale_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TripLeg_SacScale_IsValid(int value);
extern const uint32_t TripLeg_SacScale_internal_data_[];
constexpr TripLeg_SacScale TripLeg_SacScale_SacScale_MIN = static_cast<TripLeg_SacScale>(0);
constexpr TripLeg_SacScale TripLeg_SacScale_SacScale_MAX = static_cast<TripLeg_SacScale>(6);
constexpr int TripLeg_SacScale_SacScale_ARRAYSIZE = 6 + 1;
const std::string& TripLeg_SacScale_Name(TripLeg_SacScale value);
template <typename T>
const std::string& TripLeg_SacScale_Name(T value) {
  static_assert(std::is_same<T, TripLeg_SacScale>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SacScale_Name().");
  return TripLeg_SacScale_Name(static_cast<TripLeg_SacScale>(value));
}
const std::string& TripLeg_SacScale_Name(TripLeg_SacScale value);
bool TripLeg_SacScale_Parse(absl::string_view name, TripLeg_SacScale* value);
enum TripLeg_Sidewalk : int {
  TripLeg_Sidewalk_kNoSidewalk = 0,
  TripLeg_Sidewalk_kLeft = 1,
  TripLeg_Sidewalk_kRight = 2,
  TripLeg_Sidewalk_kBothSides = 3,
  TripLeg_Sidewalk_TripLeg_Sidewalk_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TripLeg_Sidewalk_TripLeg_Sidewalk_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TripLeg_Sidewalk_IsValid(int value);
extern const uint32_t TripLeg_Sidewalk_internal_data_[];
constexpr TripLeg_Sidewalk TripLeg_Sidewalk_Sidewalk_MIN = static_cast<TripLeg_Sidewalk>(0);
constexpr TripLeg_Sidewalk TripLeg_Sidewalk_Sidewalk_MAX = static_cast<TripLeg_Sidewalk>(3);
constexpr int TripLeg_Sidewalk_Sidewalk_ARRAYSIZE = 3 + 1;
const std::string& TripLeg_Sidewalk_Name(TripLeg_Sidewalk value);
template <typename T>
const std::string& TripLeg_Sidewalk_Name(T value) {
  static_assert(std::is_same<T, TripLeg_Sidewalk>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Sidewalk_Name().");
  return TripLeg_Sidewalk_Name(static_cast<TripLeg_Sidewalk>(value));
}
const std::string& TripLeg_Sidewalk_Name(TripLeg_Sidewalk value);
bool TripLeg_Sidewalk_Parse(absl::string_view name, TripLeg_Sidewalk* value);

// ===================================================================


// -------------------------------------------------------------------

class TripLeg_TrafficSegment final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.TrafficSegment) */ {
 public:
  inline TripLeg_TrafficSegment() : TripLeg_TrafficSegment(nullptr) {}
  ~TripLeg_TrafficSegment() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TripLeg_TrafficSegment(::google::protobuf::internal::ConstantInitialized);

  inline TripLeg_TrafficSegment(const TripLeg_TrafficSegment& from)
      : TripLeg_TrafficSegment(nullptr, from) {}
  TripLeg_TrafficSegment(TripLeg_TrafficSegment&& from) noexcept
    : TripLeg_TrafficSegment() {
    *this = ::std::move(from);
  }

  inline TripLeg_TrafficSegment& operator=(const TripLeg_TrafficSegment& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_TrafficSegment& operator=(TripLeg_TrafficSegment&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TripLeg_TrafficSegment& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripLeg_TrafficSegment* internal_default_instance() {
    return reinterpret_cast<const TripLeg_TrafficSegment*>(
               &_TripLeg_TrafficSegment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TripLeg_TrafficSegment& a, TripLeg_TrafficSegment& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_TrafficSegment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_TrafficSegment* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_TrafficSegment* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_TrafficSegment>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const TripLeg_TrafficSegment& from);
  void MergeFrom(const TripLeg_TrafficSegment& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TripLeg_TrafficSegment* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.TripLeg.TrafficSegment";
  }
  protected:
  explicit TripLeg_TrafficSegment(::google::protobuf::Arena* arena);
  TripLeg_TrafficSegment(::google::protobuf::Arena* arena, const TripLeg_TrafficSegment& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSegmentIdFieldNumber = 1,
    kBeginPercentFieldNumber = 2,
    kEndPercentFieldNumber = 3,
    kStartsSegmentFieldNumber = 4,
    kEndsSegmentFieldNumber = 5,
  };
  // uint64 segment_id = 1;
  void clear_segment_id() ;
  ::uint64_t segment_id() const;
  void set_segment_id(::uint64_t value);

  private:
  ::uint64_t _internal_segment_id() const;
  void _internal_set_segment_id(::uint64_t value);

  public:
  // float begin_percent = 2;
  void clear_begin_percent() ;
  float begin_percent() const;
  void set_begin_percent(float value);

  private:
  float _internal_begin_percent() const;
  void _internal_set_begin_percent(float value);

  public:
  // float end_percent = 3;
  void clear_end_percent() ;
  float end_percent() const;
  void set_end_percent(float value);

  private:
  float _internal_end_percent() const;
  void _internal_set_end_percent(float value);

  public:
  // bool starts_segment = 4;
  void clear_starts_segment() ;
  bool starts_segment() const;
  void set_starts_segment(bool value);

  private:
  bool _internal_starts_segment() const;
  void _internal_set_starts_segment(bool value);

  public:
  // bool ends_segment = 5;
  void clear_ends_segment() ;
  bool ends_segment() const;
  void set_ends_segment(bool value);

  private:
  bool _internal_ends_segment() const;
  void _internal_set_ends_segment(bool value);

  public:
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.TrafficSegment)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint64_t segment_id_;
    float begin_percent_;
    float end_percent_;
    bool starts_segment_;
    bool ends_segment_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};// -------------------------------------------------------------------

class TripLeg_TimeDomain final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.TimeDomain) */ {
 public:
  inline TripLeg_TimeDomain() : TripLeg_TimeDomain(nullptr) {}
  ~TripLeg_TimeDomain() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TripLeg_TimeDomain(::google::protobuf::internal::ConstantInitialized);

  inline TripLeg_TimeDomain(const TripLeg_TimeDomain& from)
      : TripLeg_TimeDomain(nullptr, from) {}
  TripLeg_TimeDomain(TripLeg_TimeDomain&& from) noexcept
    : TripLeg_TimeDomain() {
    *this = ::std::move(from);
  }

  inline TripLeg_TimeDomain& operator=(const TripLeg_TimeDomain& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_TimeDomain& operator=(TripLeg_TimeDomain&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TripLeg_TimeDomain& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripLeg_TimeDomain* internal_default_instance() {
    return reinterpret_cast<const TripLeg_TimeDomain*>(
               &_TripLeg_TimeDomain_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TripLeg_TimeDomain& a, TripLeg_TimeDomain& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_TimeDomain* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_TimeDomain* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_TimeDomain* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_TimeDomain>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const TripLeg_TimeDomain& from);
  void MergeFrom(const TripLeg_TimeDomain& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TripLeg_TimeDomain* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.TripLeg.TimeDomain";
  }
  protected:
  explicit TripLeg_TimeDomain(::google::protobuf::Arena* arena);
  TripLeg_TimeDomain(::google::protobuf::Arena* arena, const TripLeg_TimeDomain& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using DayDowType = TripLeg_TimeDomain_DayDowType;
  static constexpr DayDowType kDayOfMonth = TripLeg_TimeDomain_DayDowType_kDayOfMonth;
  static constexpr DayDowType kNthDayOfWeek = TripLeg_TimeDomain_DayDowType_kNthDayOfWeek;
  static inline bool DayDowType_IsValid(int value) {
    return TripLeg_TimeDomain_DayDowType_IsValid(value);
  }
  static constexpr DayDowType DayDowType_MIN = TripLeg_TimeDomain_DayDowType_DayDowType_MIN;
  static constexpr DayDowType DayDowType_MAX = TripLeg_TimeDomain_DayDowType_DayDowType_MAX;
  static constexpr int DayDowType_ARRAYSIZE = TripLeg_TimeDomain_DayDowType_DayDowType_ARRAYSIZE;
  template <typename T>
  static inline const std::string& DayDowType_Name(T value) {
    return TripLeg_TimeDomain_DayDowType_Name(value);
  }
  static inline bool DayDowType_Parse(absl::string_view name, DayDowType* value) {
    return TripLeg_TimeDomain_DayDowType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDayDowTypeFieldNumber = 1,
    kDowMaskFieldNumber = 2,
    kBeginHrsFieldNumber = 3,
    kBeginMinsFieldNumber = 4,
    kBeginMonthFieldNumber = 5,
    kBeginDayDowFieldNumber = 6,
    kBeginWeekFieldNumber = 7,
    kEndHrsFieldNumber = 8,
    kEndMinsFieldNumber = 9,
    kEndMonthFieldNumber = 10,
    kEndDayDowFieldNumber = 11,
    kEndWeekFieldNumber = 12,
  };
  // .valhalla.TripLeg.TimeDomain.DayDowType day_dow_type = 1;
  void clear_day_dow_type() ;
  ::valhalla::TripLeg_TimeDomain_DayDowType day_dow_type() const;
  void set_day_dow_type(::valhalla::TripLeg_TimeDomain_DayDowType value);

  private:
  ::valhalla::TripLeg_TimeDomain_DayDowType _internal_day_dow_type() const;
  void _internal_set_day_dow_type(::valhalla::TripLeg_TimeDomain_DayDowType value);

  public:
  // uint32 dow_mask = 2;
  void clear_dow_mask() ;
  ::uint32_t dow_mask() const;
  void set_dow_mask(::uint32_t value);

  private:
  ::uint32_t _internal_dow_mask() const;
  void _internal_set_dow_mask(::uint32_t value);

  public:
  // uint32 begin_hrs = 3;
  void clear_begin_hrs() ;
  ::uint32_t begin_hrs() const;
  void set_begin_hrs(::uint32_t value);

  private:
  ::uint32_t _internal_begin_hrs() const;
  void _internal_set_begin_hrs(::uint32_t value);

  public:
  // uint32 begin_mins = 4;
  void clear_begin_mins() ;
  ::uint32_t begin_mins() const;
  void set_begin_mins(::uint32_t value);

  private:
  ::uint32_t _internal_begin_mins() const;
  void _internal_set_begin_mins(::uint32_t value);

  public:
  // uint32 begin_month = 5;
  void clear_begin_month() ;
  ::uint32_t begin_month() const;
  void set_begin_month(::uint32_t value);

  private:
  ::uint32_t _internal_begin_month() const;
  void _internal_set_begin_month(::uint32_t value);

  public:
  // uint32 begin_day_dow = 6;
  void clear_begin_day_dow() ;
  ::uint32_t begin_day_dow() const;
  void set_begin_day_dow(::uint32_t value);

  private:
  ::uint32_t _internal_begin_day_dow() const;
  void _internal_set_begin_day_dow(::uint32_t value);

  public:
  // uint32 begin_week = 7;
  void clear_begin_week() ;
  ::uint32_t begin_week() const;
  void set_begin_week(::uint32_t value);

  private:
  ::uint32_t _internal_begin_week() const;
  void _internal_set_begin_week(::uint32_t value);

  public:
  // uint32 end_hrs = 8;
  void clear_end_hrs() ;
  ::uint32_t end_hrs() const;
  void set_end_hrs(::uint32_t value);

  private:
  ::uint32_t _internal_end_hrs() const;
  void _internal_set_end_hrs(::uint32_t value);

  public:
  // uint32 end_mins = 9;
  void clear_end_mins() ;
  ::uint32_t end_mins() const;
  void set_end_mins(::uint32_t value);

  private:
  ::uint32_t _internal_end_mins() const;
  void _internal_set_end_mins(::uint32_t value);

  public:
  // uint32 end_month = 10;
  void clear_end_month() ;
  ::uint32_t end_month() const;
  void set_end_month(::uint32_t value);

  private:
  ::uint32_t _internal_end_month() const;
  void _internal_set_end_month(::uint32_t value);

  public:
  // uint32 end_day_dow = 11;
  void clear_end_day_dow() ;
  ::uint32_t end_day_dow() const;
  void set_end_day_dow(::uint32_t value);

  private:
  ::uint32_t _internal_end_day_dow() const;
  void _internal_set_end_day_dow(::uint32_t value);

  public:
  // uint32 end_week = 12;
  void clear_end_week() ;
  ::uint32_t end_week() const;
  void set_end_week(::uint32_t value);

  private:
  ::uint32_t _internal_end_week() const;
  void _internal_set_end_week(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.TimeDomain)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    int day_dow_type_;
    ::uint32_t dow_mask_;
    ::uint32_t begin_hrs_;
    ::uint32_t begin_mins_;
    ::uint32_t begin_month_;
    ::uint32_t begin_day_dow_;
    ::uint32_t begin_week_;
    ::uint32_t end_hrs_;
    ::uint32_t end_mins_;
    ::uint32_t end_month_;
    ::uint32_t end_day_dow_;
    ::uint32_t end_week_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};// -------------------------------------------------------------------

class TripLeg_ShapeAttributes final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.ShapeAttributes) */ {
 public:
  inline TripLeg_ShapeAttributes() : TripLeg_ShapeAttributes(nullptr) {}
  ~TripLeg_ShapeAttributes() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TripLeg_ShapeAttributes(::google::protobuf::internal::ConstantInitialized);

  inline TripLeg_ShapeAttributes(const TripLeg_ShapeAttributes& from)
      : TripLeg_ShapeAttributes(nullptr, from) {}
  TripLeg_ShapeAttributes(TripLeg_ShapeAttributes&& from) noexcept
    : TripLeg_ShapeAttributes() {
    *this = ::std::move(from);
  }

  inline TripLeg_ShapeAttributes& operator=(const TripLeg_ShapeAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_ShapeAttributes& operator=(TripLeg_ShapeAttributes&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TripLeg_ShapeAttributes& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripLeg_ShapeAttributes* internal_default_instance() {
    return reinterpret_cast<const TripLeg_ShapeAttributes*>(
               &_TripLeg_ShapeAttributes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TripLeg_ShapeAttributes& a, TripLeg_ShapeAttributes& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_ShapeAttributes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_ShapeAttributes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_ShapeAttributes* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_ShapeAttributes>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const TripLeg_ShapeAttributes& from);
  void MergeFrom(const TripLeg_ShapeAttributes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TripLeg_ShapeAttributes* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.TripLeg.ShapeAttributes";
  }
  protected:
  explicit TripLeg_ShapeAttributes(::google::protobuf::Arena* arena);
  TripLeg_ShapeAttributes(::google::protobuf::Arena* arena, const TripLeg_ShapeAttributes& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeFieldNumber = 1,
    kLengthFieldNumber = 2,
    kSpeedFieldNumber = 3,
    kSpeedLimitFieldNumber = 5,
  };
  // repeated uint32 time = 1 [packed = true];
  int time_size() const;
  private:
  int _internal_time_size() const;

  public:
  void clear_time() ;
  ::uint32_t time(int index) const;
  void set_time(int index, ::uint32_t value);
  void add_time(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& time() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_time();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_time() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_time();

  public:
  // repeated uint32 length = 2 [packed = true];
  int length_size() const;
  private:
  int _internal_length_size() const;

  public:
  void clear_length() ;
  ::uint32_t length(int index) const;
  void set_length(int index, ::uint32_t value);
  void add_length(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& length() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_length();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_length() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_length();

  public:
  // repeated uint32 speed = 3 [packed = true];
  int speed_size() const;
  private:
  int _internal_speed_size() const;

  public:
  void clear_speed() ;
  ::uint32_t speed(int index) const;
  void set_speed(int index, ::uint32_t value);
  void add_speed(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& speed() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_speed();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_speed() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_speed();

  public:
  // repeated uint32 speed_limit = 5 [packed = true];
  int speed_limit_size() const;
  private:
  int _internal_speed_limit_size() const;

  public:
  void clear_speed_limit() ;
  ::uint32_t speed_limit(int index) const;
  void set_speed_limit(int index, ::uint32_t value);
  void add_speed_limit(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& speed_limit() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_speed_limit();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_speed_limit() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_speed_limit();

  public:
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.ShapeAttributes)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<::uint32_t> time_;
    mutable ::google::protobuf::internal::CachedSize _time_cached_byte_size_;
    ::google::protobuf::RepeatedField<::uint32_t> length_;
    mutable ::google::protobuf::internal::CachedSize _length_cached_byte_size_;
    ::google::protobuf::RepeatedField<::uint32_t> speed_;
    mutable ::google::protobuf::internal::CachedSize _speed_cached_byte_size_;
    ::google::protobuf::RepeatedField<::uint32_t> speed_limit_;
    mutable ::google::protobuf::internal::CachedSize _speed_limit_cached_byte_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};// -------------------------------------------------------------------

class TripLeg_Restriction final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.Restriction) */ {
 public:
  inline TripLeg_Restriction() : TripLeg_Restriction(nullptr) {}
  ~TripLeg_Restriction() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TripLeg_Restriction(::google::protobuf::internal::ConstantInitialized);

  inline TripLeg_Restriction(const TripLeg_Restriction& from)
      : TripLeg_Restriction(nullptr, from) {}
  TripLeg_Restriction(TripLeg_Restriction&& from) noexcept
    : TripLeg_Restriction() {
    *this = ::std::move(from);
  }

  inline TripLeg_Restriction& operator=(const TripLeg_Restriction& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_Restriction& operator=(TripLeg_Restriction&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TripLeg_Restriction& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripLeg_Restriction* internal_default_instance() {
    return reinterpret_cast<const TripLeg_Restriction*>(
               &_TripLeg_Restriction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TripLeg_Restriction& a, TripLeg_Restriction& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_Restriction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_Restriction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_Restriction* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_Restriction>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const TripLeg_Restriction& from);
  void MergeFrom(const TripLeg_Restriction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TripLeg_Restriction* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.TripLeg.Restriction";
  }
  protected:
  explicit TripLeg_Restriction(::google::protobuf::Arena* arena);
  TripLeg_Restriction(::google::protobuf::Arena* arena, const TripLeg_Restriction& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // uint32 type = 1;
  void clear_type() ;
  ::uint32_t type() const;
  void set_type(::uint32_t value);

  private:
  ::uint32_t _internal_type() const;
  void _internal_set_type(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.Restriction)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint32_t type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};// -------------------------------------------------------------------

class TripLeg_LaneConnectivity final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.LaneConnectivity) */ {
 public:
  inline TripLeg_LaneConnectivity() : TripLeg_LaneConnectivity(nullptr) {}
  ~TripLeg_LaneConnectivity() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TripLeg_LaneConnectivity(::google::protobuf::internal::ConstantInitialized);

  inline TripLeg_LaneConnectivity(const TripLeg_LaneConnectivity& from)
      : TripLeg_LaneConnectivity(nullptr, from) {}
  TripLeg_LaneConnectivity(TripLeg_LaneConnectivity&& from) noexcept
    : TripLeg_LaneConnectivity() {
    *this = ::std::move(from);
  }

  inline TripLeg_LaneConnectivity& operator=(const TripLeg_LaneConnectivity& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_LaneConnectivity& operator=(TripLeg_LaneConnectivity&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TripLeg_LaneConnectivity& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripLeg_LaneConnectivity* internal_default_instance() {
    return reinterpret_cast<const TripLeg_LaneConnectivity*>(
               &_TripLeg_LaneConnectivity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TripLeg_LaneConnectivity& a, TripLeg_LaneConnectivity& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_LaneConnectivity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_LaneConnectivity* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_LaneConnectivity* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_LaneConnectivity>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const TripLeg_LaneConnectivity& from);
  void MergeFrom(const TripLeg_LaneConnectivity& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TripLeg_LaneConnectivity* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.TripLeg.LaneConnectivity";
  }
  protected:
  explicit TripLeg_LaneConnectivity(::google::protobuf::Arena* arena);
  TripLeg_LaneConnectivity(::google::protobuf::Arena* arena, const TripLeg_LaneConnectivity& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromLanesFieldNumber = 2,
    kToLanesFieldNumber = 3,
    kFromWayIdFieldNumber = 1,
  };
  // string from_lanes = 2;
  void clear_from_lanes() ;
  const std::string& from_lanes() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_from_lanes(Arg_&& arg, Args_... args);
  std::string* mutable_from_lanes();
  PROTOBUF_NODISCARD std::string* release_from_lanes();
  void set_allocated_from_lanes(std::string* value);

  private:
  const std::string& _internal_from_lanes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from_lanes(
      const std::string& value);
  std::string* _internal_mutable_from_lanes();

  public:
  // string to_lanes = 3;
  void clear_to_lanes() ;
  const std::string& to_lanes() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_to_lanes(Arg_&& arg, Args_... args);
  std::string* mutable_to_lanes();
  PROTOBUF_NODISCARD std::string* release_to_lanes();
  void set_allocated_to_lanes(std::string* value);

  private:
  const std::string& _internal_to_lanes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_lanes(
      const std::string& value);
  std::string* _internal_mutable_to_lanes();

  public:
  // uint64 from_way_id = 1;
  void clear_from_way_id() ;
  ::uint64_t from_way_id() const;
  void set_from_way_id(::uint64_t value);

  private:
  ::uint64_t _internal_from_way_id() const;
  void _internal_set_from_way_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.LaneConnectivity)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      60, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr from_lanes_;
    ::google::protobuf::internal::ArenaStringPtr to_lanes_;
    ::uint64_t from_way_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};// -------------------------------------------------------------------

class TripLeg_Cost final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.Cost) */ {
 public:
  inline TripLeg_Cost() : TripLeg_Cost(nullptr) {}
  ~TripLeg_Cost() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TripLeg_Cost(::google::protobuf::internal::ConstantInitialized);

  inline TripLeg_Cost(const TripLeg_Cost& from)
      : TripLeg_Cost(nullptr, from) {}
  TripLeg_Cost(TripLeg_Cost&& from) noexcept
    : TripLeg_Cost() {
    *this = ::std::move(from);
  }

  inline TripLeg_Cost& operator=(const TripLeg_Cost& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_Cost& operator=(TripLeg_Cost&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TripLeg_Cost& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripLeg_Cost* internal_default_instance() {
    return reinterpret_cast<const TripLeg_Cost*>(
               &_TripLeg_Cost_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TripLeg_Cost& a, TripLeg_Cost& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_Cost* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_Cost* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_Cost* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_Cost>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const TripLeg_Cost& from);
  void MergeFrom(const TripLeg_Cost& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TripLeg_Cost* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.TripLeg.Cost";
  }
  protected:
  explicit TripLeg_Cost(::google::protobuf::Arena* arena);
  TripLeg_Cost(::google::protobuf::Arena* arena, const TripLeg_Cost& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecondsFieldNumber = 1,
    kCostFieldNumber = 2,
  };
  // double seconds = 1;
  void clear_seconds() ;
  double seconds() const;
  void set_seconds(double value);

  private:
  double _internal_seconds() const;
  void _internal_set_seconds(double value);

  public:
  // double cost = 2;
  void clear_cost() ;
  double cost() const;
  void set_cost(double value);

  private:
  double _internal_cost() const;
  void _internal_set_cost(double value);

  public:
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.Cost)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    double seconds_;
    double cost_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};// -------------------------------------------------------------------

class TripLeg_Closure final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.Closure) */ {
 public:
  inline TripLeg_Closure() : TripLeg_Closure(nullptr) {}
  ~TripLeg_Closure() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TripLeg_Closure(::google::protobuf::internal::ConstantInitialized);

  inline TripLeg_Closure(const TripLeg_Closure& from)
      : TripLeg_Closure(nullptr, from) {}
  TripLeg_Closure(TripLeg_Closure&& from) noexcept
    : TripLeg_Closure() {
    *this = ::std::move(from);
  }

  inline TripLeg_Closure& operator=(const TripLeg_Closure& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_Closure& operator=(TripLeg_Closure&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TripLeg_Closure& default_instance() {
    return *internal_default_instance();
  }
  enum HasBeginShapeIndexCase {
    kBeginShapeIndex = 1,
    HAS_BEGIN_SHAPE_INDEX_NOT_SET = 0,
  };

  enum HasEndShapeIndexCase {
    kEndShapeIndex = 2,
    HAS_END_SHAPE_INDEX_NOT_SET = 0,
  };

  static inline const TripLeg_Closure* internal_default_instance() {
    return reinterpret_cast<const TripLeg_Closure*>(
               &_TripLeg_Closure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TripLeg_Closure& a, TripLeg_Closure& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_Closure* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_Closure* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_Closure* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_Closure>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const TripLeg_Closure& from);
  void MergeFrom(const TripLeg_Closure& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TripLeg_Closure* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.TripLeg.Closure";
  }
  protected:
  explicit TripLeg_Closure(::google::protobuf::Arena* arena);
  TripLeg_Closure(::google::protobuf::Arena* arena, const TripLeg_Closure& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBeginShapeIndexFieldNumber = 1,
    kEndShapeIndexFieldNumber = 2,
  };
  // uint32 begin_shape_index = 1;
  bool has_begin_shape_index() const;
  void clear_begin_shape_index() ;
  ::uint32_t begin_shape_index() const;
  void set_begin_shape_index(::uint32_t value);

  private:
  ::uint32_t _internal_begin_shape_index() const;
  void _internal_set_begin_shape_index(::uint32_t value);

  public:
  // uint32 end_shape_index = 2;
  bool has_end_shape_index() const;
  void clear_end_shape_index() ;
  ::uint32_t end_shape_index() const;
  void set_end_shape_index(::uint32_t value);

  private:
  ::uint32_t _internal_end_shape_index() const;
  void _internal_set_end_shape_index(::uint32_t value);

  public:
  void clear_has_begin_shape_index();
  HasBeginShapeIndexCase has_begin_shape_index_case() const;
  void clear_has_end_shape_index();
  HasEndShapeIndexCase has_end_shape_index_case() const;
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.Closure)
 private:
  class _Internal;
  void set_has_begin_shape_index();
  void set_has_end_shape_index();

  inline bool has_has_begin_shape_index() const;
  inline void clear_has_has_begin_shape_index();

  inline bool has_has_end_shape_index() const;
  inline void clear_has_has_end_shape_index();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union HasBeginShapeIndexUnion {
      constexpr HasBeginShapeIndexUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint32_t begin_shape_index_;
    } has_begin_shape_index_;
    union HasEndShapeIndexUnion {
      constexpr HasEndShapeIndexUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint32_t end_shape_index_;
    } has_end_shape_index_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[2];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};// -------------------------------------------------------------------

class TripLeg_Admin final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.Admin) */ {
 public:
  inline TripLeg_Admin() : TripLeg_Admin(nullptr) {}
  ~TripLeg_Admin() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TripLeg_Admin(::google::protobuf::internal::ConstantInitialized);

  inline TripLeg_Admin(const TripLeg_Admin& from)
      : TripLeg_Admin(nullptr, from) {}
  TripLeg_Admin(TripLeg_Admin&& from) noexcept
    : TripLeg_Admin() {
    *this = ::std::move(from);
  }

  inline TripLeg_Admin& operator=(const TripLeg_Admin& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_Admin& operator=(TripLeg_Admin&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TripLeg_Admin& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripLeg_Admin* internal_default_instance() {
    return reinterpret_cast<const TripLeg_Admin*>(
               &_TripLeg_Admin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TripLeg_Admin& a, TripLeg_Admin& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_Admin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_Admin* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_Admin* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_Admin>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const TripLeg_Admin& from);
  void MergeFrom(const TripLeg_Admin& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TripLeg_Admin* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.TripLeg.Admin";
  }
  protected:
  explicit TripLeg_Admin(::google::protobuf::Arena* arena);
  TripLeg_Admin(::google::protobuf::Arena* arena, const TripLeg_Admin& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountryCodeFieldNumber = 1,
    kCountryTextFieldNumber = 2,
    kStateCodeFieldNumber = 3,
    kStateTextFieldNumber = 4,
  };
  // string country_code = 1;
  void clear_country_code() ;
  const std::string& country_code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_country_code(Arg_&& arg, Args_... args);
  std::string* mutable_country_code();
  PROTOBUF_NODISCARD std::string* release_country_code();
  void set_allocated_country_code(std::string* value);

  private:
  const std::string& _internal_country_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country_code(
      const std::string& value);
  std::string* _internal_mutable_country_code();

  public:
  // string country_text = 2;
  void clear_country_text() ;
  const std::string& country_text() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_country_text(Arg_&& arg, Args_... args);
  std::string* mutable_country_text();
  PROTOBUF_NODISCARD std::string* release_country_text();
  void set_allocated_country_text(std::string* value);

  private:
  const std::string& _internal_country_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country_text(
      const std::string& value);
  std::string* _internal_mutable_country_text();

  public:
  // string state_code = 3;
  void clear_state_code() ;
  const std::string& state_code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_state_code(Arg_&& arg, Args_... args);
  std::string* mutable_state_code();
  PROTOBUF_NODISCARD std::string* release_state_code();
  void set_allocated_state_code(std::string* value);

  private:
  const std::string& _internal_state_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state_code(
      const std::string& value);
  std::string* _internal_mutable_state_code();

  public:
  // string state_text = 4;
  void clear_state_text() ;
  const std::string& state_text() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_state_text(Arg_&& arg, Args_... args);
  std::string* mutable_state_text();
  PROTOBUF_NODISCARD std::string* release_state_text();
  void set_allocated_state_text(std::string* value);

  private:
  const std::string& _internal_state_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state_text(
      const std::string& value);
  std::string* _internal_mutable_state_text();

  public:
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.Admin)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      75, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr country_code_;
    ::google::protobuf::internal::ArenaStringPtr country_text_;
    ::google::protobuf::internal::ArenaStringPtr state_code_;
    ::google::protobuf::internal::ArenaStringPtr state_text_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};// -------------------------------------------------------------------

class TripLeg_PathCost final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.PathCost) */ {
 public:
  inline TripLeg_PathCost() : TripLeg_PathCost(nullptr) {}
  ~TripLeg_PathCost() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TripLeg_PathCost(::google::protobuf::internal::ConstantInitialized);

  inline TripLeg_PathCost(const TripLeg_PathCost& from)
      : TripLeg_PathCost(nullptr, from) {}
  TripLeg_PathCost(TripLeg_PathCost&& from) noexcept
    : TripLeg_PathCost() {
    *this = ::std::move(from);
  }

  inline TripLeg_PathCost& operator=(const TripLeg_PathCost& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_PathCost& operator=(TripLeg_PathCost&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TripLeg_PathCost& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripLeg_PathCost* internal_default_instance() {
    return reinterpret_cast<const TripLeg_PathCost*>(
               &_TripLeg_PathCost_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TripLeg_PathCost& a, TripLeg_PathCost& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_PathCost* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_PathCost* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_PathCost* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_PathCost>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const TripLeg_PathCost& from);
  void MergeFrom(const TripLeg_PathCost& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TripLeg_PathCost* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.TripLeg.PathCost";
  }
  protected:
  explicit TripLeg_PathCost(::google::protobuf::Arena* arena);
  TripLeg_PathCost(::google::protobuf::Arena* arena, const TripLeg_PathCost& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kElapsedCostFieldNumber = 1,
    kTransitionCostFieldNumber = 2,
  };
  // .valhalla.TripLeg.Cost elapsed_cost = 1;
  bool has_elapsed_cost() const;
  void clear_elapsed_cost() ;
  const ::valhalla::TripLeg_Cost& elapsed_cost() const;
  PROTOBUF_NODISCARD ::valhalla::TripLeg_Cost* release_elapsed_cost();
  ::valhalla::TripLeg_Cost* mutable_elapsed_cost();
  void set_allocated_elapsed_cost(::valhalla::TripLeg_Cost* value);
  void unsafe_arena_set_allocated_elapsed_cost(::valhalla::TripLeg_Cost* value);
  ::valhalla::TripLeg_Cost* unsafe_arena_release_elapsed_cost();

  private:
  const ::valhalla::TripLeg_Cost& _internal_elapsed_cost() const;
  ::valhalla::TripLeg_Cost* _internal_mutable_elapsed_cost();

  public:
  // .valhalla.TripLeg.Cost transition_cost = 2;
  bool has_transition_cost() const;
  void clear_transition_cost() ;
  const ::valhalla::TripLeg_Cost& transition_cost() const;
  PROTOBUF_NODISCARD ::valhalla::TripLeg_Cost* release_transition_cost();
  ::valhalla::TripLeg_Cost* mutable_transition_cost();
  void set_allocated_transition_cost(::valhalla::TripLeg_Cost* value);
  void unsafe_arena_set_allocated_transition_cost(::valhalla::TripLeg_Cost* value);
  ::valhalla::TripLeg_Cost* unsafe_arena_release_transition_cost();

  private:
  const ::valhalla::TripLeg_Cost& _internal_transition_cost() const;
  ::valhalla::TripLeg_Cost* _internal_mutable_transition_cost();

  public:
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.PathCost)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::valhalla::TripLeg_Cost* elapsed_cost_;
    ::valhalla::TripLeg_Cost* transition_cost_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};// -------------------------------------------------------------------

class TripLeg_ConditionalSpeedLimit final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.ConditionalSpeedLimit) */ {
 public:
  inline TripLeg_ConditionalSpeedLimit() : TripLeg_ConditionalSpeedLimit(nullptr) {}
  ~TripLeg_ConditionalSpeedLimit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TripLeg_ConditionalSpeedLimit(::google::protobuf::internal::ConstantInitialized);

  inline TripLeg_ConditionalSpeedLimit(const TripLeg_ConditionalSpeedLimit& from)
      : TripLeg_ConditionalSpeedLimit(nullptr, from) {}
  TripLeg_ConditionalSpeedLimit(TripLeg_ConditionalSpeedLimit&& from) noexcept
    : TripLeg_ConditionalSpeedLimit() {
    *this = ::std::move(from);
  }

  inline TripLeg_ConditionalSpeedLimit& operator=(const TripLeg_ConditionalSpeedLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_ConditionalSpeedLimit& operator=(TripLeg_ConditionalSpeedLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TripLeg_ConditionalSpeedLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripLeg_ConditionalSpeedLimit* internal_default_instance() {
    return reinterpret_cast<const TripLeg_ConditionalSpeedLimit*>(
               &_TripLeg_ConditionalSpeedLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TripLeg_ConditionalSpeedLimit& a, TripLeg_ConditionalSpeedLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_ConditionalSpeedLimit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_ConditionalSpeedLimit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_ConditionalSpeedLimit* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_ConditionalSpeedLimit>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const TripLeg_ConditionalSpeedLimit& from);
  void MergeFrom(const TripLeg_ConditionalSpeedLimit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TripLeg_ConditionalSpeedLimit* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.TripLeg.ConditionalSpeedLimit";
  }
  protected:
  explicit TripLeg_ConditionalSpeedLimit(::google::protobuf::Arena* arena);
  TripLeg_ConditionalSpeedLimit(::google::protobuf::Arena* arena, const TripLeg_ConditionalSpeedLimit& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConditionFieldNumber = 2,
    kSpeedLimitFieldNumber = 1,
  };
  // .valhalla.TripLeg.TimeDomain condition = 2;
  bool has_condition() const;
  void clear_condition() ;
  const ::valhalla::TripLeg_TimeDomain& condition() const;
  PROTOBUF_NODISCARD ::valhalla::TripLeg_TimeDomain* release_condition();
  ::valhalla::TripLeg_TimeDomain* mutable_condition();
  void set_allocated_condition(::valhalla::TripLeg_TimeDomain* value);
  void unsafe_arena_set_allocated_condition(::valhalla::TripLeg_TimeDomain* value);
  ::valhalla::TripLeg_TimeDomain* unsafe_arena_release_condition();

  private:
  const ::valhalla::TripLeg_TimeDomain& _internal_condition() const;
  ::valhalla::TripLeg_TimeDomain* _internal_mutable_condition();

  public:
  // uint32 speed_limit = 1;
  void clear_speed_limit() ;
  ::uint32_t speed_limit() const;
  void set_speed_limit(::uint32_t value);

  private:
  ::uint32_t _internal_speed_limit() const;
  void _internal_set_speed_limit(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.ConditionalSpeedLimit)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::valhalla::TripLeg_TimeDomain* condition_;
    ::uint32_t speed_limit_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};// -------------------------------------------------------------------

class TripLeg_Incident final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.Incident) */ {
 public:
  inline TripLeg_Incident() : TripLeg_Incident(nullptr) {}
  ~TripLeg_Incident() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TripLeg_Incident(::google::protobuf::internal::ConstantInitialized);

  inline TripLeg_Incident(const TripLeg_Incident& from)
      : TripLeg_Incident(nullptr, from) {}
  TripLeg_Incident(TripLeg_Incident&& from) noexcept
    : TripLeg_Incident() {
    *this = ::std::move(from);
  }

  inline TripLeg_Incident& operator=(const TripLeg_Incident& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_Incident& operator=(TripLeg_Incident&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TripLeg_Incident& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripLeg_Incident* internal_default_instance() {
    return reinterpret_cast<const TripLeg_Incident*>(
               &_TripLeg_Incident_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TripLeg_Incident& a, TripLeg_Incident& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_Incident* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_Incident* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_Incident* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_Incident>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const TripLeg_Incident& from);
  void MergeFrom(const TripLeg_Incident& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TripLeg_Incident* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.TripLeg.Incident";
  }
  protected:
  explicit TripLeg_Incident(::google::protobuf::Arena* arena);
  TripLeg_Incident(::google::protobuf::Arena* arena, const TripLeg_Incident& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
    kBeginShapeIndexFieldNumber = 3,
    kEndShapeIndexFieldNumber = 4,
  };
  // .valhalla.IncidentsTile.Metadata metadata = 1;
  bool has_metadata() const;
  void clear_metadata() ;
  const ::valhalla::IncidentsTile_Metadata& metadata() const;
  PROTOBUF_NODISCARD ::valhalla::IncidentsTile_Metadata* release_metadata();
  ::valhalla::IncidentsTile_Metadata* mutable_metadata();
  void set_allocated_metadata(::valhalla::IncidentsTile_Metadata* value);
  void unsafe_arena_set_allocated_metadata(::valhalla::IncidentsTile_Metadata* value);
  ::valhalla::IncidentsTile_Metadata* unsafe_arena_release_metadata();

  private:
  const ::valhalla::IncidentsTile_Metadata& _internal_metadata() const;
  ::valhalla::IncidentsTile_Metadata* _internal_mutable_metadata();

  public:
  // uint32 begin_shape_index = 3;
  void clear_begin_shape_index() ;
  ::uint32_t begin_shape_index() const;
  void set_begin_shape_index(::uint32_t value);

  private:
  ::uint32_t _internal_begin_shape_index() const;
  void _internal_set_begin_shape_index(::uint32_t value);

  public:
  // uint32 end_shape_index = 4;
  void clear_end_shape_index() ;
  ::uint32_t end_shape_index() const;
  void set_end_shape_index(::uint32_t value);

  private:
  ::uint32_t _internal_end_shape_index() const;
  void _internal_set_end_shape_index(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.Incident)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::valhalla::IncidentsTile_Metadata* metadata_;
    ::uint32_t begin_shape_index_;
    ::uint32_t end_shape_index_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};// -------------------------------------------------------------------

class TripLeg_IntersectingEdge final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.IntersectingEdge) */ {
 public:
  inline TripLeg_IntersectingEdge() : TripLeg_IntersectingEdge(nullptr) {}
  ~TripLeg_IntersectingEdge() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TripLeg_IntersectingEdge(::google::protobuf::internal::ConstantInitialized);

  inline TripLeg_IntersectingEdge(const TripLeg_IntersectingEdge& from)
      : TripLeg_IntersectingEdge(nullptr, from) {}
  TripLeg_IntersectingEdge(TripLeg_IntersectingEdge&& from) noexcept
    : TripLeg_IntersectingEdge() {
    *this = ::std::move(from);
  }

  inline TripLeg_IntersectingEdge& operator=(const TripLeg_IntersectingEdge& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_IntersectingEdge& operator=(TripLeg_IntersectingEdge&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TripLeg_IntersectingEdge& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripLeg_IntersectingEdge* internal_default_instance() {
    return reinterpret_cast<const TripLeg_IntersectingEdge*>(
               &_TripLeg_IntersectingEdge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TripLeg_IntersectingEdge& a, TripLeg_IntersectingEdge& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_IntersectingEdge* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_IntersectingEdge* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_IntersectingEdge* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_IntersectingEdge>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const TripLeg_IntersectingEdge& from);
  void MergeFrom(const TripLeg_IntersectingEdge& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TripLeg_IntersectingEdge* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.TripLeg.IntersectingEdge";
  }
  protected:
  explicit TripLeg_IntersectingEdge(::google::protobuf::Arena* arena);
  TripLeg_IntersectingEdge(::google::protobuf::Arena* arena, const TripLeg_IntersectingEdge& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 21,
    kSignFieldNumber = 10,
    kBeginHeadingFieldNumber = 1,
    kPrevNameConsistencyFieldNumber = 2,
    kCurrNameConsistencyFieldNumber = 3,
    kDriveabilityFieldNumber = 4,
    kCyclabilityFieldNumber = 5,
    kWalkabilityFieldNumber = 6,
    kUseFieldNumber = 7,
    kRoadClassFieldNumber = 8,
    kLaneCountFieldNumber = 9,
  };
  // repeated .valhalla.StreetName name = 21;
  int name_size() const;
  private:
  int _internal_name_size() const;

  public:
  void clear_name() ;
  ::valhalla::StreetName* mutable_name(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >*
      mutable_name();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>& _internal_name() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>* _internal_mutable_name();
  public:
  const ::valhalla::StreetName& name(int index) const;
  ::valhalla::StreetName* add_name();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >&
      name() const;
  // .valhalla.TripSign sign = 10;
  bool has_sign() const;
  void clear_sign() ;
  const ::valhalla::TripSign& sign() const;
  PROTOBUF_NODISCARD ::valhalla::TripSign* release_sign();
  ::valhalla::TripSign* mutable_sign();
  void set_allocated_sign(::valhalla::TripSign* value);
  void unsafe_arena_set_allocated_sign(::valhalla::TripSign* value);
  ::valhalla::TripSign* unsafe_arena_release_sign();

  private:
  const ::valhalla::TripSign& _internal_sign() const;
  ::valhalla::TripSign* _internal_mutable_sign();

  public:
  // uint32 begin_heading = 1;
  void clear_begin_heading() ;
  ::uint32_t begin_heading() const;
  void set_begin_heading(::uint32_t value);

  private:
  ::uint32_t _internal_begin_heading() const;
  void _internal_set_begin_heading(::uint32_t value);

  public:
  // bool prev_name_consistency = 2;
  void clear_prev_name_consistency() ;
  bool prev_name_consistency() const;
  void set_prev_name_consistency(bool value);

  private:
  bool _internal_prev_name_consistency() const;
  void _internal_set_prev_name_consistency(bool value);

  public:
  // bool curr_name_consistency = 3;
  void clear_curr_name_consistency() ;
  bool curr_name_consistency() const;
  void set_curr_name_consistency(bool value);

  private:
  bool _internal_curr_name_consistency() const;
  void _internal_set_curr_name_consistency(bool value);

  public:
  // .valhalla.TripLeg.Traversability driveability = 4;
  void clear_driveability() ;
  ::valhalla::TripLeg_Traversability driveability() const;
  void set_driveability(::valhalla::TripLeg_Traversability value);

  private:
  ::valhalla::TripLeg_Traversability _internal_driveability() const;
  void _internal_set_driveability(::valhalla::TripLeg_Traversability value);

  public:
  // .valhalla.TripLeg.Traversability cyclability = 5;
  void clear_cyclability() ;
  ::valhalla::TripLeg_Traversability cyclability() const;
  void set_cyclability(::valhalla::TripLeg_Traversability value);

  private:
  ::valhalla::TripLeg_Traversability _internal_cyclability() const;
  void _internal_set_cyclability(::valhalla::TripLeg_Traversability value);

  public:
  // .valhalla.TripLeg.Traversability walkability = 6;
  void clear_walkability() ;
  ::valhalla::TripLeg_Traversability walkability() const;
  void set_walkability(::valhalla::TripLeg_Traversability value);

  private:
  ::valhalla::TripLeg_Traversability _internal_walkability() const;
  void _internal_set_walkability(::valhalla::TripLeg_Traversability value);

  public:
  // .valhalla.TripLeg.Use use = 7;
  void clear_use() ;
  ::valhalla::TripLeg_Use use() const;
  void set_use(::valhalla::TripLeg_Use value);

  private:
  ::valhalla::TripLeg_Use _internal_use() const;
  void _internal_set_use(::valhalla::TripLeg_Use value);

  public:
  // .valhalla.RoadClass road_class = 8;
  void clear_road_class() ;
  ::valhalla::RoadClass road_class() const;
  void set_road_class(::valhalla::RoadClass value);

  private:
  ::valhalla::RoadClass _internal_road_class() const;
  void _internal_set_road_class(::valhalla::RoadClass value);

  public:
  // uint32 lane_count = 9;
  void clear_lane_count() ;
  ::uint32_t lane_count() const;
  void set_lane_count(::uint32_t value);

  private:
  ::uint32_t _internal_lane_count() const;
  void _internal_set_lane_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.IntersectingEdge)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 11, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName > name_;
    ::valhalla::TripSign* sign_;
    ::uint32_t begin_heading_;
    bool prev_name_consistency_;
    bool curr_name_consistency_;
    int driveability_;
    int cyclability_;
    int walkability_;
    int use_;
    int road_class_;
    ::uint32_t lane_count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};// -------------------------------------------------------------------

class TripLeg_Edge final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.Edge) */ {
 public:
  inline TripLeg_Edge() : TripLeg_Edge(nullptr) {}
  ~TripLeg_Edge() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TripLeg_Edge(::google::protobuf::internal::ConstantInitialized);

  inline TripLeg_Edge(const TripLeg_Edge& from)
      : TripLeg_Edge(nullptr, from) {}
  TripLeg_Edge(TripLeg_Edge&& from) noexcept
    : TripLeg_Edge() {
    *this = ::std::move(from);
  }

  inline TripLeg_Edge& operator=(const TripLeg_Edge& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_Edge& operator=(TripLeg_Edge&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TripLeg_Edge& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripLeg_Edge* internal_default_instance() {
    return reinterpret_cast<const TripLeg_Edge*>(
               &_TripLeg_Edge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TripLeg_Edge& a, TripLeg_Edge& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_Edge* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_Edge* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_Edge* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_Edge>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const TripLeg_Edge& from);
  void MergeFrom(const TripLeg_Edge& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TripLeg_Edge* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.TripLeg.Edge";
  }
  protected:
  explicit TripLeg_Edge(::google::protobuf::Arena* arena);
  TripLeg_Edge(::google::protobuf::Arena* arena, const TripLeg_Edge& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kLaneConnectivityFieldNumber = 39,
    kTrafficSegmentFieldNumber = 41,
    kTurnLanesFieldNumber = 42,
    kTaggedValueFieldNumber = 48,
    kLandmarksFieldNumber = 54,
    kTunnelNameFieldNumber = 55,
    kElevationFieldNumber = 57,
    kConditionalSpeedLimitsFieldNumber = 60,
    kSignFieldNumber = 19,
    kTransitRouteInfoFieldNumber = 25,
    kRestrictionFieldNumber = 45,
    kLengthKmFieldNumber = 2,
    kSpeedFieldNumber = 3,
    kRoadClassFieldNumber = 4,
    kBeginHeadingFieldNumber = 5,
    kEndHeadingFieldNumber = 6,
    kBeginShapeIndexFieldNumber = 7,
    kEndShapeIndexFieldNumber = 8,
    kTraversabilityFieldNumber = 9,
    kUseFieldNumber = 10,
    kTollFieldNumber = 11,
    kUnpavedFieldNumber = 12,
    kTunnelFieldNumber = 13,
    kBridgeFieldNumber = 14,
    kSurfaceFieldNumber = 18,
    kTravelModeFieldNumber = 20,
    kRoundaboutFieldNumber = 15,
    kInternalIntersectionFieldNumber = 16,
    kDriveOnLeftFieldNumber = 17,
    kBicycleNetworkFieldNumber = 33,
    kVehicleTypeFieldNumber = 21,
    kPedestrianTypeFieldNumber = 22,
    kBicycleTypeFieldNumber = 23,
    kIdFieldNumber = 26,
    kTransitTypeFieldNumber = 24,
    kWeightedGradeFieldNumber = 28,
    kWayIdFieldNumber = 27,
    kMaxUpwardGradeFieldNumber = 29,
    kMaxDownwardGradeFieldNumber = 30,
    kLaneCountFieldNumber = 31,
    kCycleLaneFieldNumber = 32,
    kSidewalkFieldNumber = 34,
    kDensityFieldNumber = 35,
    kSpeedLimitFieldNumber = 36,
    kTruckSpeedFieldNumber = 37,
    kMeanElevationFieldNumber = 40,
    kTruckRouteFieldNumber = 38,
    kHasTimeRestrictionsFieldNumber = 43,
    kDestinationOnlyFieldNumber = 46,
    kIsUrbanFieldNumber = 47,
    kDefaultSpeedFieldNumber = 44,
    kSourceAlongEdgeFieldNumber = 49,
    kTargetAlongEdgeFieldNumber = 50,
    kSacScaleFieldNumber = 51,
    kShoulderFieldNumber = 52,
    kIndoorFieldNumber = 53,
    kCountryCrossingFieldNumber = 58,
    kForwardFieldNumber = 59,
    kElevationSamplingIntervalFieldNumber = 56,
  };
  // repeated .valhalla.StreetName name = 1;
  int name_size() const;
  private:
  int _internal_name_size() const;

  public:
  void clear_name() ;
  ::valhalla::StreetName* mutable_name(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >*
      mutable_name();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>& _internal_name() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>* _internal_mutable_name();
  public:
  const ::valhalla::StreetName& name(int index) const;
  ::valhalla::StreetName* add_name();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >&
      name() const;
  // repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
  int lane_connectivity_size() const;
  private:
  int _internal_lane_connectivity_size() const;

  public:
  void clear_lane_connectivity() ;
  ::valhalla::TripLeg_LaneConnectivity* mutable_lane_connectivity(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_LaneConnectivity >*
      mutable_lane_connectivity();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_LaneConnectivity>& _internal_lane_connectivity() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_LaneConnectivity>* _internal_mutable_lane_connectivity();
  public:
  const ::valhalla::TripLeg_LaneConnectivity& lane_connectivity(int index) const;
  ::valhalla::TripLeg_LaneConnectivity* add_lane_connectivity();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_LaneConnectivity >&
      lane_connectivity() const;
  // repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
  int traffic_segment_size() const;
  private:
  int _internal_traffic_segment_size() const;

  public:
  void clear_traffic_segment() ;
  ::valhalla::TripLeg_TrafficSegment* mutable_traffic_segment(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_TrafficSegment >*
      mutable_traffic_segment();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_TrafficSegment>& _internal_traffic_segment() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_TrafficSegment>* _internal_mutable_traffic_segment();
  public:
  const ::valhalla::TripLeg_TrafficSegment& traffic_segment(int index) const;
  ::valhalla::TripLeg_TrafficSegment* add_traffic_segment();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_TrafficSegment >&
      traffic_segment() const;
  // repeated .valhalla.TurnLane turn_lanes = 42;
  int turn_lanes_size() const;
  private:
  int _internal_turn_lanes_size() const;

  public:
  void clear_turn_lanes() ;
  ::valhalla::TurnLane* mutable_turn_lanes(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::TurnLane >*
      mutable_turn_lanes();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::TurnLane>& _internal_turn_lanes() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::TurnLane>* _internal_mutable_turn_lanes();
  public:
  const ::valhalla::TurnLane& turn_lanes(int index) const;
  ::valhalla::TurnLane* add_turn_lanes();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::TurnLane >&
      turn_lanes() const;
  // repeated .valhalla.TaggedValue tagged_value = 48;
  int tagged_value_size() const;
  private:
  int _internal_tagged_value_size() const;

  public:
  void clear_tagged_value() ;
  ::valhalla::TaggedValue* mutable_tagged_value(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::TaggedValue >*
      mutable_tagged_value();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::TaggedValue>& _internal_tagged_value() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::TaggedValue>* _internal_mutable_tagged_value();
  public:
  const ::valhalla::TaggedValue& tagged_value(int index) const;
  ::valhalla::TaggedValue* add_tagged_value();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::TaggedValue >&
      tagged_value() const;
  // repeated .valhalla.RouteLandmark landmarks = 54;
  int landmarks_size() const;
  private:
  int _internal_landmarks_size() const;

  public:
  void clear_landmarks() ;
  ::valhalla::RouteLandmark* mutable_landmarks(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::RouteLandmark >*
      mutable_landmarks();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::RouteLandmark>& _internal_landmarks() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::RouteLandmark>* _internal_mutable_landmarks();
  public:
  const ::valhalla::RouteLandmark& landmarks(int index) const;
  ::valhalla::RouteLandmark* add_landmarks();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::RouteLandmark >&
      landmarks() const;
  // repeated .valhalla.StreetName tunnel_name = 55;
  int tunnel_name_size() const;
  private:
  int _internal_tunnel_name_size() const;

  public:
  void clear_tunnel_name() ;
  ::valhalla::StreetName* mutable_tunnel_name(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >*
      mutable_tunnel_name();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>& _internal_tunnel_name() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>* _internal_mutable_tunnel_name();
  public:
  const ::valhalla::StreetName& tunnel_name(int index) const;
  ::valhalla::StreetName* add_tunnel_name();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >&
      tunnel_name() const;
  // repeated float elevation = 57;
  int elevation_size() const;
  private:
  int _internal_elevation_size() const;

  public:
  void clear_elevation() ;
  float elevation(int index) const;
  void set_elevation(int index, float value);
  void add_elevation(float value);
  const ::google::protobuf::RepeatedField<float>& elevation() const;
  ::google::protobuf::RepeatedField<float>* mutable_elevation();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_elevation() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_elevation();

  public:
  // repeated .valhalla.TripLeg.ConditionalSpeedLimit conditional_speed_limits = 60;
  int conditional_speed_limits_size() const;
  private:
  int _internal_conditional_speed_limits_size() const;

  public:
  void clear_conditional_speed_limits() ;
  ::valhalla::TripLeg_ConditionalSpeedLimit* mutable_conditional_speed_limits(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_ConditionalSpeedLimit >*
      mutable_conditional_speed_limits();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_ConditionalSpeedLimit>& _internal_conditional_speed_limits() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_ConditionalSpeedLimit>* _internal_mutable_conditional_speed_limits();
  public:
  const ::valhalla::TripLeg_ConditionalSpeedLimit& conditional_speed_limits(int index) const;
  ::valhalla::TripLeg_ConditionalSpeedLimit* add_conditional_speed_limits();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_ConditionalSpeedLimit >&
      conditional_speed_limits() const;
  // .valhalla.TripSign sign = 19;
  bool has_sign() const;
  void clear_sign() ;
  const ::valhalla::TripSign& sign() const;
  PROTOBUF_NODISCARD ::valhalla::TripSign* release_sign();
  ::valhalla::TripSign* mutable_sign();
  void set_allocated_sign(::valhalla::TripSign* value);
  void unsafe_arena_set_allocated_sign(::valhalla::TripSign* value);
  ::valhalla::TripSign* unsafe_arena_release_sign();

  private:
  const ::valhalla::TripSign& _internal_sign() const;
  ::valhalla::TripSign* _internal_mutable_sign();

  public:
  // .valhalla.TransitRouteInfo transit_route_info = 25;
  bool has_transit_route_info() const;
  void clear_transit_route_info() ;
  const ::valhalla::TransitRouteInfo& transit_route_info() const;
  PROTOBUF_NODISCARD ::valhalla::TransitRouteInfo* release_transit_route_info();
  ::valhalla::TransitRouteInfo* mutable_transit_route_info();
  void set_allocated_transit_route_info(::valhalla::TransitRouteInfo* value);
  void unsafe_arena_set_allocated_transit_route_info(::valhalla::TransitRouteInfo* value);
  ::valhalla::TransitRouteInfo* unsafe_arena_release_transit_route_info();

  private:
  const ::valhalla::TransitRouteInfo& _internal_transit_route_info() const;
  ::valhalla::TransitRouteInfo* _internal_mutable_transit_route_info();

  public:
  // .valhalla.TripLeg.Restriction restriction = 45;
  bool has_restriction() const;
  void clear_restriction() ;
  const ::valhalla::TripLeg_Restriction& restriction() const;
  PROTOBUF_NODISCARD ::valhalla::TripLeg_Restriction* release_restriction();
  ::valhalla::TripLeg_Restriction* mutable_restriction();
  void set_allocated_restriction(::valhalla::TripLeg_Restriction* value);
  void unsafe_arena_set_allocated_restriction(::valhalla::TripLeg_Restriction* value);
  ::valhalla::TripLeg_Restriction* unsafe_arena_release_restriction();

  private:
  const ::valhalla::TripLeg_Restriction& _internal_restriction() const;
  ::valhalla::TripLeg_Restriction* _internal_mutable_restriction();

  public:
  // float length_km = 2;
  void clear_length_km() ;
  float length_km() const;
  void set_length_km(float value);

  private:
  float _internal_length_km() const;
  void _internal_set_length_km(float value);

  public:
  // float speed = 3;
  void clear_speed() ;
  float speed() const;
  void set_speed(float value);

  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);

  public:
  // .valhalla.RoadClass road_class = 4;
  void clear_road_class() ;
  ::valhalla::RoadClass road_class() const;
  void set_road_class(::valhalla::RoadClass value);

  private:
  ::valhalla::RoadClass _internal_road_class() const;
  void _internal_set_road_class(::valhalla::RoadClass value);

  public:
  // uint32 begin_heading = 5;
  void clear_begin_heading() ;
  ::uint32_t begin_heading() const;
  void set_begin_heading(::uint32_t value);

  private:
  ::uint32_t _internal_begin_heading() const;
  void _internal_set_begin_heading(::uint32_t value);

  public:
  // uint32 end_heading = 6;
  void clear_end_heading() ;
  ::uint32_t end_heading() const;
  void set_end_heading(::uint32_t value);

  private:
  ::uint32_t _internal_end_heading() const;
  void _internal_set_end_heading(::uint32_t value);

  public:
  // uint32 begin_shape_index = 7;
  void clear_begin_shape_index() ;
  ::uint32_t begin_shape_index() const;
  void set_begin_shape_index(::uint32_t value);

  private:
  ::uint32_t _internal_begin_shape_index() const;
  void _internal_set_begin_shape_index(::uint32_t value);

  public:
  // uint32 end_shape_index = 8;
  void clear_end_shape_index() ;
  ::uint32_t end_shape_index() const;
  void set_end_shape_index(::uint32_t value);

  private:
  ::uint32_t _internal_end_shape_index() const;
  void _internal_set_end_shape_index(::uint32_t value);

  public:
  // .valhalla.TripLeg.Traversability traversability = 9;
  void clear_traversability() ;
  ::valhalla::TripLeg_Traversability traversability() const;
  void set_traversability(::valhalla::TripLeg_Traversability value);

  private:
  ::valhalla::TripLeg_Traversability _internal_traversability() const;
  void _internal_set_traversability(::valhalla::TripLeg_Traversability value);

  public:
  // .valhalla.TripLeg.Use use = 10;
  void clear_use() ;
  ::valhalla::TripLeg_Use use() const;
  void set_use(::valhalla::TripLeg_Use value);

  private:
  ::valhalla::TripLeg_Use _internal_use() const;
  void _internal_set_use(::valhalla::TripLeg_Use value);

  public:
  // bool toll = 11;
  void clear_toll() ;
  bool toll() const;
  void set_toll(bool value);

  private:
  bool _internal_toll() const;
  void _internal_set_toll(bool value);

  public:
  // bool unpaved = 12;
  void clear_unpaved() ;
  bool unpaved() const;
  void set_unpaved(bool value);

  private:
  bool _internal_unpaved() const;
  void _internal_set_unpaved(bool value);

  public:
  // bool tunnel = 13;
  void clear_tunnel() ;
  bool tunnel() const;
  void set_tunnel(bool value);

  private:
  bool _internal_tunnel() const;
  void _internal_set_tunnel(bool value);

  public:
  // bool bridge = 14;
  void clear_bridge() ;
  bool bridge() const;
  void set_bridge(bool value);

  private:
  bool _internal_bridge() const;
  void _internal_set_bridge(bool value);

  public:
  // .valhalla.TripLeg.Surface surface = 18;
  void clear_surface() ;
  ::valhalla::TripLeg_Surface surface() const;
  void set_surface(::valhalla::TripLeg_Surface value);

  private:
  ::valhalla::TripLeg_Surface _internal_surface() const;
  void _internal_set_surface(::valhalla::TripLeg_Surface value);

  public:
  // .valhalla.TravelMode travel_mode = 20;
  void clear_travel_mode() ;
  ::valhalla::TravelMode travel_mode() const;
  void set_travel_mode(::valhalla::TravelMode value);

  private:
  ::valhalla::TravelMode _internal_travel_mode() const;
  void _internal_set_travel_mode(::valhalla::TravelMode value);

  public:
  // bool roundabout = 15;
  void clear_roundabout() ;
  bool roundabout() const;
  void set_roundabout(bool value);

  private:
  bool _internal_roundabout() const;
  void _internal_set_roundabout(bool value);

  public:
  // bool internal_intersection = 16;
  void clear_internal_intersection() ;
  bool internal_intersection() const;
  void set_internal_intersection(bool value);

  private:
  bool _internal_internal_intersection() const;
  void _internal_set_internal_intersection(bool value);

  public:
  // bool drive_on_left = 17;
  void clear_drive_on_left() ;
  bool drive_on_left() const;
  void set_drive_on_left(bool value);

  private:
  bool _internal_drive_on_left() const;
  void _internal_set_drive_on_left(bool value);

  public:
  // bool bicycle_network = 33;
  void clear_bicycle_network() ;
  bool bicycle_network() const;
  void set_bicycle_network(bool value);

  private:
  bool _internal_bicycle_network() const;
  void _internal_set_bicycle_network(bool value);

  public:
  // .valhalla.VehicleType vehicle_type = 21;
  void clear_vehicle_type() ;
  ::valhalla::VehicleType vehicle_type() const;
  void set_vehicle_type(::valhalla::VehicleType value);

  private:
  ::valhalla::VehicleType _internal_vehicle_type() const;
  void _internal_set_vehicle_type(::valhalla::VehicleType value);

  public:
  // .valhalla.PedestrianType pedestrian_type = 22;
  void clear_pedestrian_type() ;
  ::valhalla::PedestrianType pedestrian_type() const;
  void set_pedestrian_type(::valhalla::PedestrianType value);

  private:
  ::valhalla::PedestrianType _internal_pedestrian_type() const;
  void _internal_set_pedestrian_type(::valhalla::PedestrianType value);

  public:
  // .valhalla.BicycleType bicycle_type = 23;
  void clear_bicycle_type() ;
  ::valhalla::BicycleType bicycle_type() const;
  void set_bicycle_type(::valhalla::BicycleType value);

  private:
  ::valhalla::BicycleType _internal_bicycle_type() const;
  void _internal_set_bicycle_type(::valhalla::BicycleType value);

  public:
  // uint64 id = 26;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // .valhalla.TransitType transit_type = 24;
  void clear_transit_type() ;
  ::valhalla::TransitType transit_type() const;
  void set_transit_type(::valhalla::TransitType value);

  private:
  ::valhalla::TransitType _internal_transit_type() const;
  void _internal_set_transit_type(::valhalla::TransitType value);

  public:
  // float weighted_grade = 28;
  void clear_weighted_grade() ;
  float weighted_grade() const;
  void set_weighted_grade(float value);

  private:
  float _internal_weighted_grade() const;
  void _internal_set_weighted_grade(float value);

  public:
  // uint64 way_id = 27;
  void clear_way_id() ;
  ::uint64_t way_id() const;
  void set_way_id(::uint64_t value);

  private:
  ::uint64_t _internal_way_id() const;
  void _internal_set_way_id(::uint64_t value);

  public:
  // int32 max_upward_grade = 29;
  void clear_max_upward_grade() ;
  ::int32_t max_upward_grade() const;
  void set_max_upward_grade(::int32_t value);

  private:
  ::int32_t _internal_max_upward_grade() const;
  void _internal_set_max_upward_grade(::int32_t value);

  public:
  // int32 max_downward_grade = 30;
  void clear_max_downward_grade() ;
  ::int32_t max_downward_grade() const;
  void set_max_downward_grade(::int32_t value);

  private:
  ::int32_t _internal_max_downward_grade() const;
  void _internal_set_max_downward_grade(::int32_t value);

  public:
  // uint32 lane_count = 31;
  void clear_lane_count() ;
  ::uint32_t lane_count() const;
  void set_lane_count(::uint32_t value);

  private:
  ::uint32_t _internal_lane_count() const;
  void _internal_set_lane_count(::uint32_t value);

  public:
  // .valhalla.TripLeg.CycleLane cycle_lane = 32;
  void clear_cycle_lane() ;
  ::valhalla::TripLeg_CycleLane cycle_lane() const;
  void set_cycle_lane(::valhalla::TripLeg_CycleLane value);

  private:
  ::valhalla::TripLeg_CycleLane _internal_cycle_lane() const;
  void _internal_set_cycle_lane(::valhalla::TripLeg_CycleLane value);

  public:
  // .valhalla.TripLeg.Sidewalk sidewalk = 34;
  void clear_sidewalk() ;
  ::valhalla::TripLeg_Sidewalk sidewalk() const;
  void set_sidewalk(::valhalla::TripLeg_Sidewalk value);

  private:
  ::valhalla::TripLeg_Sidewalk _internal_sidewalk() const;
  void _internal_set_sidewalk(::valhalla::TripLeg_Sidewalk value);

  public:
  // uint32 density = 35;
  void clear_density() ;
  ::uint32_t density() const;
  void set_density(::uint32_t value);

  private:
  ::uint32_t _internal_density() const;
  void _internal_set_density(::uint32_t value);

  public:
  // uint32 speed_limit = 36;
  void clear_speed_limit() ;
  ::uint32_t speed_limit() const;
  void set_speed_limit(::uint32_t value);

  private:
  ::uint32_t _internal_speed_limit() const;
  void _internal_set_speed_limit(::uint32_t value);

  public:
  // float truck_speed = 37;
  void clear_truck_speed() ;
  float truck_speed() const;
  void set_truck_speed(float value);

  private:
  float _internal_truck_speed() const;
  void _internal_set_truck_speed(float value);

  public:
  // int32 mean_elevation = 40;
  void clear_mean_elevation() ;
  ::int32_t mean_elevation() const;
  void set_mean_elevation(::int32_t value);

  private:
  ::int32_t _internal_mean_elevation() const;
  void _internal_set_mean_elevation(::int32_t value);

  public:
  // bool truck_route = 38;
  void clear_truck_route() ;
  bool truck_route() const;
  void set_truck_route(bool value);

  private:
  bool _internal_truck_route() const;
  void _internal_set_truck_route(bool value);

  public:
  // bool has_time_restrictions = 43;
  void clear_has_time_restrictions() ;
  bool has_time_restrictions() const;
  void set_has_time_restrictions(bool value);

  private:
  bool _internal_has_time_restrictions() const;
  void _internal_set_has_time_restrictions(bool value);

  public:
  // bool destination_only = 46;
  void clear_destination_only() ;
  bool destination_only() const;
  void set_destination_only(bool value);

  private:
  bool _internal_destination_only() const;
  void _internal_set_destination_only(bool value);

  public:
  // bool is_urban = 47;
  void clear_is_urban() ;
  bool is_urban() const;
  void set_is_urban(bool value);

  private:
  bool _internal_is_urban() const;
  void _internal_set_is_urban(bool value);

  public:
  // float default_speed = 44;
  void clear_default_speed() ;
  float default_speed() const;
  void set_default_speed(float value);

  private:
  float _internal_default_speed() const;
  void _internal_set_default_speed(float value);

  public:
  // float source_along_edge = 49;
  void clear_source_along_edge() ;
  float source_along_edge() const;
  void set_source_along_edge(float value);

  private:
  float _internal_source_along_edge() const;
  void _internal_set_source_along_edge(float value);

  public:
  // float target_along_edge = 50;
  void clear_target_along_edge() ;
  float target_along_edge() const;
  void set_target_along_edge(float value);

  private:
  float _internal_target_along_edge() const;
  void _internal_set_target_along_edge(float value);

  public:
  // .valhalla.TripLeg.SacScale sac_scale = 51;
  void clear_sac_scale() ;
  ::valhalla::TripLeg_SacScale sac_scale() const;
  void set_sac_scale(::valhalla::TripLeg_SacScale value);

  private:
  ::valhalla::TripLeg_SacScale _internal_sac_scale() const;
  void _internal_set_sac_scale(::valhalla::TripLeg_SacScale value);

  public:
  // bool shoulder = 52;
  void clear_shoulder() ;
  bool shoulder() const;
  void set_shoulder(bool value);

  private:
  bool _internal_shoulder() const;
  void _internal_set_shoulder(bool value);

  public:
  // bool indoor = 53;
  void clear_indoor() ;
  bool indoor() const;
  void set_indoor(bool value);

  private:
  bool _internal_indoor() const;
  void _internal_set_indoor(bool value);

  public:
  // bool country_crossing = 58;
  void clear_country_crossing() ;
  bool country_crossing() const;
  void set_country_crossing(bool value);

  private:
  bool _internal_country_crossing() const;
  void _internal_set_country_crossing(bool value);

  public:
  // bool forward = 59;
  void clear_forward() ;
  bool forward() const;
  void set_forward(bool value);

  private:
  bool _internal_forward() const;
  void _internal_set_forward(bool value);

  public:
  // float elevation_sampling_interval = 56;
  void clear_elevation_sampling_interval() ;
  float elevation_sampling_interval() const;
  void set_elevation_sampling_interval(float value);

  private:
  float _internal_elevation_sampling_interval() const;
  void _internal_set_elevation_sampling_interval(float value);

  public:
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.Edge)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 60, 11,
      0, 9>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName > name_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_LaneConnectivity > lane_connectivity_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_TrafficSegment > traffic_segment_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::TurnLane > turn_lanes_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::TaggedValue > tagged_value_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::RouteLandmark > landmarks_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName > tunnel_name_;
    ::google::protobuf::RepeatedField<float> elevation_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_ConditionalSpeedLimit > conditional_speed_limits_;
    ::valhalla::TripSign* sign_;
    ::valhalla::TransitRouteInfo* transit_route_info_;
    ::valhalla::TripLeg_Restriction* restriction_;
    float length_km_;
    float speed_;
    int road_class_;
    ::uint32_t begin_heading_;
    ::uint32_t end_heading_;
    ::uint32_t begin_shape_index_;
    ::uint32_t end_shape_index_;
    int traversability_;
    int use_;
    bool toll_;
    bool unpaved_;
    bool tunnel_;
    bool bridge_;
    int surface_;
    int travel_mode_;
    bool roundabout_;
    bool internal_intersection_;
    bool drive_on_left_;
    bool bicycle_network_;
    int vehicle_type_;
    int pedestrian_type_;
    int bicycle_type_;
    ::uint64_t id_;
    int transit_type_;
    float weighted_grade_;
    ::uint64_t way_id_;
    ::int32_t max_upward_grade_;
    ::int32_t max_downward_grade_;
    ::uint32_t lane_count_;
    int cycle_lane_;
    int sidewalk_;
    ::uint32_t density_;
    ::uint32_t speed_limit_;
    float truck_speed_;
    ::int32_t mean_elevation_;
    bool truck_route_;
    bool has_time_restrictions_;
    bool destination_only_;
    bool is_urban_;
    float default_speed_;
    float source_along_edge_;
    float target_along_edge_;
    int sac_scale_;
    bool shoulder_;
    bool indoor_;
    bool country_crossing_;
    bool forward_;
    float elevation_sampling_interval_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};// -------------------------------------------------------------------

class TripLeg_Node final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg.Node) */ {
 public:
  inline TripLeg_Node() : TripLeg_Node(nullptr) {}
  ~TripLeg_Node() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TripLeg_Node(::google::protobuf::internal::ConstantInitialized);

  inline TripLeg_Node(const TripLeg_Node& from)
      : TripLeg_Node(nullptr, from) {}
  TripLeg_Node(TripLeg_Node&& from) noexcept
    : TripLeg_Node() {
    *this = ::std::move(from);
  }

  inline TripLeg_Node& operator=(const TripLeg_Node& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg_Node& operator=(TripLeg_Node&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TripLeg_Node& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripLeg_Node* internal_default_instance() {
    return reinterpret_cast<const TripLeg_Node*>(
               &_TripLeg_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TripLeg_Node& a, TripLeg_Node& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg_Node* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg_Node* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg_Node* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg_Node>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const TripLeg_Node& from);
  void MergeFrom(const TripLeg_Node& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TripLeg_Node* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.TripLeg.Node";
  }
  protected:
  explicit TripLeg_Node(::google::protobuf::Arena* arena);
  TripLeg_Node(::google::protobuf::Arena* arena, const TripLeg_Node& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using Type = TripLeg_Node_Type;
  static constexpr Type kStreetIntersection = TripLeg_Node_Type_kStreetIntersection;
  static constexpr Type kGate = TripLeg_Node_Type_kGate;
  static constexpr Type kBollard = TripLeg_Node_Type_kBollard;
  static constexpr Type kTollBooth = TripLeg_Node_Type_kTollBooth;
  static constexpr Type kTransitEgress = TripLeg_Node_Type_kTransitEgress;
  static constexpr Type kTransitStation = TripLeg_Node_Type_kTransitStation;
  static constexpr Type kTransitPlatform = TripLeg_Node_Type_kTransitPlatform;
  static constexpr Type kBikeShare = TripLeg_Node_Type_kBikeShare;
  static constexpr Type kParking = TripLeg_Node_Type_kParking;
  static constexpr Type kMotorwayJunction = TripLeg_Node_Type_kMotorwayJunction;
  static constexpr Type kBorderControl = TripLeg_Node_Type_kBorderControl;
  static constexpr Type kTollGantry = TripLeg_Node_Type_kTollGantry;
  static constexpr Type kSumpBuster = TripLeg_Node_Type_kSumpBuster;
  static constexpr Type kBuildingEntrance = TripLeg_Node_Type_kBuildingEntrance;
  static constexpr Type kElevator = TripLeg_Node_Type_kElevator;
  static inline bool Type_IsValid(int value) {
    return TripLeg_Node_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = TripLeg_Node_Type_Type_MIN;
  static constexpr Type Type_MAX = TripLeg_Node_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = TripLeg_Node_Type_Type_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return TripLeg_Node_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return TripLeg_Node_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIntersectingEdgeFieldNumber = 2,
    kRecostsFieldNumber = 13,
    kTimeZoneFieldNumber = 11,
    kEdgeFieldNumber = 1,
    kTransitPlatformInfoFieldNumber = 6,
    kTransitStationInfoFieldNumber = 7,
    kTransitEgressInfoFieldNumber = 10,
    kCostFieldNumber = 12,
    kBssInfoFieldNumber = 14,
    kAdminIndexFieldNumber = 3,
    kTypeFieldNumber = 4,
    kForkFieldNumber = 5,
    kTrafficSignalFieldNumber = 21,
  };
  // repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
  int intersecting_edge_size() const;
  private:
  int _internal_intersecting_edge_size() const;

  public:
  void clear_intersecting_edge() ;
  ::valhalla::TripLeg_IntersectingEdge* mutable_intersecting_edge(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_IntersectingEdge >*
      mutable_intersecting_edge();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_IntersectingEdge>& _internal_intersecting_edge() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_IntersectingEdge>* _internal_mutable_intersecting_edge();
  public:
  const ::valhalla::TripLeg_IntersectingEdge& intersecting_edge(int index) const;
  ::valhalla::TripLeg_IntersectingEdge* add_intersecting_edge();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_IntersectingEdge >&
      intersecting_edge() const;
  // repeated .valhalla.TripLeg.PathCost recosts = 13;
  int recosts_size() const;
  private:
  int _internal_recosts_size() const;

  public:
  void clear_recosts() ;
  ::valhalla::TripLeg_PathCost* mutable_recosts(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_PathCost >*
      mutable_recosts();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_PathCost>& _internal_recosts() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_PathCost>* _internal_mutable_recosts();
  public:
  const ::valhalla::TripLeg_PathCost& recosts(int index) const;
  ::valhalla::TripLeg_PathCost* add_recosts();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_PathCost >&
      recosts() const;
  // string time_zone = 11;
  void clear_time_zone() ;
  const std::string& time_zone() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_time_zone(Arg_&& arg, Args_... args);
  std::string* mutable_time_zone();
  PROTOBUF_NODISCARD std::string* release_time_zone();
  void set_allocated_time_zone(std::string* value);

  private:
  const std::string& _internal_time_zone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time_zone(
      const std::string& value);
  std::string* _internal_mutable_time_zone();

  public:
  // .valhalla.TripLeg.Edge edge = 1;
  bool has_edge() const;
  void clear_edge() ;
  const ::valhalla::TripLeg_Edge& edge() const;
  PROTOBUF_NODISCARD ::valhalla::TripLeg_Edge* release_edge();
  ::valhalla::TripLeg_Edge* mutable_edge();
  void set_allocated_edge(::valhalla::TripLeg_Edge* value);
  void unsafe_arena_set_allocated_edge(::valhalla::TripLeg_Edge* value);
  ::valhalla::TripLeg_Edge* unsafe_arena_release_edge();

  private:
  const ::valhalla::TripLeg_Edge& _internal_edge() const;
  ::valhalla::TripLeg_Edge* _internal_mutable_edge();

  public:
  // .valhalla.TransitPlatformInfo transit_platform_info = 6;
  bool has_transit_platform_info() const;
  void clear_transit_platform_info() ;
  const ::valhalla::TransitPlatformInfo& transit_platform_info() const;
  PROTOBUF_NODISCARD ::valhalla::TransitPlatformInfo* release_transit_platform_info();
  ::valhalla::TransitPlatformInfo* mutable_transit_platform_info();
  void set_allocated_transit_platform_info(::valhalla::TransitPlatformInfo* value);
  void unsafe_arena_set_allocated_transit_platform_info(::valhalla::TransitPlatformInfo* value);
  ::valhalla::TransitPlatformInfo* unsafe_arena_release_transit_platform_info();

  private:
  const ::valhalla::TransitPlatformInfo& _internal_transit_platform_info() const;
  ::valhalla::TransitPlatformInfo* _internal_mutable_transit_platform_info();

  public:
  // .valhalla.TransitStationInfo transit_station_info = 7;
  bool has_transit_station_info() const;
  void clear_transit_station_info() ;
  const ::valhalla::TransitStationInfo& transit_station_info() const;
  PROTOBUF_NODISCARD ::valhalla::TransitStationInfo* release_transit_station_info();
  ::valhalla::TransitStationInfo* mutable_transit_station_info();
  void set_allocated_transit_station_info(::valhalla::TransitStationInfo* value);
  void unsafe_arena_set_allocated_transit_station_info(::valhalla::TransitStationInfo* value);
  ::valhalla::TransitStationInfo* unsafe_arena_release_transit_station_info();

  private:
  const ::valhalla::TransitStationInfo& _internal_transit_station_info() const;
  ::valhalla::TransitStationInfo* _internal_mutable_transit_station_info();

  public:
  // .valhalla.TransitEgressInfo transit_egress_info = 10;
  bool has_transit_egress_info() const;
  void clear_transit_egress_info() ;
  const ::valhalla::TransitEgressInfo& transit_egress_info() const;
  PROTOBUF_NODISCARD ::valhalla::TransitEgressInfo* release_transit_egress_info();
  ::valhalla::TransitEgressInfo* mutable_transit_egress_info();
  void set_allocated_transit_egress_info(::valhalla::TransitEgressInfo* value);
  void unsafe_arena_set_allocated_transit_egress_info(::valhalla::TransitEgressInfo* value);
  ::valhalla::TransitEgressInfo* unsafe_arena_release_transit_egress_info();

  private:
  const ::valhalla::TransitEgressInfo& _internal_transit_egress_info() const;
  ::valhalla::TransitEgressInfo* _internal_mutable_transit_egress_info();

  public:
  // .valhalla.TripLeg.PathCost cost = 12;
  bool has_cost() const;
  void clear_cost() ;
  const ::valhalla::TripLeg_PathCost& cost() const;
  PROTOBUF_NODISCARD ::valhalla::TripLeg_PathCost* release_cost();
  ::valhalla::TripLeg_PathCost* mutable_cost();
  void set_allocated_cost(::valhalla::TripLeg_PathCost* value);
  void unsafe_arena_set_allocated_cost(::valhalla::TripLeg_PathCost* value);
  ::valhalla::TripLeg_PathCost* unsafe_arena_release_cost();

  private:
  const ::valhalla::TripLeg_PathCost& _internal_cost() const;
  ::valhalla::TripLeg_PathCost* _internal_mutable_cost();

  public:
  // .valhalla.BikeShareStationInfo bss_info = 14;
  bool has_bss_info() const;
  void clear_bss_info() ;
  const ::valhalla::BikeShareStationInfo& bss_info() const;
  PROTOBUF_NODISCARD ::valhalla::BikeShareStationInfo* release_bss_info();
  ::valhalla::BikeShareStationInfo* mutable_bss_info();
  void set_allocated_bss_info(::valhalla::BikeShareStationInfo* value);
  void unsafe_arena_set_allocated_bss_info(::valhalla::BikeShareStationInfo* value);
  ::valhalla::BikeShareStationInfo* unsafe_arena_release_bss_info();

  private:
  const ::valhalla::BikeShareStationInfo& _internal_bss_info() const;
  ::valhalla::BikeShareStationInfo* _internal_mutable_bss_info();

  public:
  // uint32 admin_index = 3;
  void clear_admin_index() ;
  ::uint32_t admin_index() const;
  void set_admin_index(::uint32_t value);

  private:
  ::uint32_t _internal_admin_index() const;
  void _internal_set_admin_index(::uint32_t value);

  public:
  // .valhalla.TripLeg.Node.Type type = 4;
  void clear_type() ;
  ::valhalla::TripLeg_Node_Type type() const;
  void set_type(::valhalla::TripLeg_Node_Type value);

  private:
  ::valhalla::TripLeg_Node_Type _internal_type() const;
  void _internal_set_type(::valhalla::TripLeg_Node_Type value);

  public:
  // bool fork = 5;
  void clear_fork() ;
  bool fork() const;
  void set_fork(bool value);

  private:
  bool _internal_fork() const;
  void _internal_set_fork(bool value);

  public:
  // bool traffic_signal = 21;
  void clear_traffic_signal() ;
  bool traffic_signal() const;
  void set_traffic_signal(bool value);

  private:
  bool _internal_traffic_signal() const;
  void _internal_set_traffic_signal(bool value);

  public:
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.Node)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 13, 8,
      47, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_IntersectingEdge > intersecting_edge_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_PathCost > recosts_;
    ::google::protobuf::internal::ArenaStringPtr time_zone_;
    ::valhalla::TripLeg_Edge* edge_;
    ::valhalla::TransitPlatformInfo* transit_platform_info_;
    ::valhalla::TransitStationInfo* transit_station_info_;
    ::valhalla::TransitEgressInfo* transit_egress_info_;
    ::valhalla::TripLeg_PathCost* cost_;
    ::valhalla::BikeShareStationInfo* bss_info_;
    ::uint32_t admin_index_;
    int type_;
    bool fork_;
    bool traffic_signal_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};// -------------------------------------------------------------------

class TripLeg final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripLeg) */ {
 public:
  inline TripLeg() : TripLeg(nullptr) {}
  ~TripLeg() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TripLeg(::google::protobuf::internal::ConstantInitialized);

  inline TripLeg(const TripLeg& from)
      : TripLeg(nullptr, from) {}
  TripLeg(TripLeg&& from) noexcept
    : TripLeg() {
    *this = ::std::move(from);
  }

  inline TripLeg& operator=(const TripLeg& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripLeg& operator=(TripLeg&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TripLeg& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripLeg* internal_default_instance() {
    return reinterpret_cast<const TripLeg*>(
               &_TripLeg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TripLeg& a, TripLeg& b) {
    a.Swap(&b);
  }
  inline void Swap(TripLeg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripLeg* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripLeg* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripLeg>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const TripLeg& from);
  void MergeFrom(const TripLeg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TripLeg* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.TripLeg";
  }
  protected:
  explicit TripLeg(::google::protobuf::Arena* arena);
  TripLeg(::google::protobuf::Arena* arena, const TripLeg& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using LaneConnectivity = TripLeg_LaneConnectivity;
  using TrafficSegment = TripLeg_TrafficSegment;
  using Restriction = TripLeg_Restriction;
  using TimeDomain = TripLeg_TimeDomain;
  using ConditionalSpeedLimit = TripLeg_ConditionalSpeedLimit;
  using Edge = TripLeg_Edge;
  using IntersectingEdge = TripLeg_IntersectingEdge;
  using Cost = TripLeg_Cost;
  using PathCost = TripLeg_PathCost;
  using Node = TripLeg_Node;
  using Admin = TripLeg_Admin;
  using ShapeAttributes = TripLeg_ShapeAttributes;
  using Incident = TripLeg_Incident;
  using Closure = TripLeg_Closure;

  using Traversability = TripLeg_Traversability;
  static constexpr Traversability kNone = TripLeg_Traversability_kNone;
  static constexpr Traversability kForward = TripLeg_Traversability_kForward;
  static constexpr Traversability kBackward = TripLeg_Traversability_kBackward;
  static constexpr Traversability kBoth = TripLeg_Traversability_kBoth;
  static inline bool Traversability_IsValid(int value) {
    return TripLeg_Traversability_IsValid(value);
  }
  static constexpr Traversability Traversability_MIN = TripLeg_Traversability_Traversability_MIN;
  static constexpr Traversability Traversability_MAX = TripLeg_Traversability_Traversability_MAX;
  static constexpr int Traversability_ARRAYSIZE = TripLeg_Traversability_Traversability_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Traversability_Name(T value) {
    return TripLeg_Traversability_Name(value);
  }
  static inline bool Traversability_Parse(absl::string_view name, Traversability* value) {
    return TripLeg_Traversability_Parse(name, value);
  }

  using Use = TripLeg_Use;
  static constexpr Use kRoadUse = TripLeg_Use_kRoadUse;
  static constexpr Use kRampUse = TripLeg_Use_kRampUse;
  static constexpr Use kTurnChannelUse = TripLeg_Use_kTurnChannelUse;
  static constexpr Use kTrackUse = TripLeg_Use_kTrackUse;
  static constexpr Use kDrivewayUse = TripLeg_Use_kDrivewayUse;
  static constexpr Use kAlleyUse = TripLeg_Use_kAlleyUse;
  static constexpr Use kParkingAisleUse = TripLeg_Use_kParkingAisleUse;
  static constexpr Use kEmergencyAccessUse = TripLeg_Use_kEmergencyAccessUse;
  static constexpr Use kDriveThruUse = TripLeg_Use_kDriveThruUse;
  static constexpr Use kCuldesacUse = TripLeg_Use_kCuldesacUse;
  static constexpr Use kLivingStreetUse = TripLeg_Use_kLivingStreetUse;
  static constexpr Use kServiceRoadUse = TripLeg_Use_kServiceRoadUse;
  static constexpr Use kCyclewayUse = TripLeg_Use_kCyclewayUse;
  static constexpr Use kMountainBikeUse = TripLeg_Use_kMountainBikeUse;
  static constexpr Use kSidewalkUse = TripLeg_Use_kSidewalkUse;
  static constexpr Use kFootwayUse = TripLeg_Use_kFootwayUse;
  static constexpr Use kStepsUse = TripLeg_Use_kStepsUse;
  static constexpr Use kPathUse = TripLeg_Use_kPathUse;
  static constexpr Use kPedestrianUse = TripLeg_Use_kPedestrianUse;
  static constexpr Use kBridlewayUse = TripLeg_Use_kBridlewayUse;
  static constexpr Use kPedestrianCrossingUse = TripLeg_Use_kPedestrianCrossingUse;
  static constexpr Use kElevatorUse = TripLeg_Use_kElevatorUse;
  static constexpr Use kEscalatorUse = TripLeg_Use_kEscalatorUse;
  static constexpr Use kRestAreaUse = TripLeg_Use_kRestAreaUse;
  static constexpr Use kServiceAreaUse = TripLeg_Use_kServiceAreaUse;
  static constexpr Use kOtherUse = TripLeg_Use_kOtherUse;
  static constexpr Use kFerryUse = TripLeg_Use_kFerryUse;
  static constexpr Use kRailFerryUse = TripLeg_Use_kRailFerryUse;
  static constexpr Use kConstructionUse = TripLeg_Use_kConstructionUse;
  static constexpr Use kRailUse = TripLeg_Use_kRailUse;
  static constexpr Use kBusUse = TripLeg_Use_kBusUse;
  static constexpr Use kEgressConnectionUse = TripLeg_Use_kEgressConnectionUse;
  static constexpr Use kPlatformConnectionUse = TripLeg_Use_kPlatformConnectionUse;
  static constexpr Use kTransitConnectionUse = TripLeg_Use_kTransitConnectionUse;
  static inline bool Use_IsValid(int value) {
    return TripLeg_Use_IsValid(value);
  }
  static constexpr Use Use_MIN = TripLeg_Use_Use_MIN;
  static constexpr Use Use_MAX = TripLeg_Use_Use_MAX;
  static constexpr int Use_ARRAYSIZE = TripLeg_Use_Use_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Use_Name(T value) {
    return TripLeg_Use_Name(value);
  }
  static inline bool Use_Parse(absl::string_view name, Use* value) {
    return TripLeg_Use_Parse(name, value);
  }

  using Surface = TripLeg_Surface;
  static constexpr Surface kPavedSmooth = TripLeg_Surface_kPavedSmooth;
  static constexpr Surface kPaved = TripLeg_Surface_kPaved;
  static constexpr Surface kPavedRough = TripLeg_Surface_kPavedRough;
  static constexpr Surface kCompacted = TripLeg_Surface_kCompacted;
  static constexpr Surface kDirt = TripLeg_Surface_kDirt;
  static constexpr Surface kGravel = TripLeg_Surface_kGravel;
  static constexpr Surface kPath = TripLeg_Surface_kPath;
  static constexpr Surface kImpassable = TripLeg_Surface_kImpassable;
  static inline bool Surface_IsValid(int value) {
    return TripLeg_Surface_IsValid(value);
  }
  static constexpr Surface Surface_MIN = TripLeg_Surface_Surface_MIN;
  static constexpr Surface Surface_MAX = TripLeg_Surface_Surface_MAX;
  static constexpr int Surface_ARRAYSIZE = TripLeg_Surface_Surface_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Surface_Name(T value) {
    return TripLeg_Surface_Name(value);
  }
  static inline bool Surface_Parse(absl::string_view name, Surface* value) {
    return TripLeg_Surface_Parse(name, value);
  }

  using CycleLane = TripLeg_CycleLane;
  static constexpr CycleLane kNoCycleLane = TripLeg_CycleLane_kNoCycleLane;
  static constexpr CycleLane kShared = TripLeg_CycleLane_kShared;
  static constexpr CycleLane kDedicated = TripLeg_CycleLane_kDedicated;
  static constexpr CycleLane kSeparated = TripLeg_CycleLane_kSeparated;
  static inline bool CycleLane_IsValid(int value) {
    return TripLeg_CycleLane_IsValid(value);
  }
  static constexpr CycleLane CycleLane_MIN = TripLeg_CycleLane_CycleLane_MIN;
  static constexpr CycleLane CycleLane_MAX = TripLeg_CycleLane_CycleLane_MAX;
  static constexpr int CycleLane_ARRAYSIZE = TripLeg_CycleLane_CycleLane_ARRAYSIZE;
  template <typename T>
  static inline const std::string& CycleLane_Name(T value) {
    return TripLeg_CycleLane_Name(value);
  }
  static inline bool CycleLane_Parse(absl::string_view name, CycleLane* value) {
    return TripLeg_CycleLane_Parse(name, value);
  }

  using SacScale = TripLeg_SacScale;
  static constexpr SacScale kNoSacScale = TripLeg_SacScale_kNoSacScale;
  static constexpr SacScale kHiking = TripLeg_SacScale_kHiking;
  static constexpr SacScale kMountainHiking = TripLeg_SacScale_kMountainHiking;
  static constexpr SacScale kDemandingMountainHiking = TripLeg_SacScale_kDemandingMountainHiking;
  static constexpr SacScale kAlpineHiking = TripLeg_SacScale_kAlpineHiking;
  static constexpr SacScale kDemandingAlpineHiking = TripLeg_SacScale_kDemandingAlpineHiking;
  static constexpr SacScale kDifficultAlpineHiking = TripLeg_SacScale_kDifficultAlpineHiking;
  static inline bool SacScale_IsValid(int value) {
    return TripLeg_SacScale_IsValid(value);
  }
  static constexpr SacScale SacScale_MIN = TripLeg_SacScale_SacScale_MIN;
  static constexpr SacScale SacScale_MAX = TripLeg_SacScale_SacScale_MAX;
  static constexpr int SacScale_ARRAYSIZE = TripLeg_SacScale_SacScale_ARRAYSIZE;
  template <typename T>
  static inline const std::string& SacScale_Name(T value) {
    return TripLeg_SacScale_Name(value);
  }
  static inline bool SacScale_Parse(absl::string_view name, SacScale* value) {
    return TripLeg_SacScale_Parse(name, value);
  }

  using Sidewalk = TripLeg_Sidewalk;
  static constexpr Sidewalk kNoSidewalk = TripLeg_Sidewalk_kNoSidewalk;
  static constexpr Sidewalk kLeft = TripLeg_Sidewalk_kLeft;
  static constexpr Sidewalk kRight = TripLeg_Sidewalk_kRight;
  static constexpr Sidewalk kBothSides = TripLeg_Sidewalk_kBothSides;
  static inline bool Sidewalk_IsValid(int value) {
    return TripLeg_Sidewalk_IsValid(value);
  }
  static constexpr Sidewalk Sidewalk_MIN = TripLeg_Sidewalk_Sidewalk_MIN;
  static constexpr Sidewalk Sidewalk_MAX = TripLeg_Sidewalk_Sidewalk_MAX;
  static constexpr int Sidewalk_ARRAYSIZE = TripLeg_Sidewalk_Sidewalk_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Sidewalk_Name(T value) {
    return TripLeg_Sidewalk_Name(value);
  }
  static inline bool Sidewalk_Parse(absl::string_view name, Sidewalk* value) {
    return TripLeg_Sidewalk_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 5,
    kNodeFieldNumber = 6,
    kAdminFieldNumber = 7,
    kIncidentsFieldNumber = 11,
    kAlgorithmsFieldNumber = 12,
    kClosuresFieldNumber = 13,
    kShapeFieldNumber = 8,
    kBboxFieldNumber = 9,
    kShapeAttributesFieldNumber = 10,
    kSummaryFieldNumber = 14,
    kOsmChangesetFieldNumber = 1,
    kTripIdFieldNumber = 2,
    kLegIdFieldNumber = 3,
    kLegCountFieldNumber = 4,
  };
  // repeated .valhalla.Location location = 5;
  int location_size() const;
  private:
  int _internal_location_size() const;

  public:
  void clear_location() ;
  ::valhalla::Location* mutable_location(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
      mutable_location();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::Location>& _internal_location() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::Location>* _internal_mutable_location();
  public:
  const ::valhalla::Location& location(int index) const;
  ::valhalla::Location* add_location();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
      location() const;
  // repeated .valhalla.TripLeg.Node node = 6;
  int node_size() const;
  private:
  int _internal_node_size() const;

  public:
  void clear_node() ;
  ::valhalla::TripLeg_Node* mutable_node(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Node >*
      mutable_node();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_Node>& _internal_node() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_Node>* _internal_mutable_node();
  public:
  const ::valhalla::TripLeg_Node& node(int index) const;
  ::valhalla::TripLeg_Node* add_node();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Node >&
      node() const;
  // repeated .valhalla.TripLeg.Admin admin = 7;
  int admin_size() const;
  private:
  int _internal_admin_size() const;

  public:
  void clear_admin() ;
  ::valhalla::TripLeg_Admin* mutable_admin(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Admin >*
      mutable_admin();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_Admin>& _internal_admin() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_Admin>* _internal_mutable_admin();
  public:
  const ::valhalla::TripLeg_Admin& admin(int index) const;
  ::valhalla::TripLeg_Admin* add_admin();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Admin >&
      admin() const;
  // repeated .valhalla.TripLeg.Incident incidents = 11;
  int incidents_size() const;
  private:
  int _internal_incidents_size() const;

  public:
  void clear_incidents() ;
  ::valhalla::TripLeg_Incident* mutable_incidents(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Incident >*
      mutable_incidents();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_Incident>& _internal_incidents() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_Incident>* _internal_mutable_incidents();
  public:
  const ::valhalla::TripLeg_Incident& incidents(int index) const;
  ::valhalla::TripLeg_Incident* add_incidents();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Incident >&
      incidents() const;
  // repeated string algorithms = 12;
  int algorithms_size() const;
  private:
  int _internal_algorithms_size() const;

  public:
  void clear_algorithms() ;
  const std::string& algorithms(int index) const;
  std::string* mutable_algorithms(int index);
  void set_algorithms(int index, const std::string& value);
  void set_algorithms(int index, std::string&& value);
  void set_algorithms(int index, const char* value);
  void set_algorithms(int index, const char* value, std::size_t size);
  void set_algorithms(int index, absl::string_view value);
  std::string* add_algorithms();
  void add_algorithms(const std::string& value);
  void add_algorithms(std::string&& value);
  void add_algorithms(const char* value);
  void add_algorithms(const char* value, std::size_t size);
  void add_algorithms(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& algorithms() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_algorithms();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_algorithms() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_algorithms();

  public:
  // repeated .valhalla.TripLeg.Closure closures = 13;
  int closures_size() const;
  private:
  int _internal_closures_size() const;

  public:
  void clear_closures() ;
  ::valhalla::TripLeg_Closure* mutable_closures(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Closure >*
      mutable_closures();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_Closure>& _internal_closures() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_Closure>* _internal_mutable_closures();
  public:
  const ::valhalla::TripLeg_Closure& closures(int index) const;
  ::valhalla::TripLeg_Closure* add_closures();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Closure >&
      closures() const;
  // string shape = 8;
  void clear_shape() ;
  const std::string& shape() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_shape(Arg_&& arg, Args_... args);
  std::string* mutable_shape();
  PROTOBUF_NODISCARD std::string* release_shape();
  void set_allocated_shape(std::string* value);

  private:
  const std::string& _internal_shape() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shape(
      const std::string& value);
  std::string* _internal_mutable_shape();

  public:
  // .valhalla.BoundingBox bbox = 9;
  bool has_bbox() const;
  void clear_bbox() ;
  const ::valhalla::BoundingBox& bbox() const;
  PROTOBUF_NODISCARD ::valhalla::BoundingBox* release_bbox();
  ::valhalla::BoundingBox* mutable_bbox();
  void set_allocated_bbox(::valhalla::BoundingBox* value);
  void unsafe_arena_set_allocated_bbox(::valhalla::BoundingBox* value);
  ::valhalla::BoundingBox* unsafe_arena_release_bbox();

  private:
  const ::valhalla::BoundingBox& _internal_bbox() const;
  ::valhalla::BoundingBox* _internal_mutable_bbox();

  public:
  // .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
  bool has_shape_attributes() const;
  void clear_shape_attributes() ;
  const ::valhalla::TripLeg_ShapeAttributes& shape_attributes() const;
  PROTOBUF_NODISCARD ::valhalla::TripLeg_ShapeAttributes* release_shape_attributes();
  ::valhalla::TripLeg_ShapeAttributes* mutable_shape_attributes();
  void set_allocated_shape_attributes(::valhalla::TripLeg_ShapeAttributes* value);
  void unsafe_arena_set_allocated_shape_attributes(::valhalla::TripLeg_ShapeAttributes* value);
  ::valhalla::TripLeg_ShapeAttributes* unsafe_arena_release_shape_attributes();

  private:
  const ::valhalla::TripLeg_ShapeAttributes& _internal_shape_attributes() const;
  ::valhalla::TripLeg_ShapeAttributes* _internal_mutable_shape_attributes();

  public:
  // .valhalla.Summary summary = 14;
  bool has_summary() const;
  void clear_summary() ;
  const ::valhalla::Summary& summary() const;
  PROTOBUF_NODISCARD ::valhalla::Summary* release_summary();
  ::valhalla::Summary* mutable_summary();
  void set_allocated_summary(::valhalla::Summary* value);
  void unsafe_arena_set_allocated_summary(::valhalla::Summary* value);
  ::valhalla::Summary* unsafe_arena_release_summary();

  private:
  const ::valhalla::Summary& _internal_summary() const;
  ::valhalla::Summary* _internal_mutable_summary();

  public:
  // uint64 osm_changeset = 1;
  void clear_osm_changeset() ;
  ::uint64_t osm_changeset() const;
  void set_osm_changeset(::uint64_t value);

  private:
  ::uint64_t _internal_osm_changeset() const;
  void _internal_set_osm_changeset(::uint64_t value);

  public:
  // uint64 trip_id = 2;
  void clear_trip_id() ;
  ::uint64_t trip_id() const;
  void set_trip_id(::uint64_t value);

  private:
  ::uint64_t _internal_trip_id() const;
  void _internal_set_trip_id(::uint64_t value);

  public:
  // uint32 leg_id = 3;
  void clear_leg_id() ;
  ::uint32_t leg_id() const;
  void set_leg_id(::uint32_t value);

  private:
  ::uint32_t _internal_leg_id() const;
  void _internal_set_leg_id(::uint32_t value);

  public:
  // uint32 leg_count = 4;
  void clear_leg_count() ;
  ::uint32_t leg_count() const;
  void set_leg_count(::uint32_t value);

  private:
  ::uint32_t _internal_leg_count() const;
  void _internal_set_leg_count(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:valhalla.TripLeg)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 14, 8,
      48, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::Location > location_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Node > node_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Admin > admin_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Incident > incidents_;
    ::google::protobuf::RepeatedPtrField<std::string> algorithms_;
    ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Closure > closures_;
    ::google::protobuf::internal::ArenaStringPtr shape_;
    ::valhalla::BoundingBox* bbox_;
    ::valhalla::TripLeg_ShapeAttributes* shape_attributes_;
    ::valhalla::Summary* summary_;
    ::uint64_t osm_changeset_;
    ::uint64_t trip_id_;
    ::uint32_t leg_id_;
    ::uint32_t leg_count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};// -------------------------------------------------------------------

class TripRoute final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TripRoute) */ {
 public:
  inline TripRoute() : TripRoute(nullptr) {}
  ~TripRoute() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TripRoute(::google::protobuf::internal::ConstantInitialized);

  inline TripRoute(const TripRoute& from)
      : TripRoute(nullptr, from) {}
  TripRoute(TripRoute&& from) noexcept
    : TripRoute() {
    *this = ::std::move(from);
  }

  inline TripRoute& operator=(const TripRoute& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripRoute& operator=(TripRoute&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TripRoute& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripRoute* internal_default_instance() {
    return reinterpret_cast<const TripRoute*>(
               &_TripRoute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(TripRoute& a, TripRoute& b) {
    a.Swap(&b);
  }
  inline void Swap(TripRoute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripRoute* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripRoute* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TripRoute>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const TripRoute& from);
  void MergeFrom(const TripRoute& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TripRoute* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.TripRoute";
  }
  protected:
  explicit TripRoute(::google::protobuf::Arena* arena);
  TripRoute(::google::protobuf::Arena* arena, const TripRoute& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLegsFieldNumber = 1,
  };
  // repeated .valhalla.TripLeg legs = 1;
  int legs_size() const;
  private:
  int _internal_legs_size() const;

  public:
  void clear_legs() ;
  ::valhalla::TripLeg* mutable_legs(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg >*
      mutable_legs();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg>& _internal_legs() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg>* _internal_mutable_legs();
  public:
  const ::valhalla::TripLeg& legs(int index) const;
  ::valhalla::TripLeg* add_legs();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg >&
      legs() const;
  // @@protoc_insertion_point(class_scope:valhalla.TripRoute)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg > legs_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};// -------------------------------------------------------------------

class Trip final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.Trip) */ {
 public:
  inline Trip() : Trip(nullptr) {}
  ~Trip() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Trip(::google::protobuf::internal::ConstantInitialized);

  inline Trip(const Trip& from)
      : Trip(nullptr, from) {}
  Trip(Trip&& from) noexcept
    : Trip() {
    *this = ::std::move(from);
  }

  inline Trip& operator=(const Trip& from) {
    CopyFrom(from);
    return *this;
  }
  inline Trip& operator=(Trip&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Trip& default_instance() {
    return *internal_default_instance();
  }
  static inline const Trip* internal_default_instance() {
    return reinterpret_cast<const Trip*>(
               &_Trip_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Trip& a, Trip& b) {
    a.Swap(&b);
  }
  inline void Swap(Trip* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Trip* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Trip* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Trip>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Trip& from);
  void MergeFrom(const Trip& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Trip* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "valhalla.Trip";
  }
  protected:
  explicit Trip(::google::protobuf::Arena* arena);
  Trip(::google::protobuf::Arena* arena, const Trip& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoutesFieldNumber = 1,
  };
  // repeated .valhalla.TripRoute routes = 1;
  int routes_size() const;
  private:
  int _internal_routes_size() const;

  public:
  void clear_routes() ;
  ::valhalla::TripRoute* mutable_routes(int index);
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripRoute >*
      mutable_routes();
  private:
  const ::google::protobuf::RepeatedPtrField<::valhalla::TripRoute>& _internal_routes() const;
  ::google::protobuf::RepeatedPtrField<::valhalla::TripRoute>* _internal_mutable_routes();
  public:
  const ::valhalla::TripRoute& routes(int index) const;
  ::valhalla::TripRoute* add_routes();
  const ::google::protobuf::RepeatedPtrField< ::valhalla::TripRoute >&
      routes() const;
  // @@protoc_insertion_point(class_scope:valhalla.Trip)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::valhalla::TripRoute > routes_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trip_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// TripLeg_LaneConnectivity

// uint64 from_way_id = 1;
inline void TripLeg_LaneConnectivity::clear_from_way_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.from_way_id_ = ::uint64_t{0u};
}
inline ::uint64_t TripLeg_LaneConnectivity::from_way_id() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.LaneConnectivity.from_way_id)
  return _internal_from_way_id();
}
inline void TripLeg_LaneConnectivity::set_from_way_id(::uint64_t value) {
  _internal_set_from_way_id(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.LaneConnectivity.from_way_id)
}
inline ::uint64_t TripLeg_LaneConnectivity::_internal_from_way_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.from_way_id_;
}
inline void TripLeg_LaneConnectivity::_internal_set_from_way_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.from_way_id_ = value;
}

// string from_lanes = 2;
inline void TripLeg_LaneConnectivity::clear_from_lanes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.from_lanes_.ClearToEmpty();
}
inline const std::string& TripLeg_LaneConnectivity::from_lanes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.LaneConnectivity.from_lanes)
  return _internal_from_lanes();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TripLeg_LaneConnectivity::set_from_lanes(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.from_lanes_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.LaneConnectivity.from_lanes)
}
inline std::string* TripLeg_LaneConnectivity::mutable_from_lanes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_from_lanes();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.LaneConnectivity.from_lanes)
  return _s;
}
inline const std::string& TripLeg_LaneConnectivity::_internal_from_lanes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.from_lanes_.Get();
}
inline void TripLeg_LaneConnectivity::_internal_set_from_lanes(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.from_lanes_.Set(value, GetArena());
}
inline std::string* TripLeg_LaneConnectivity::_internal_mutable_from_lanes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.from_lanes_.Mutable( GetArena());
}
inline std::string* TripLeg_LaneConnectivity::release_from_lanes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.LaneConnectivity.from_lanes)
  return _impl_.from_lanes_.Release();
}
inline void TripLeg_LaneConnectivity::set_allocated_from_lanes(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.from_lanes_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.from_lanes_.IsDefault()) {
          _impl_.from_lanes_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.LaneConnectivity.from_lanes)
}

// string to_lanes = 3;
inline void TripLeg_LaneConnectivity::clear_to_lanes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.to_lanes_.ClearToEmpty();
}
inline const std::string& TripLeg_LaneConnectivity::to_lanes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.LaneConnectivity.to_lanes)
  return _internal_to_lanes();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TripLeg_LaneConnectivity::set_to_lanes(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.to_lanes_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.LaneConnectivity.to_lanes)
}
inline std::string* TripLeg_LaneConnectivity::mutable_to_lanes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_to_lanes();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.LaneConnectivity.to_lanes)
  return _s;
}
inline const std::string& TripLeg_LaneConnectivity::_internal_to_lanes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.to_lanes_.Get();
}
inline void TripLeg_LaneConnectivity::_internal_set_to_lanes(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.to_lanes_.Set(value, GetArena());
}
inline std::string* TripLeg_LaneConnectivity::_internal_mutable_to_lanes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.to_lanes_.Mutable( GetArena());
}
inline std::string* TripLeg_LaneConnectivity::release_to_lanes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.LaneConnectivity.to_lanes)
  return _impl_.to_lanes_.Release();
}
inline void TripLeg_LaneConnectivity::set_allocated_to_lanes(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.to_lanes_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.to_lanes_.IsDefault()) {
          _impl_.to_lanes_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.LaneConnectivity.to_lanes)
}

// -------------------------------------------------------------------

// TripLeg_TrafficSegment

// uint64 segment_id = 1;
inline void TripLeg_TrafficSegment::clear_segment_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.segment_id_ = ::uint64_t{0u};
}
inline ::uint64_t TripLeg_TrafficSegment::segment_id() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TrafficSegment.segment_id)
  return _internal_segment_id();
}
inline void TripLeg_TrafficSegment::set_segment_id(::uint64_t value) {
  _internal_set_segment_id(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TrafficSegment.segment_id)
}
inline ::uint64_t TripLeg_TrafficSegment::_internal_segment_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.segment_id_;
}
inline void TripLeg_TrafficSegment::_internal_set_segment_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.segment_id_ = value;
}

// float begin_percent = 2;
inline void TripLeg_TrafficSegment::clear_begin_percent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.begin_percent_ = 0;
}
inline float TripLeg_TrafficSegment::begin_percent() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TrafficSegment.begin_percent)
  return _internal_begin_percent();
}
inline void TripLeg_TrafficSegment::set_begin_percent(float value) {
  _internal_set_begin_percent(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TrafficSegment.begin_percent)
}
inline float TripLeg_TrafficSegment::_internal_begin_percent() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.begin_percent_;
}
inline void TripLeg_TrafficSegment::_internal_set_begin_percent(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.begin_percent_ = value;
}

// float end_percent = 3;
inline void TripLeg_TrafficSegment::clear_end_percent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_percent_ = 0;
}
inline float TripLeg_TrafficSegment::end_percent() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TrafficSegment.end_percent)
  return _internal_end_percent();
}
inline void TripLeg_TrafficSegment::set_end_percent(float value) {
  _internal_set_end_percent(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TrafficSegment.end_percent)
}
inline float TripLeg_TrafficSegment::_internal_end_percent() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_percent_;
}
inline void TripLeg_TrafficSegment::_internal_set_end_percent(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.end_percent_ = value;
}

// bool starts_segment = 4;
inline void TripLeg_TrafficSegment::clear_starts_segment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.starts_segment_ = false;
}
inline bool TripLeg_TrafficSegment::starts_segment() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TrafficSegment.starts_segment)
  return _internal_starts_segment();
}
inline void TripLeg_TrafficSegment::set_starts_segment(bool value) {
  _internal_set_starts_segment(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TrafficSegment.starts_segment)
}
inline bool TripLeg_TrafficSegment::_internal_starts_segment() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.starts_segment_;
}
inline void TripLeg_TrafficSegment::_internal_set_starts_segment(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.starts_segment_ = value;
}

// bool ends_segment = 5;
inline void TripLeg_TrafficSegment::clear_ends_segment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ends_segment_ = false;
}
inline bool TripLeg_TrafficSegment::ends_segment() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TrafficSegment.ends_segment)
  return _internal_ends_segment();
}
inline void TripLeg_TrafficSegment::set_ends_segment(bool value) {
  _internal_set_ends_segment(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TrafficSegment.ends_segment)
}
inline bool TripLeg_TrafficSegment::_internal_ends_segment() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ends_segment_;
}
inline void TripLeg_TrafficSegment::_internal_set_ends_segment(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ends_segment_ = value;
}

// -------------------------------------------------------------------

// TripLeg_Restriction

// uint32 type = 1;
inline void TripLeg_Restriction::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0u;
}
inline ::uint32_t TripLeg_Restriction::type() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Restriction.type)
  return _internal_type();
}
inline void TripLeg_Restriction::set_type(::uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Restriction.type)
}
inline ::uint32_t TripLeg_Restriction::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_;
}
inline void TripLeg_Restriction::_internal_set_type(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// TripLeg_TimeDomain

// .valhalla.TripLeg.TimeDomain.DayDowType day_dow_type = 1;
inline void TripLeg_TimeDomain::clear_day_dow_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.day_dow_type_ = 0;
}
inline ::valhalla::TripLeg_TimeDomain_DayDowType TripLeg_TimeDomain::day_dow_type() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TimeDomain.day_dow_type)
  return _internal_day_dow_type();
}
inline void TripLeg_TimeDomain::set_day_dow_type(::valhalla::TripLeg_TimeDomain_DayDowType value) {
  _internal_set_day_dow_type(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TimeDomain.day_dow_type)
}
inline ::valhalla::TripLeg_TimeDomain_DayDowType TripLeg_TimeDomain::_internal_day_dow_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::TripLeg_TimeDomain_DayDowType>(_impl_.day_dow_type_);
}
inline void TripLeg_TimeDomain::_internal_set_day_dow_type(::valhalla::TripLeg_TimeDomain_DayDowType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.day_dow_type_ = value;
}

// uint32 dow_mask = 2;
inline void TripLeg_TimeDomain::clear_dow_mask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dow_mask_ = 0u;
}
inline ::uint32_t TripLeg_TimeDomain::dow_mask() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TimeDomain.dow_mask)
  return _internal_dow_mask();
}
inline void TripLeg_TimeDomain::set_dow_mask(::uint32_t value) {
  _internal_set_dow_mask(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TimeDomain.dow_mask)
}
inline ::uint32_t TripLeg_TimeDomain::_internal_dow_mask() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dow_mask_;
}
inline void TripLeg_TimeDomain::_internal_set_dow_mask(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dow_mask_ = value;
}

// uint32 begin_hrs = 3;
inline void TripLeg_TimeDomain::clear_begin_hrs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.begin_hrs_ = 0u;
}
inline ::uint32_t TripLeg_TimeDomain::begin_hrs() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TimeDomain.begin_hrs)
  return _internal_begin_hrs();
}
inline void TripLeg_TimeDomain::set_begin_hrs(::uint32_t value) {
  _internal_set_begin_hrs(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TimeDomain.begin_hrs)
}
inline ::uint32_t TripLeg_TimeDomain::_internal_begin_hrs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.begin_hrs_;
}
inline void TripLeg_TimeDomain::_internal_set_begin_hrs(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.begin_hrs_ = value;
}

// uint32 begin_mins = 4;
inline void TripLeg_TimeDomain::clear_begin_mins() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.begin_mins_ = 0u;
}
inline ::uint32_t TripLeg_TimeDomain::begin_mins() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TimeDomain.begin_mins)
  return _internal_begin_mins();
}
inline void TripLeg_TimeDomain::set_begin_mins(::uint32_t value) {
  _internal_set_begin_mins(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TimeDomain.begin_mins)
}
inline ::uint32_t TripLeg_TimeDomain::_internal_begin_mins() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.begin_mins_;
}
inline void TripLeg_TimeDomain::_internal_set_begin_mins(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.begin_mins_ = value;
}

// uint32 begin_month = 5;
inline void TripLeg_TimeDomain::clear_begin_month() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.begin_month_ = 0u;
}
inline ::uint32_t TripLeg_TimeDomain::begin_month() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TimeDomain.begin_month)
  return _internal_begin_month();
}
inline void TripLeg_TimeDomain::set_begin_month(::uint32_t value) {
  _internal_set_begin_month(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TimeDomain.begin_month)
}
inline ::uint32_t TripLeg_TimeDomain::_internal_begin_month() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.begin_month_;
}
inline void TripLeg_TimeDomain::_internal_set_begin_month(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.begin_month_ = value;
}

// uint32 begin_day_dow = 6;
inline void TripLeg_TimeDomain::clear_begin_day_dow() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.begin_day_dow_ = 0u;
}
inline ::uint32_t TripLeg_TimeDomain::begin_day_dow() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TimeDomain.begin_day_dow)
  return _internal_begin_day_dow();
}
inline void TripLeg_TimeDomain::set_begin_day_dow(::uint32_t value) {
  _internal_set_begin_day_dow(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TimeDomain.begin_day_dow)
}
inline ::uint32_t TripLeg_TimeDomain::_internal_begin_day_dow() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.begin_day_dow_;
}
inline void TripLeg_TimeDomain::_internal_set_begin_day_dow(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.begin_day_dow_ = value;
}

// uint32 begin_week = 7;
inline void TripLeg_TimeDomain::clear_begin_week() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.begin_week_ = 0u;
}
inline ::uint32_t TripLeg_TimeDomain::begin_week() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TimeDomain.begin_week)
  return _internal_begin_week();
}
inline void TripLeg_TimeDomain::set_begin_week(::uint32_t value) {
  _internal_set_begin_week(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TimeDomain.begin_week)
}
inline ::uint32_t TripLeg_TimeDomain::_internal_begin_week() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.begin_week_;
}
inline void TripLeg_TimeDomain::_internal_set_begin_week(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.begin_week_ = value;
}

// uint32 end_hrs = 8;
inline void TripLeg_TimeDomain::clear_end_hrs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_hrs_ = 0u;
}
inline ::uint32_t TripLeg_TimeDomain::end_hrs() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TimeDomain.end_hrs)
  return _internal_end_hrs();
}
inline void TripLeg_TimeDomain::set_end_hrs(::uint32_t value) {
  _internal_set_end_hrs(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TimeDomain.end_hrs)
}
inline ::uint32_t TripLeg_TimeDomain::_internal_end_hrs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_hrs_;
}
inline void TripLeg_TimeDomain::_internal_set_end_hrs(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.end_hrs_ = value;
}

// uint32 end_mins = 9;
inline void TripLeg_TimeDomain::clear_end_mins() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_mins_ = 0u;
}
inline ::uint32_t TripLeg_TimeDomain::end_mins() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TimeDomain.end_mins)
  return _internal_end_mins();
}
inline void TripLeg_TimeDomain::set_end_mins(::uint32_t value) {
  _internal_set_end_mins(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TimeDomain.end_mins)
}
inline ::uint32_t TripLeg_TimeDomain::_internal_end_mins() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_mins_;
}
inline void TripLeg_TimeDomain::_internal_set_end_mins(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.end_mins_ = value;
}

// uint32 end_month = 10;
inline void TripLeg_TimeDomain::clear_end_month() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_month_ = 0u;
}
inline ::uint32_t TripLeg_TimeDomain::end_month() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TimeDomain.end_month)
  return _internal_end_month();
}
inline void TripLeg_TimeDomain::set_end_month(::uint32_t value) {
  _internal_set_end_month(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TimeDomain.end_month)
}
inline ::uint32_t TripLeg_TimeDomain::_internal_end_month() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_month_;
}
inline void TripLeg_TimeDomain::_internal_set_end_month(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.end_month_ = value;
}

// uint32 end_day_dow = 11;
inline void TripLeg_TimeDomain::clear_end_day_dow() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_day_dow_ = 0u;
}
inline ::uint32_t TripLeg_TimeDomain::end_day_dow() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TimeDomain.end_day_dow)
  return _internal_end_day_dow();
}
inline void TripLeg_TimeDomain::set_end_day_dow(::uint32_t value) {
  _internal_set_end_day_dow(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TimeDomain.end_day_dow)
}
inline ::uint32_t TripLeg_TimeDomain::_internal_end_day_dow() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_day_dow_;
}
inline void TripLeg_TimeDomain::_internal_set_end_day_dow(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.end_day_dow_ = value;
}

// uint32 end_week = 12;
inline void TripLeg_TimeDomain::clear_end_week() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_week_ = 0u;
}
inline ::uint32_t TripLeg_TimeDomain::end_week() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.TimeDomain.end_week)
  return _internal_end_week();
}
inline void TripLeg_TimeDomain::set_end_week(::uint32_t value) {
  _internal_set_end_week(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.TimeDomain.end_week)
}
inline ::uint32_t TripLeg_TimeDomain::_internal_end_week() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_week_;
}
inline void TripLeg_TimeDomain::_internal_set_end_week(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.end_week_ = value;
}

// -------------------------------------------------------------------

// TripLeg_ConditionalSpeedLimit

// uint32 speed_limit = 1;
inline void TripLeg_ConditionalSpeedLimit::clear_speed_limit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.speed_limit_ = 0u;
}
inline ::uint32_t TripLeg_ConditionalSpeedLimit::speed_limit() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.ConditionalSpeedLimit.speed_limit)
  return _internal_speed_limit();
}
inline void TripLeg_ConditionalSpeedLimit::set_speed_limit(::uint32_t value) {
  _internal_set_speed_limit(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.ConditionalSpeedLimit.speed_limit)
}
inline ::uint32_t TripLeg_ConditionalSpeedLimit::_internal_speed_limit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.speed_limit_;
}
inline void TripLeg_ConditionalSpeedLimit::_internal_set_speed_limit(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.speed_limit_ = value;
}

// .valhalla.TripLeg.TimeDomain condition = 2;
inline bool TripLeg_ConditionalSpeedLimit::has_condition() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.condition_ != nullptr);
  return value;
}
inline void TripLeg_ConditionalSpeedLimit::clear_condition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.condition_ != nullptr) _impl_.condition_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::valhalla::TripLeg_TimeDomain& TripLeg_ConditionalSpeedLimit::_internal_condition() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::TripLeg_TimeDomain* p = _impl_.condition_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TripLeg_TimeDomain&>(::valhalla::_TripLeg_TimeDomain_default_instance_);
}
inline const ::valhalla::TripLeg_TimeDomain& TripLeg_ConditionalSpeedLimit::condition() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.ConditionalSpeedLimit.condition)
  return _internal_condition();
}
inline void TripLeg_ConditionalSpeedLimit::unsafe_arena_set_allocated_condition(::valhalla::TripLeg_TimeDomain* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.condition_);
  }
  _impl_.condition_ = reinterpret_cast<::valhalla::TripLeg_TimeDomain*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.ConditionalSpeedLimit.condition)
}
inline ::valhalla::TripLeg_TimeDomain* TripLeg_ConditionalSpeedLimit::release_condition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::TripLeg_TimeDomain* released = _impl_.condition_;
  _impl_.condition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::TripLeg_TimeDomain* TripLeg_ConditionalSpeedLimit::unsafe_arena_release_condition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.ConditionalSpeedLimit.condition)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::TripLeg_TimeDomain* temp = _impl_.condition_;
  _impl_.condition_ = nullptr;
  return temp;
}
inline ::valhalla::TripLeg_TimeDomain* TripLeg_ConditionalSpeedLimit::_internal_mutable_condition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.condition_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TripLeg_TimeDomain>(GetArena());
    _impl_.condition_ = reinterpret_cast<::valhalla::TripLeg_TimeDomain*>(p);
  }
  return _impl_.condition_;
}
inline ::valhalla::TripLeg_TimeDomain* TripLeg_ConditionalSpeedLimit::mutable_condition() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::TripLeg_TimeDomain* _msg = _internal_mutable_condition();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.ConditionalSpeedLimit.condition)
  return _msg;
}
inline void TripLeg_ConditionalSpeedLimit::set_allocated_condition(::valhalla::TripLeg_TimeDomain* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::valhalla::TripLeg_TimeDomain*>(_impl_.condition_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::valhalla::TripLeg_TimeDomain*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.condition_ = reinterpret_cast<::valhalla::TripLeg_TimeDomain*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.ConditionalSpeedLimit.condition)
}

// -------------------------------------------------------------------

// TripLeg_Edge

// repeated .valhalla.StreetName name = 1;
inline int TripLeg_Edge::_internal_name_size() const {
  return _internal_name().size();
}
inline int TripLeg_Edge::name_size() const {
  return _internal_name_size();
}
inline ::valhalla::StreetName* TripLeg_Edge::mutable_name(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.name)
  return _internal_mutable_name()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>* TripLeg_Edge::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Edge.name)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_name();
}
inline const ::valhalla::StreetName& TripLeg_Edge::name(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.name)
  return _internal_name().Get(index);
}
inline ::valhalla::StreetName* TripLeg_Edge::add_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::StreetName* _add = _internal_mutable_name()->Add();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Edge.name)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>& TripLeg_Edge::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Edge.name)
  return _internal_name();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>&
TripLeg_Edge::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>*
TripLeg_Edge::_internal_mutable_name() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.name_;
}

// float length_km = 2;
inline void TripLeg_Edge::clear_length_km() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.length_km_ = 0;
}
inline float TripLeg_Edge::length_km() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.length_km)
  return _internal_length_km();
}
inline void TripLeg_Edge::set_length_km(float value) {
  _internal_set_length_km(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.length_km)
}
inline float TripLeg_Edge::_internal_length_km() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.length_km_;
}
inline void TripLeg_Edge::_internal_set_length_km(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.length_km_ = value;
}

// float speed = 3;
inline void TripLeg_Edge::clear_speed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.speed_ = 0;
}
inline float TripLeg_Edge::speed() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.speed)
  return _internal_speed();
}
inline void TripLeg_Edge::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.speed)
}
inline float TripLeg_Edge::_internal_speed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.speed_;
}
inline void TripLeg_Edge::_internal_set_speed(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.speed_ = value;
}

// .valhalla.RoadClass road_class = 4;
inline void TripLeg_Edge::clear_road_class() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.road_class_ = 0;
}
inline ::valhalla::RoadClass TripLeg_Edge::road_class() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.road_class)
  return _internal_road_class();
}
inline void TripLeg_Edge::set_road_class(::valhalla::RoadClass value) {
  _internal_set_road_class(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.road_class)
}
inline ::valhalla::RoadClass TripLeg_Edge::_internal_road_class() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::RoadClass>(_impl_.road_class_);
}
inline void TripLeg_Edge::_internal_set_road_class(::valhalla::RoadClass value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.road_class_ = value;
}

// uint32 begin_heading = 5;
inline void TripLeg_Edge::clear_begin_heading() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.begin_heading_ = 0u;
}
inline ::uint32_t TripLeg_Edge::begin_heading() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.begin_heading)
  return _internal_begin_heading();
}
inline void TripLeg_Edge::set_begin_heading(::uint32_t value) {
  _internal_set_begin_heading(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.begin_heading)
}
inline ::uint32_t TripLeg_Edge::_internal_begin_heading() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.begin_heading_;
}
inline void TripLeg_Edge::_internal_set_begin_heading(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.begin_heading_ = value;
}

// uint32 end_heading = 6;
inline void TripLeg_Edge::clear_end_heading() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_heading_ = 0u;
}
inline ::uint32_t TripLeg_Edge::end_heading() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.end_heading)
  return _internal_end_heading();
}
inline void TripLeg_Edge::set_end_heading(::uint32_t value) {
  _internal_set_end_heading(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.end_heading)
}
inline ::uint32_t TripLeg_Edge::_internal_end_heading() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_heading_;
}
inline void TripLeg_Edge::_internal_set_end_heading(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.end_heading_ = value;
}

// uint32 begin_shape_index = 7;
inline void TripLeg_Edge::clear_begin_shape_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.begin_shape_index_ = 0u;
}
inline ::uint32_t TripLeg_Edge::begin_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.begin_shape_index)
  return _internal_begin_shape_index();
}
inline void TripLeg_Edge::set_begin_shape_index(::uint32_t value) {
  _internal_set_begin_shape_index(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.begin_shape_index)
}
inline ::uint32_t TripLeg_Edge::_internal_begin_shape_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.begin_shape_index_;
}
inline void TripLeg_Edge::_internal_set_begin_shape_index(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.begin_shape_index_ = value;
}

// uint32 end_shape_index = 8;
inline void TripLeg_Edge::clear_end_shape_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_shape_index_ = 0u;
}
inline ::uint32_t TripLeg_Edge::end_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.end_shape_index)
  return _internal_end_shape_index();
}
inline void TripLeg_Edge::set_end_shape_index(::uint32_t value) {
  _internal_set_end_shape_index(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.end_shape_index)
}
inline ::uint32_t TripLeg_Edge::_internal_end_shape_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_shape_index_;
}
inline void TripLeg_Edge::_internal_set_end_shape_index(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.end_shape_index_ = value;
}

// .valhalla.TripLeg.Traversability traversability = 9;
inline void TripLeg_Edge::clear_traversability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.traversability_ = 0;
}
inline ::valhalla::TripLeg_Traversability TripLeg_Edge::traversability() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.traversability)
  return _internal_traversability();
}
inline void TripLeg_Edge::set_traversability(::valhalla::TripLeg_Traversability value) {
  _internal_set_traversability(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.traversability)
}
inline ::valhalla::TripLeg_Traversability TripLeg_Edge::_internal_traversability() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::TripLeg_Traversability>(_impl_.traversability_);
}
inline void TripLeg_Edge::_internal_set_traversability(::valhalla::TripLeg_Traversability value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.traversability_ = value;
}

// .valhalla.TripLeg.Use use = 10;
inline void TripLeg_Edge::clear_use() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_ = 0;
}
inline ::valhalla::TripLeg_Use TripLeg_Edge::use() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.use)
  return _internal_use();
}
inline void TripLeg_Edge::set_use(::valhalla::TripLeg_Use value) {
  _internal_set_use(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.use)
}
inline ::valhalla::TripLeg_Use TripLeg_Edge::_internal_use() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::TripLeg_Use>(_impl_.use_);
}
inline void TripLeg_Edge::_internal_set_use(::valhalla::TripLeg_Use value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.use_ = value;
}

// bool toll = 11;
inline void TripLeg_Edge::clear_toll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.toll_ = false;
}
inline bool TripLeg_Edge::toll() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.toll)
  return _internal_toll();
}
inline void TripLeg_Edge::set_toll(bool value) {
  _internal_set_toll(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.toll)
}
inline bool TripLeg_Edge::_internal_toll() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.toll_;
}
inline void TripLeg_Edge::_internal_set_toll(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.toll_ = value;
}

// bool unpaved = 12;
inline void TripLeg_Edge::clear_unpaved() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.unpaved_ = false;
}
inline bool TripLeg_Edge::unpaved() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.unpaved)
  return _internal_unpaved();
}
inline void TripLeg_Edge::set_unpaved(bool value) {
  _internal_set_unpaved(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.unpaved)
}
inline bool TripLeg_Edge::_internal_unpaved() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.unpaved_;
}
inline void TripLeg_Edge::_internal_set_unpaved(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.unpaved_ = value;
}

// bool tunnel = 13;
inline void TripLeg_Edge::clear_tunnel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tunnel_ = false;
}
inline bool TripLeg_Edge::tunnel() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.tunnel)
  return _internal_tunnel();
}
inline void TripLeg_Edge::set_tunnel(bool value) {
  _internal_set_tunnel(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.tunnel)
}
inline bool TripLeg_Edge::_internal_tunnel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tunnel_;
}
inline void TripLeg_Edge::_internal_set_tunnel(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tunnel_ = value;
}

// bool bridge = 14;
inline void TripLeg_Edge::clear_bridge() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bridge_ = false;
}
inline bool TripLeg_Edge::bridge() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.bridge)
  return _internal_bridge();
}
inline void TripLeg_Edge::set_bridge(bool value) {
  _internal_set_bridge(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.bridge)
}
inline bool TripLeg_Edge::_internal_bridge() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bridge_;
}
inline void TripLeg_Edge::_internal_set_bridge(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.bridge_ = value;
}

// bool roundabout = 15;
inline void TripLeg_Edge::clear_roundabout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.roundabout_ = false;
}
inline bool TripLeg_Edge::roundabout() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.roundabout)
  return _internal_roundabout();
}
inline void TripLeg_Edge::set_roundabout(bool value) {
  _internal_set_roundabout(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.roundabout)
}
inline bool TripLeg_Edge::_internal_roundabout() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.roundabout_;
}
inline void TripLeg_Edge::_internal_set_roundabout(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.roundabout_ = value;
}

// bool internal_intersection = 16;
inline void TripLeg_Edge::clear_internal_intersection() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.internal_intersection_ = false;
}
inline bool TripLeg_Edge::internal_intersection() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.internal_intersection)
  return _internal_internal_intersection();
}
inline void TripLeg_Edge::set_internal_intersection(bool value) {
  _internal_set_internal_intersection(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.internal_intersection)
}
inline bool TripLeg_Edge::_internal_internal_intersection() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.internal_intersection_;
}
inline void TripLeg_Edge::_internal_set_internal_intersection(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.internal_intersection_ = value;
}

// bool drive_on_left = 17;
inline void TripLeg_Edge::clear_drive_on_left() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.drive_on_left_ = false;
}
inline bool TripLeg_Edge::drive_on_left() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.drive_on_left)
  return _internal_drive_on_left();
}
inline void TripLeg_Edge::set_drive_on_left(bool value) {
  _internal_set_drive_on_left(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.drive_on_left)
}
inline bool TripLeg_Edge::_internal_drive_on_left() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.drive_on_left_;
}
inline void TripLeg_Edge::_internal_set_drive_on_left(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.drive_on_left_ = value;
}

// .valhalla.TripLeg.Surface surface = 18;
inline void TripLeg_Edge::clear_surface() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.surface_ = 0;
}
inline ::valhalla::TripLeg_Surface TripLeg_Edge::surface() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.surface)
  return _internal_surface();
}
inline void TripLeg_Edge::set_surface(::valhalla::TripLeg_Surface value) {
  _internal_set_surface(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.surface)
}
inline ::valhalla::TripLeg_Surface TripLeg_Edge::_internal_surface() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::TripLeg_Surface>(_impl_.surface_);
}
inline void TripLeg_Edge::_internal_set_surface(::valhalla::TripLeg_Surface value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.surface_ = value;
}

// .valhalla.TripSign sign = 19;
inline bool TripLeg_Edge::has_sign() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sign_ != nullptr);
  return value;
}
inline const ::valhalla::TripSign& TripLeg_Edge::_internal_sign() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::TripSign* p = _impl_.sign_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TripSign&>(::valhalla::_TripSign_default_instance_);
}
inline const ::valhalla::TripSign& TripLeg_Edge::sign() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.sign)
  return _internal_sign();
}
inline void TripLeg_Edge::unsafe_arena_set_allocated_sign(::valhalla::TripSign* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sign_);
  }
  _impl_.sign_ = reinterpret_cast<::valhalla::TripSign*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.Edge.sign)
}
inline ::valhalla::TripSign* TripLeg_Edge::release_sign() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::TripSign* released = _impl_.sign_;
  _impl_.sign_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::TripSign* TripLeg_Edge::unsafe_arena_release_sign() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Edge.sign)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::TripSign* temp = _impl_.sign_;
  _impl_.sign_ = nullptr;
  return temp;
}
inline ::valhalla::TripSign* TripLeg_Edge::_internal_mutable_sign() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.sign_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TripSign>(GetArena());
    _impl_.sign_ = reinterpret_cast<::valhalla::TripSign*>(p);
  }
  return _impl_.sign_;
}
inline ::valhalla::TripSign* TripLeg_Edge::mutable_sign() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::TripSign* _msg = _internal_mutable_sign();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.sign)
  return _msg;
}
inline void TripLeg_Edge::set_allocated_sign(::valhalla::TripSign* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sign_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.sign_ = reinterpret_cast<::valhalla::TripSign*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Edge.sign)
}

// .valhalla.TravelMode travel_mode = 20;
inline void TripLeg_Edge::clear_travel_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.travel_mode_ = 0;
}
inline ::valhalla::TravelMode TripLeg_Edge::travel_mode() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.travel_mode)
  return _internal_travel_mode();
}
inline void TripLeg_Edge::set_travel_mode(::valhalla::TravelMode value) {
  _internal_set_travel_mode(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.travel_mode)
}
inline ::valhalla::TravelMode TripLeg_Edge::_internal_travel_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::TravelMode>(_impl_.travel_mode_);
}
inline void TripLeg_Edge::_internal_set_travel_mode(::valhalla::TravelMode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.travel_mode_ = value;
}

// .valhalla.VehicleType vehicle_type = 21;
inline void TripLeg_Edge::clear_vehicle_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vehicle_type_ = 0;
}
inline ::valhalla::VehicleType TripLeg_Edge::vehicle_type() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.vehicle_type)
  return _internal_vehicle_type();
}
inline void TripLeg_Edge::set_vehicle_type(::valhalla::VehicleType value) {
  _internal_set_vehicle_type(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.vehicle_type)
}
inline ::valhalla::VehicleType TripLeg_Edge::_internal_vehicle_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::VehicleType>(_impl_.vehicle_type_);
}
inline void TripLeg_Edge::_internal_set_vehicle_type(::valhalla::VehicleType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.vehicle_type_ = value;
}

// .valhalla.PedestrianType pedestrian_type = 22;
inline void TripLeg_Edge::clear_pedestrian_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pedestrian_type_ = 0;
}
inline ::valhalla::PedestrianType TripLeg_Edge::pedestrian_type() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.pedestrian_type)
  return _internal_pedestrian_type();
}
inline void TripLeg_Edge::set_pedestrian_type(::valhalla::PedestrianType value) {
  _internal_set_pedestrian_type(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.pedestrian_type)
}
inline ::valhalla::PedestrianType TripLeg_Edge::_internal_pedestrian_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::PedestrianType>(_impl_.pedestrian_type_);
}
inline void TripLeg_Edge::_internal_set_pedestrian_type(::valhalla::PedestrianType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pedestrian_type_ = value;
}

// .valhalla.BicycleType bicycle_type = 23;
inline void TripLeg_Edge::clear_bicycle_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bicycle_type_ = 0;
}
inline ::valhalla::BicycleType TripLeg_Edge::bicycle_type() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.bicycle_type)
  return _internal_bicycle_type();
}
inline void TripLeg_Edge::set_bicycle_type(::valhalla::BicycleType value) {
  _internal_set_bicycle_type(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.bicycle_type)
}
inline ::valhalla::BicycleType TripLeg_Edge::_internal_bicycle_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::BicycleType>(_impl_.bicycle_type_);
}
inline void TripLeg_Edge::_internal_set_bicycle_type(::valhalla::BicycleType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.bicycle_type_ = value;
}

// .valhalla.TransitType transit_type = 24;
inline void TripLeg_Edge::clear_transit_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.transit_type_ = 0;
}
inline ::valhalla::TransitType TripLeg_Edge::transit_type() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.transit_type)
  return _internal_transit_type();
}
inline void TripLeg_Edge::set_transit_type(::valhalla::TransitType value) {
  _internal_set_transit_type(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.transit_type)
}
inline ::valhalla::TransitType TripLeg_Edge::_internal_transit_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::TransitType>(_impl_.transit_type_);
}
inline void TripLeg_Edge::_internal_set_transit_type(::valhalla::TransitType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.transit_type_ = value;
}

// .valhalla.TransitRouteInfo transit_route_info = 25;
inline bool TripLeg_Edge::has_transit_route_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transit_route_info_ != nullptr);
  return value;
}
inline const ::valhalla::TransitRouteInfo& TripLeg_Edge::_internal_transit_route_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::TransitRouteInfo* p = _impl_.transit_route_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TransitRouteInfo&>(::valhalla::_TransitRouteInfo_default_instance_);
}
inline const ::valhalla::TransitRouteInfo& TripLeg_Edge::transit_route_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.transit_route_info)
  return _internal_transit_route_info();
}
inline void TripLeg_Edge::unsafe_arena_set_allocated_transit_route_info(::valhalla::TransitRouteInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transit_route_info_);
  }
  _impl_.transit_route_info_ = reinterpret_cast<::valhalla::TransitRouteInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.Edge.transit_route_info)
}
inline ::valhalla::TransitRouteInfo* TripLeg_Edge::release_transit_route_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::valhalla::TransitRouteInfo* released = _impl_.transit_route_info_;
  _impl_.transit_route_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::TransitRouteInfo* TripLeg_Edge::unsafe_arena_release_transit_route_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Edge.transit_route_info)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::valhalla::TransitRouteInfo* temp = _impl_.transit_route_info_;
  _impl_.transit_route_info_ = nullptr;
  return temp;
}
inline ::valhalla::TransitRouteInfo* TripLeg_Edge::_internal_mutable_transit_route_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.transit_route_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TransitRouteInfo>(GetArena());
    _impl_.transit_route_info_ = reinterpret_cast<::valhalla::TransitRouteInfo*>(p);
  }
  return _impl_.transit_route_info_;
}
inline ::valhalla::TransitRouteInfo* TripLeg_Edge::mutable_transit_route_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::TransitRouteInfo* _msg = _internal_mutable_transit_route_info();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.transit_route_info)
  return _msg;
}
inline void TripLeg_Edge::set_allocated_transit_route_info(::valhalla::TransitRouteInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transit_route_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.transit_route_info_ = reinterpret_cast<::valhalla::TransitRouteInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Edge.transit_route_info)
}

// uint64 id = 26;
inline void TripLeg_Edge::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t TripLeg_Edge::id() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.id)
  return _internal_id();
}
inline void TripLeg_Edge::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.id)
}
inline ::uint64_t TripLeg_Edge::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void TripLeg_Edge::_internal_set_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// uint64 way_id = 27;
inline void TripLeg_Edge::clear_way_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.way_id_ = ::uint64_t{0u};
}
inline ::uint64_t TripLeg_Edge::way_id() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.way_id)
  return _internal_way_id();
}
inline void TripLeg_Edge::set_way_id(::uint64_t value) {
  _internal_set_way_id(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.way_id)
}
inline ::uint64_t TripLeg_Edge::_internal_way_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.way_id_;
}
inline void TripLeg_Edge::_internal_set_way_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.way_id_ = value;
}

// float weighted_grade = 28;
inline void TripLeg_Edge::clear_weighted_grade() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.weighted_grade_ = 0;
}
inline float TripLeg_Edge::weighted_grade() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.weighted_grade)
  return _internal_weighted_grade();
}
inline void TripLeg_Edge::set_weighted_grade(float value) {
  _internal_set_weighted_grade(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.weighted_grade)
}
inline float TripLeg_Edge::_internal_weighted_grade() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.weighted_grade_;
}
inline void TripLeg_Edge::_internal_set_weighted_grade(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.weighted_grade_ = value;
}

// int32 max_upward_grade = 29;
inline void TripLeg_Edge::clear_max_upward_grade() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_upward_grade_ = 0;
}
inline ::int32_t TripLeg_Edge::max_upward_grade() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.max_upward_grade)
  return _internal_max_upward_grade();
}
inline void TripLeg_Edge::set_max_upward_grade(::int32_t value) {
  _internal_set_max_upward_grade(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.max_upward_grade)
}
inline ::int32_t TripLeg_Edge::_internal_max_upward_grade() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_upward_grade_;
}
inline void TripLeg_Edge::_internal_set_max_upward_grade(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_upward_grade_ = value;
}

// int32 max_downward_grade = 30;
inline void TripLeg_Edge::clear_max_downward_grade() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_downward_grade_ = 0;
}
inline ::int32_t TripLeg_Edge::max_downward_grade() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.max_downward_grade)
  return _internal_max_downward_grade();
}
inline void TripLeg_Edge::set_max_downward_grade(::int32_t value) {
  _internal_set_max_downward_grade(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.max_downward_grade)
}
inline ::int32_t TripLeg_Edge::_internal_max_downward_grade() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_downward_grade_;
}
inline void TripLeg_Edge::_internal_set_max_downward_grade(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_downward_grade_ = value;
}

// uint32 lane_count = 31;
inline void TripLeg_Edge::clear_lane_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lane_count_ = 0u;
}
inline ::uint32_t TripLeg_Edge::lane_count() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.lane_count)
  return _internal_lane_count();
}
inline void TripLeg_Edge::set_lane_count(::uint32_t value) {
  _internal_set_lane_count(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.lane_count)
}
inline ::uint32_t TripLeg_Edge::_internal_lane_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lane_count_;
}
inline void TripLeg_Edge::_internal_set_lane_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.lane_count_ = value;
}

// .valhalla.TripLeg.CycleLane cycle_lane = 32;
inline void TripLeg_Edge::clear_cycle_lane() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cycle_lane_ = 0;
}
inline ::valhalla::TripLeg_CycleLane TripLeg_Edge::cycle_lane() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.cycle_lane)
  return _internal_cycle_lane();
}
inline void TripLeg_Edge::set_cycle_lane(::valhalla::TripLeg_CycleLane value) {
  _internal_set_cycle_lane(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.cycle_lane)
}
inline ::valhalla::TripLeg_CycleLane TripLeg_Edge::_internal_cycle_lane() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::TripLeg_CycleLane>(_impl_.cycle_lane_);
}
inline void TripLeg_Edge::_internal_set_cycle_lane(::valhalla::TripLeg_CycleLane value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cycle_lane_ = value;
}

// bool bicycle_network = 33;
inline void TripLeg_Edge::clear_bicycle_network() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bicycle_network_ = false;
}
inline bool TripLeg_Edge::bicycle_network() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.bicycle_network)
  return _internal_bicycle_network();
}
inline void TripLeg_Edge::set_bicycle_network(bool value) {
  _internal_set_bicycle_network(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.bicycle_network)
}
inline bool TripLeg_Edge::_internal_bicycle_network() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bicycle_network_;
}
inline void TripLeg_Edge::_internal_set_bicycle_network(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.bicycle_network_ = value;
}

// .valhalla.TripLeg.Sidewalk sidewalk = 34;
inline void TripLeg_Edge::clear_sidewalk() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sidewalk_ = 0;
}
inline ::valhalla::TripLeg_Sidewalk TripLeg_Edge::sidewalk() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.sidewalk)
  return _internal_sidewalk();
}
inline void TripLeg_Edge::set_sidewalk(::valhalla::TripLeg_Sidewalk value) {
  _internal_set_sidewalk(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.sidewalk)
}
inline ::valhalla::TripLeg_Sidewalk TripLeg_Edge::_internal_sidewalk() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::TripLeg_Sidewalk>(_impl_.sidewalk_);
}
inline void TripLeg_Edge::_internal_set_sidewalk(::valhalla::TripLeg_Sidewalk value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sidewalk_ = value;
}

// uint32 density = 35;
inline void TripLeg_Edge::clear_density() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.density_ = 0u;
}
inline ::uint32_t TripLeg_Edge::density() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.density)
  return _internal_density();
}
inline void TripLeg_Edge::set_density(::uint32_t value) {
  _internal_set_density(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.density)
}
inline ::uint32_t TripLeg_Edge::_internal_density() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.density_;
}
inline void TripLeg_Edge::_internal_set_density(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.density_ = value;
}

// uint32 speed_limit = 36;
inline void TripLeg_Edge::clear_speed_limit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.speed_limit_ = 0u;
}
inline ::uint32_t TripLeg_Edge::speed_limit() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.speed_limit)
  return _internal_speed_limit();
}
inline void TripLeg_Edge::set_speed_limit(::uint32_t value) {
  _internal_set_speed_limit(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.speed_limit)
}
inline ::uint32_t TripLeg_Edge::_internal_speed_limit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.speed_limit_;
}
inline void TripLeg_Edge::_internal_set_speed_limit(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.speed_limit_ = value;
}

// float truck_speed = 37;
inline void TripLeg_Edge::clear_truck_speed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.truck_speed_ = 0;
}
inline float TripLeg_Edge::truck_speed() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.truck_speed)
  return _internal_truck_speed();
}
inline void TripLeg_Edge::set_truck_speed(float value) {
  _internal_set_truck_speed(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.truck_speed)
}
inline float TripLeg_Edge::_internal_truck_speed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.truck_speed_;
}
inline void TripLeg_Edge::_internal_set_truck_speed(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.truck_speed_ = value;
}

// bool truck_route = 38;
inline void TripLeg_Edge::clear_truck_route() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.truck_route_ = false;
}
inline bool TripLeg_Edge::truck_route() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.truck_route)
  return _internal_truck_route();
}
inline void TripLeg_Edge::set_truck_route(bool value) {
  _internal_set_truck_route(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.truck_route)
}
inline bool TripLeg_Edge::_internal_truck_route() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.truck_route_;
}
inline void TripLeg_Edge::_internal_set_truck_route(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.truck_route_ = value;
}

// repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
inline int TripLeg_Edge::_internal_lane_connectivity_size() const {
  return _internal_lane_connectivity().size();
}
inline int TripLeg_Edge::lane_connectivity_size() const {
  return _internal_lane_connectivity_size();
}
inline void TripLeg_Edge::clear_lane_connectivity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lane_connectivity_.Clear();
}
inline ::valhalla::TripLeg_LaneConnectivity* TripLeg_Edge::mutable_lane_connectivity(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.lane_connectivity)
  return _internal_mutable_lane_connectivity()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_LaneConnectivity>* TripLeg_Edge::mutable_lane_connectivity()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Edge.lane_connectivity)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_lane_connectivity();
}
inline const ::valhalla::TripLeg_LaneConnectivity& TripLeg_Edge::lane_connectivity(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.lane_connectivity)
  return _internal_lane_connectivity().Get(index);
}
inline ::valhalla::TripLeg_LaneConnectivity* TripLeg_Edge::add_lane_connectivity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::TripLeg_LaneConnectivity* _add = _internal_mutable_lane_connectivity()->Add();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Edge.lane_connectivity)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_LaneConnectivity>& TripLeg_Edge::lane_connectivity() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Edge.lane_connectivity)
  return _internal_lane_connectivity();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_LaneConnectivity>&
TripLeg_Edge::_internal_lane_connectivity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lane_connectivity_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_LaneConnectivity>*
TripLeg_Edge::_internal_mutable_lane_connectivity() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.lane_connectivity_;
}

// int32 mean_elevation = 40;
inline void TripLeg_Edge::clear_mean_elevation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mean_elevation_ = 0;
}
inline ::int32_t TripLeg_Edge::mean_elevation() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.mean_elevation)
  return _internal_mean_elevation();
}
inline void TripLeg_Edge::set_mean_elevation(::int32_t value) {
  _internal_set_mean_elevation(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.mean_elevation)
}
inline ::int32_t TripLeg_Edge::_internal_mean_elevation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mean_elevation_;
}
inline void TripLeg_Edge::_internal_set_mean_elevation(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mean_elevation_ = value;
}

// repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
inline int TripLeg_Edge::_internal_traffic_segment_size() const {
  return _internal_traffic_segment().size();
}
inline int TripLeg_Edge::traffic_segment_size() const {
  return _internal_traffic_segment_size();
}
inline void TripLeg_Edge::clear_traffic_segment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.traffic_segment_.Clear();
}
inline ::valhalla::TripLeg_TrafficSegment* TripLeg_Edge::mutable_traffic_segment(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.traffic_segment)
  return _internal_mutable_traffic_segment()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_TrafficSegment>* TripLeg_Edge::mutable_traffic_segment()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Edge.traffic_segment)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_traffic_segment();
}
inline const ::valhalla::TripLeg_TrafficSegment& TripLeg_Edge::traffic_segment(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.traffic_segment)
  return _internal_traffic_segment().Get(index);
}
inline ::valhalla::TripLeg_TrafficSegment* TripLeg_Edge::add_traffic_segment() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::TripLeg_TrafficSegment* _add = _internal_mutable_traffic_segment()->Add();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Edge.traffic_segment)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_TrafficSegment>& TripLeg_Edge::traffic_segment() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Edge.traffic_segment)
  return _internal_traffic_segment();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_TrafficSegment>&
TripLeg_Edge::_internal_traffic_segment() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.traffic_segment_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_TrafficSegment>*
TripLeg_Edge::_internal_mutable_traffic_segment() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.traffic_segment_;
}

// repeated .valhalla.TurnLane turn_lanes = 42;
inline int TripLeg_Edge::_internal_turn_lanes_size() const {
  return _internal_turn_lanes().size();
}
inline int TripLeg_Edge::turn_lanes_size() const {
  return _internal_turn_lanes_size();
}
inline ::valhalla::TurnLane* TripLeg_Edge::mutable_turn_lanes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.turn_lanes)
  return _internal_mutable_turn_lanes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::TurnLane>* TripLeg_Edge::mutable_turn_lanes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Edge.turn_lanes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_turn_lanes();
}
inline const ::valhalla::TurnLane& TripLeg_Edge::turn_lanes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.turn_lanes)
  return _internal_turn_lanes().Get(index);
}
inline ::valhalla::TurnLane* TripLeg_Edge::add_turn_lanes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::TurnLane* _add = _internal_mutable_turn_lanes()->Add();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Edge.turn_lanes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::TurnLane>& TripLeg_Edge::turn_lanes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Edge.turn_lanes)
  return _internal_turn_lanes();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::TurnLane>&
TripLeg_Edge::_internal_turn_lanes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.turn_lanes_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::TurnLane>*
TripLeg_Edge::_internal_mutable_turn_lanes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.turn_lanes_;
}

// bool has_time_restrictions = 43;
inline void TripLeg_Edge::clear_has_time_restrictions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.has_time_restrictions_ = false;
}
inline bool TripLeg_Edge::has_time_restrictions() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.has_time_restrictions)
  return _internal_has_time_restrictions();
}
inline void TripLeg_Edge::set_has_time_restrictions(bool value) {
  _internal_set_has_time_restrictions(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.has_time_restrictions)
}
inline bool TripLeg_Edge::_internal_has_time_restrictions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.has_time_restrictions_;
}
inline void TripLeg_Edge::_internal_set_has_time_restrictions(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.has_time_restrictions_ = value;
}

// float default_speed = 44;
inline void TripLeg_Edge::clear_default_speed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.default_speed_ = 0;
}
inline float TripLeg_Edge::default_speed() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.default_speed)
  return _internal_default_speed();
}
inline void TripLeg_Edge::set_default_speed(float value) {
  _internal_set_default_speed(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.default_speed)
}
inline float TripLeg_Edge::_internal_default_speed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.default_speed_;
}
inline void TripLeg_Edge::_internal_set_default_speed(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.default_speed_ = value;
}

// .valhalla.TripLeg.Restriction restriction = 45;
inline bool TripLeg_Edge::has_restriction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.restriction_ != nullptr);
  return value;
}
inline void TripLeg_Edge::clear_restriction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.restriction_ != nullptr) _impl_.restriction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::valhalla::TripLeg_Restriction& TripLeg_Edge::_internal_restriction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::TripLeg_Restriction* p = _impl_.restriction_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TripLeg_Restriction&>(::valhalla::_TripLeg_Restriction_default_instance_);
}
inline const ::valhalla::TripLeg_Restriction& TripLeg_Edge::restriction() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.restriction)
  return _internal_restriction();
}
inline void TripLeg_Edge::unsafe_arena_set_allocated_restriction(::valhalla::TripLeg_Restriction* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.restriction_);
  }
  _impl_.restriction_ = reinterpret_cast<::valhalla::TripLeg_Restriction*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.Edge.restriction)
}
inline ::valhalla::TripLeg_Restriction* TripLeg_Edge::release_restriction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::valhalla::TripLeg_Restriction* released = _impl_.restriction_;
  _impl_.restriction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::TripLeg_Restriction* TripLeg_Edge::unsafe_arena_release_restriction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Edge.restriction)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::valhalla::TripLeg_Restriction* temp = _impl_.restriction_;
  _impl_.restriction_ = nullptr;
  return temp;
}
inline ::valhalla::TripLeg_Restriction* TripLeg_Edge::_internal_mutable_restriction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.restriction_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TripLeg_Restriction>(GetArena());
    _impl_.restriction_ = reinterpret_cast<::valhalla::TripLeg_Restriction*>(p);
  }
  return _impl_.restriction_;
}
inline ::valhalla::TripLeg_Restriction* TripLeg_Edge::mutable_restriction() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::TripLeg_Restriction* _msg = _internal_mutable_restriction();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.restriction)
  return _msg;
}
inline void TripLeg_Edge::set_allocated_restriction(::valhalla::TripLeg_Restriction* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::valhalla::TripLeg_Restriction*>(_impl_.restriction_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::valhalla::TripLeg_Restriction*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.restriction_ = reinterpret_cast<::valhalla::TripLeg_Restriction*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Edge.restriction)
}

// bool destination_only = 46;
inline void TripLeg_Edge::clear_destination_only() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.destination_only_ = false;
}
inline bool TripLeg_Edge::destination_only() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.destination_only)
  return _internal_destination_only();
}
inline void TripLeg_Edge::set_destination_only(bool value) {
  _internal_set_destination_only(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.destination_only)
}
inline bool TripLeg_Edge::_internal_destination_only() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.destination_only_;
}
inline void TripLeg_Edge::_internal_set_destination_only(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.destination_only_ = value;
}

// bool is_urban = 47;
inline void TripLeg_Edge::clear_is_urban() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_urban_ = false;
}
inline bool TripLeg_Edge::is_urban() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.is_urban)
  return _internal_is_urban();
}
inline void TripLeg_Edge::set_is_urban(bool value) {
  _internal_set_is_urban(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.is_urban)
}
inline bool TripLeg_Edge::_internal_is_urban() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_urban_;
}
inline void TripLeg_Edge::_internal_set_is_urban(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_urban_ = value;
}

// repeated .valhalla.TaggedValue tagged_value = 48;
inline int TripLeg_Edge::_internal_tagged_value_size() const {
  return _internal_tagged_value().size();
}
inline int TripLeg_Edge::tagged_value_size() const {
  return _internal_tagged_value_size();
}
inline ::valhalla::TaggedValue* TripLeg_Edge::mutable_tagged_value(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.tagged_value)
  return _internal_mutable_tagged_value()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::TaggedValue>* TripLeg_Edge::mutable_tagged_value()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Edge.tagged_value)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tagged_value();
}
inline const ::valhalla::TaggedValue& TripLeg_Edge::tagged_value(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.tagged_value)
  return _internal_tagged_value().Get(index);
}
inline ::valhalla::TaggedValue* TripLeg_Edge::add_tagged_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::TaggedValue* _add = _internal_mutable_tagged_value()->Add();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Edge.tagged_value)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::TaggedValue>& TripLeg_Edge::tagged_value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Edge.tagged_value)
  return _internal_tagged_value();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::TaggedValue>&
TripLeg_Edge::_internal_tagged_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tagged_value_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::TaggedValue>*
TripLeg_Edge::_internal_mutable_tagged_value() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tagged_value_;
}

// float source_along_edge = 49;
inline void TripLeg_Edge::clear_source_along_edge() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_along_edge_ = 0;
}
inline float TripLeg_Edge::source_along_edge() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.source_along_edge)
  return _internal_source_along_edge();
}
inline void TripLeg_Edge::set_source_along_edge(float value) {
  _internal_set_source_along_edge(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.source_along_edge)
}
inline float TripLeg_Edge::_internal_source_along_edge() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.source_along_edge_;
}
inline void TripLeg_Edge::_internal_set_source_along_edge(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.source_along_edge_ = value;
}

// float target_along_edge = 50;
inline void TripLeg_Edge::clear_target_along_edge() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_along_edge_ = 0;
}
inline float TripLeg_Edge::target_along_edge() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.target_along_edge)
  return _internal_target_along_edge();
}
inline void TripLeg_Edge::set_target_along_edge(float value) {
  _internal_set_target_along_edge(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.target_along_edge)
}
inline float TripLeg_Edge::_internal_target_along_edge() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.target_along_edge_;
}
inline void TripLeg_Edge::_internal_set_target_along_edge(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_along_edge_ = value;
}

// .valhalla.TripLeg.SacScale sac_scale = 51;
inline void TripLeg_Edge::clear_sac_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sac_scale_ = 0;
}
inline ::valhalla::TripLeg_SacScale TripLeg_Edge::sac_scale() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.sac_scale)
  return _internal_sac_scale();
}
inline void TripLeg_Edge::set_sac_scale(::valhalla::TripLeg_SacScale value) {
  _internal_set_sac_scale(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.sac_scale)
}
inline ::valhalla::TripLeg_SacScale TripLeg_Edge::_internal_sac_scale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::TripLeg_SacScale>(_impl_.sac_scale_);
}
inline void TripLeg_Edge::_internal_set_sac_scale(::valhalla::TripLeg_SacScale value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sac_scale_ = value;
}

// bool shoulder = 52;
inline void TripLeg_Edge::clear_shoulder() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.shoulder_ = false;
}
inline bool TripLeg_Edge::shoulder() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.shoulder)
  return _internal_shoulder();
}
inline void TripLeg_Edge::set_shoulder(bool value) {
  _internal_set_shoulder(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.shoulder)
}
inline bool TripLeg_Edge::_internal_shoulder() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.shoulder_;
}
inline void TripLeg_Edge::_internal_set_shoulder(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.shoulder_ = value;
}

// bool indoor = 53;
inline void TripLeg_Edge::clear_indoor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.indoor_ = false;
}
inline bool TripLeg_Edge::indoor() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.indoor)
  return _internal_indoor();
}
inline void TripLeg_Edge::set_indoor(bool value) {
  _internal_set_indoor(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.indoor)
}
inline bool TripLeg_Edge::_internal_indoor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.indoor_;
}
inline void TripLeg_Edge::_internal_set_indoor(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.indoor_ = value;
}

// repeated .valhalla.RouteLandmark landmarks = 54;
inline int TripLeg_Edge::_internal_landmarks_size() const {
  return _internal_landmarks().size();
}
inline int TripLeg_Edge::landmarks_size() const {
  return _internal_landmarks_size();
}
inline ::valhalla::RouteLandmark* TripLeg_Edge::mutable_landmarks(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.landmarks)
  return _internal_mutable_landmarks()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::RouteLandmark>* TripLeg_Edge::mutable_landmarks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Edge.landmarks)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_landmarks();
}
inline const ::valhalla::RouteLandmark& TripLeg_Edge::landmarks(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.landmarks)
  return _internal_landmarks().Get(index);
}
inline ::valhalla::RouteLandmark* TripLeg_Edge::add_landmarks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::RouteLandmark* _add = _internal_mutable_landmarks()->Add();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Edge.landmarks)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::RouteLandmark>& TripLeg_Edge::landmarks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Edge.landmarks)
  return _internal_landmarks();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::RouteLandmark>&
TripLeg_Edge::_internal_landmarks() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.landmarks_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::RouteLandmark>*
TripLeg_Edge::_internal_mutable_landmarks() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.landmarks_;
}

// repeated .valhalla.StreetName tunnel_name = 55;
inline int TripLeg_Edge::_internal_tunnel_name_size() const {
  return _internal_tunnel_name().size();
}
inline int TripLeg_Edge::tunnel_name_size() const {
  return _internal_tunnel_name_size();
}
inline ::valhalla::StreetName* TripLeg_Edge::mutable_tunnel_name(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.tunnel_name)
  return _internal_mutable_tunnel_name()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>* TripLeg_Edge::mutable_tunnel_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Edge.tunnel_name)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tunnel_name();
}
inline const ::valhalla::StreetName& TripLeg_Edge::tunnel_name(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.tunnel_name)
  return _internal_tunnel_name().Get(index);
}
inline ::valhalla::StreetName* TripLeg_Edge::add_tunnel_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::StreetName* _add = _internal_mutable_tunnel_name()->Add();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Edge.tunnel_name)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>& TripLeg_Edge::tunnel_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Edge.tunnel_name)
  return _internal_tunnel_name();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>&
TripLeg_Edge::_internal_tunnel_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tunnel_name_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>*
TripLeg_Edge::_internal_mutable_tunnel_name() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tunnel_name_;
}

// float elevation_sampling_interval = 56;
inline void TripLeg_Edge::clear_elevation_sampling_interval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.elevation_sampling_interval_ = 0;
}
inline float TripLeg_Edge::elevation_sampling_interval() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.elevation_sampling_interval)
  return _internal_elevation_sampling_interval();
}
inline void TripLeg_Edge::set_elevation_sampling_interval(float value) {
  _internal_set_elevation_sampling_interval(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.elevation_sampling_interval)
}
inline float TripLeg_Edge::_internal_elevation_sampling_interval() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.elevation_sampling_interval_;
}
inline void TripLeg_Edge::_internal_set_elevation_sampling_interval(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.elevation_sampling_interval_ = value;
}

// repeated float elevation = 57;
inline int TripLeg_Edge::_internal_elevation_size() const {
  return _internal_elevation().size();
}
inline int TripLeg_Edge::elevation_size() const {
  return _internal_elevation_size();
}
inline void TripLeg_Edge::clear_elevation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.elevation_.Clear();
}
inline float TripLeg_Edge::elevation(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.elevation)
  return _internal_elevation().Get(index);
}
inline void TripLeg_Edge::set_elevation(int index, float value) {
  _internal_mutable_elevation()->Set(index, value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.elevation)
}
inline void TripLeg_Edge::add_elevation(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_elevation()->Add(value);
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Edge.elevation)
}
inline const ::google::protobuf::RepeatedField<float>& TripLeg_Edge::elevation() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Edge.elevation)
  return _internal_elevation();
}
inline ::google::protobuf::RepeatedField<float>* TripLeg_Edge::mutable_elevation()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Edge.elevation)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_elevation();
}
inline const ::google::protobuf::RepeatedField<float>& TripLeg_Edge::_internal_elevation()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.elevation_;
}
inline ::google::protobuf::RepeatedField<float>* TripLeg_Edge::_internal_mutable_elevation() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.elevation_;
}

// bool country_crossing = 58;
inline void TripLeg_Edge::clear_country_crossing() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.country_crossing_ = false;
}
inline bool TripLeg_Edge::country_crossing() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.country_crossing)
  return _internal_country_crossing();
}
inline void TripLeg_Edge::set_country_crossing(bool value) {
  _internal_set_country_crossing(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.country_crossing)
}
inline bool TripLeg_Edge::_internal_country_crossing() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.country_crossing_;
}
inline void TripLeg_Edge::_internal_set_country_crossing(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.country_crossing_ = value;
}

// bool forward = 59;
inline void TripLeg_Edge::clear_forward() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.forward_ = false;
}
inline bool TripLeg_Edge::forward() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.forward)
  return _internal_forward();
}
inline void TripLeg_Edge::set_forward(bool value) {
  _internal_set_forward(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Edge.forward)
}
inline bool TripLeg_Edge::_internal_forward() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.forward_;
}
inline void TripLeg_Edge::_internal_set_forward(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.forward_ = value;
}

// repeated .valhalla.TripLeg.ConditionalSpeedLimit conditional_speed_limits = 60;
inline int TripLeg_Edge::_internal_conditional_speed_limits_size() const {
  return _internal_conditional_speed_limits().size();
}
inline int TripLeg_Edge::conditional_speed_limits_size() const {
  return _internal_conditional_speed_limits_size();
}
inline void TripLeg_Edge::clear_conditional_speed_limits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.conditional_speed_limits_.Clear();
}
inline ::valhalla::TripLeg_ConditionalSpeedLimit* TripLeg_Edge::mutable_conditional_speed_limits(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Edge.conditional_speed_limits)
  return _internal_mutable_conditional_speed_limits()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_ConditionalSpeedLimit>* TripLeg_Edge::mutable_conditional_speed_limits()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Edge.conditional_speed_limits)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_conditional_speed_limits();
}
inline const ::valhalla::TripLeg_ConditionalSpeedLimit& TripLeg_Edge::conditional_speed_limits(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Edge.conditional_speed_limits)
  return _internal_conditional_speed_limits().Get(index);
}
inline ::valhalla::TripLeg_ConditionalSpeedLimit* TripLeg_Edge::add_conditional_speed_limits() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::TripLeg_ConditionalSpeedLimit* _add = _internal_mutable_conditional_speed_limits()->Add();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Edge.conditional_speed_limits)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_ConditionalSpeedLimit>& TripLeg_Edge::conditional_speed_limits() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Edge.conditional_speed_limits)
  return _internal_conditional_speed_limits();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_ConditionalSpeedLimit>&
TripLeg_Edge::_internal_conditional_speed_limits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.conditional_speed_limits_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_ConditionalSpeedLimit>*
TripLeg_Edge::_internal_mutable_conditional_speed_limits() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.conditional_speed_limits_;
}

// -------------------------------------------------------------------

// TripLeg_IntersectingEdge

// uint32 begin_heading = 1;
inline void TripLeg_IntersectingEdge::clear_begin_heading() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.begin_heading_ = 0u;
}
inline ::uint32_t TripLeg_IntersectingEdge::begin_heading() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.begin_heading)
  return _internal_begin_heading();
}
inline void TripLeg_IntersectingEdge::set_begin_heading(::uint32_t value) {
  _internal_set_begin_heading(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.begin_heading)
}
inline ::uint32_t TripLeg_IntersectingEdge::_internal_begin_heading() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.begin_heading_;
}
inline void TripLeg_IntersectingEdge::_internal_set_begin_heading(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.begin_heading_ = value;
}

// bool prev_name_consistency = 2;
inline void TripLeg_IntersectingEdge::clear_prev_name_consistency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.prev_name_consistency_ = false;
}
inline bool TripLeg_IntersectingEdge::prev_name_consistency() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.prev_name_consistency)
  return _internal_prev_name_consistency();
}
inline void TripLeg_IntersectingEdge::set_prev_name_consistency(bool value) {
  _internal_set_prev_name_consistency(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.prev_name_consistency)
}
inline bool TripLeg_IntersectingEdge::_internal_prev_name_consistency() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.prev_name_consistency_;
}
inline void TripLeg_IntersectingEdge::_internal_set_prev_name_consistency(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.prev_name_consistency_ = value;
}

// bool curr_name_consistency = 3;
inline void TripLeg_IntersectingEdge::clear_curr_name_consistency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.curr_name_consistency_ = false;
}
inline bool TripLeg_IntersectingEdge::curr_name_consistency() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.curr_name_consistency)
  return _internal_curr_name_consistency();
}
inline void TripLeg_IntersectingEdge::set_curr_name_consistency(bool value) {
  _internal_set_curr_name_consistency(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.curr_name_consistency)
}
inline bool TripLeg_IntersectingEdge::_internal_curr_name_consistency() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.curr_name_consistency_;
}
inline void TripLeg_IntersectingEdge::_internal_set_curr_name_consistency(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.curr_name_consistency_ = value;
}

// .valhalla.TripLeg.Traversability driveability = 4;
inline void TripLeg_IntersectingEdge::clear_driveability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.driveability_ = 0;
}
inline ::valhalla::TripLeg_Traversability TripLeg_IntersectingEdge::driveability() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.driveability)
  return _internal_driveability();
}
inline void TripLeg_IntersectingEdge::set_driveability(::valhalla::TripLeg_Traversability value) {
  _internal_set_driveability(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.driveability)
}
inline ::valhalla::TripLeg_Traversability TripLeg_IntersectingEdge::_internal_driveability() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::TripLeg_Traversability>(_impl_.driveability_);
}
inline void TripLeg_IntersectingEdge::_internal_set_driveability(::valhalla::TripLeg_Traversability value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.driveability_ = value;
}

// .valhalla.TripLeg.Traversability cyclability = 5;
inline void TripLeg_IntersectingEdge::clear_cyclability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cyclability_ = 0;
}
inline ::valhalla::TripLeg_Traversability TripLeg_IntersectingEdge::cyclability() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.cyclability)
  return _internal_cyclability();
}
inline void TripLeg_IntersectingEdge::set_cyclability(::valhalla::TripLeg_Traversability value) {
  _internal_set_cyclability(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.cyclability)
}
inline ::valhalla::TripLeg_Traversability TripLeg_IntersectingEdge::_internal_cyclability() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::TripLeg_Traversability>(_impl_.cyclability_);
}
inline void TripLeg_IntersectingEdge::_internal_set_cyclability(::valhalla::TripLeg_Traversability value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cyclability_ = value;
}

// .valhalla.TripLeg.Traversability walkability = 6;
inline void TripLeg_IntersectingEdge::clear_walkability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.walkability_ = 0;
}
inline ::valhalla::TripLeg_Traversability TripLeg_IntersectingEdge::walkability() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.walkability)
  return _internal_walkability();
}
inline void TripLeg_IntersectingEdge::set_walkability(::valhalla::TripLeg_Traversability value) {
  _internal_set_walkability(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.walkability)
}
inline ::valhalla::TripLeg_Traversability TripLeg_IntersectingEdge::_internal_walkability() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::TripLeg_Traversability>(_impl_.walkability_);
}
inline void TripLeg_IntersectingEdge::_internal_set_walkability(::valhalla::TripLeg_Traversability value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.walkability_ = value;
}

// .valhalla.TripLeg.Use use = 7;
inline void TripLeg_IntersectingEdge::clear_use() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_ = 0;
}
inline ::valhalla::TripLeg_Use TripLeg_IntersectingEdge::use() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.use)
  return _internal_use();
}
inline void TripLeg_IntersectingEdge::set_use(::valhalla::TripLeg_Use value) {
  _internal_set_use(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.use)
}
inline ::valhalla::TripLeg_Use TripLeg_IntersectingEdge::_internal_use() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::TripLeg_Use>(_impl_.use_);
}
inline void TripLeg_IntersectingEdge::_internal_set_use(::valhalla::TripLeg_Use value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.use_ = value;
}

// .valhalla.RoadClass road_class = 8;
inline void TripLeg_IntersectingEdge::clear_road_class() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.road_class_ = 0;
}
inline ::valhalla::RoadClass TripLeg_IntersectingEdge::road_class() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.road_class)
  return _internal_road_class();
}
inline void TripLeg_IntersectingEdge::set_road_class(::valhalla::RoadClass value) {
  _internal_set_road_class(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.road_class)
}
inline ::valhalla::RoadClass TripLeg_IntersectingEdge::_internal_road_class() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::RoadClass>(_impl_.road_class_);
}
inline void TripLeg_IntersectingEdge::_internal_set_road_class(::valhalla::RoadClass value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.road_class_ = value;
}

// uint32 lane_count = 9;
inline void TripLeg_IntersectingEdge::clear_lane_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lane_count_ = 0u;
}
inline ::uint32_t TripLeg_IntersectingEdge::lane_count() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.lane_count)
  return _internal_lane_count();
}
inline void TripLeg_IntersectingEdge::set_lane_count(::uint32_t value) {
  _internal_set_lane_count(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.IntersectingEdge.lane_count)
}
inline ::uint32_t TripLeg_IntersectingEdge::_internal_lane_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lane_count_;
}
inline void TripLeg_IntersectingEdge::_internal_set_lane_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.lane_count_ = value;
}

// .valhalla.TripSign sign = 10;
inline bool TripLeg_IntersectingEdge::has_sign() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sign_ != nullptr);
  return value;
}
inline const ::valhalla::TripSign& TripLeg_IntersectingEdge::_internal_sign() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::TripSign* p = _impl_.sign_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TripSign&>(::valhalla::_TripSign_default_instance_);
}
inline const ::valhalla::TripSign& TripLeg_IntersectingEdge::sign() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.sign)
  return _internal_sign();
}
inline void TripLeg_IntersectingEdge::unsafe_arena_set_allocated_sign(::valhalla::TripSign* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sign_);
  }
  _impl_.sign_ = reinterpret_cast<::valhalla::TripSign*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.IntersectingEdge.sign)
}
inline ::valhalla::TripSign* TripLeg_IntersectingEdge::release_sign() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::TripSign* released = _impl_.sign_;
  _impl_.sign_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::TripSign* TripLeg_IntersectingEdge::unsafe_arena_release_sign() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.IntersectingEdge.sign)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::TripSign* temp = _impl_.sign_;
  _impl_.sign_ = nullptr;
  return temp;
}
inline ::valhalla::TripSign* TripLeg_IntersectingEdge::_internal_mutable_sign() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.sign_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TripSign>(GetArena());
    _impl_.sign_ = reinterpret_cast<::valhalla::TripSign*>(p);
  }
  return _impl_.sign_;
}
inline ::valhalla::TripSign* TripLeg_IntersectingEdge::mutable_sign() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::TripSign* _msg = _internal_mutable_sign();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.IntersectingEdge.sign)
  return _msg;
}
inline void TripLeg_IntersectingEdge::set_allocated_sign(::valhalla::TripSign* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sign_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.sign_ = reinterpret_cast<::valhalla::TripSign*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.IntersectingEdge.sign)
}

// repeated .valhalla.StreetName name = 21;
inline int TripLeg_IntersectingEdge::_internal_name_size() const {
  return _internal_name().size();
}
inline int TripLeg_IntersectingEdge::name_size() const {
  return _internal_name_size();
}
inline ::valhalla::StreetName* TripLeg_IntersectingEdge::mutable_name(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.IntersectingEdge.name)
  return _internal_mutable_name()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>* TripLeg_IntersectingEdge::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.IntersectingEdge.name)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_name();
}
inline const ::valhalla::StreetName& TripLeg_IntersectingEdge::name(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.IntersectingEdge.name)
  return _internal_name().Get(index);
}
inline ::valhalla::StreetName* TripLeg_IntersectingEdge::add_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::StreetName* _add = _internal_mutable_name()->Add();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.IntersectingEdge.name)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>& TripLeg_IntersectingEdge::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.IntersectingEdge.name)
  return _internal_name();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>&
TripLeg_IntersectingEdge::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::StreetName>*
TripLeg_IntersectingEdge::_internal_mutable_name() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.name_;
}

// -------------------------------------------------------------------

// TripLeg_Cost

// double seconds = 1;
inline void TripLeg_Cost::clear_seconds() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.seconds_ = 0;
}
inline double TripLeg_Cost::seconds() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Cost.seconds)
  return _internal_seconds();
}
inline void TripLeg_Cost::set_seconds(double value) {
  _internal_set_seconds(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Cost.seconds)
}
inline double TripLeg_Cost::_internal_seconds() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.seconds_;
}
inline void TripLeg_Cost::_internal_set_seconds(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.seconds_ = value;
}

// double cost = 2;
inline void TripLeg_Cost::clear_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cost_ = 0;
}
inline double TripLeg_Cost::cost() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Cost.cost)
  return _internal_cost();
}
inline void TripLeg_Cost::set_cost(double value) {
  _internal_set_cost(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Cost.cost)
}
inline double TripLeg_Cost::_internal_cost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cost_;
}
inline void TripLeg_Cost::_internal_set_cost(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cost_ = value;
}

// -------------------------------------------------------------------

// TripLeg_PathCost

// .valhalla.TripLeg.Cost elapsed_cost = 1;
inline bool TripLeg_PathCost::has_elapsed_cost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.elapsed_cost_ != nullptr);
  return value;
}
inline void TripLeg_PathCost::clear_elapsed_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.elapsed_cost_ != nullptr) _impl_.elapsed_cost_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::valhalla::TripLeg_Cost& TripLeg_PathCost::_internal_elapsed_cost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::TripLeg_Cost* p = _impl_.elapsed_cost_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TripLeg_Cost&>(::valhalla::_TripLeg_Cost_default_instance_);
}
inline const ::valhalla::TripLeg_Cost& TripLeg_PathCost::elapsed_cost() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.PathCost.elapsed_cost)
  return _internal_elapsed_cost();
}
inline void TripLeg_PathCost::unsafe_arena_set_allocated_elapsed_cost(::valhalla::TripLeg_Cost* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.elapsed_cost_);
  }
  _impl_.elapsed_cost_ = reinterpret_cast<::valhalla::TripLeg_Cost*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.PathCost.elapsed_cost)
}
inline ::valhalla::TripLeg_Cost* TripLeg_PathCost::release_elapsed_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::TripLeg_Cost* released = _impl_.elapsed_cost_;
  _impl_.elapsed_cost_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::TripLeg_Cost* TripLeg_PathCost::unsafe_arena_release_elapsed_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.PathCost.elapsed_cost)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::TripLeg_Cost* temp = _impl_.elapsed_cost_;
  _impl_.elapsed_cost_ = nullptr;
  return temp;
}
inline ::valhalla::TripLeg_Cost* TripLeg_PathCost::_internal_mutable_elapsed_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.elapsed_cost_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TripLeg_Cost>(GetArena());
    _impl_.elapsed_cost_ = reinterpret_cast<::valhalla::TripLeg_Cost*>(p);
  }
  return _impl_.elapsed_cost_;
}
inline ::valhalla::TripLeg_Cost* TripLeg_PathCost::mutable_elapsed_cost() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::TripLeg_Cost* _msg = _internal_mutable_elapsed_cost();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.PathCost.elapsed_cost)
  return _msg;
}
inline void TripLeg_PathCost::set_allocated_elapsed_cost(::valhalla::TripLeg_Cost* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::valhalla::TripLeg_Cost*>(_impl_.elapsed_cost_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::valhalla::TripLeg_Cost*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.elapsed_cost_ = reinterpret_cast<::valhalla::TripLeg_Cost*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.PathCost.elapsed_cost)
}

// .valhalla.TripLeg.Cost transition_cost = 2;
inline bool TripLeg_PathCost::has_transition_cost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transition_cost_ != nullptr);
  return value;
}
inline void TripLeg_PathCost::clear_transition_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.transition_cost_ != nullptr) _impl_.transition_cost_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::valhalla::TripLeg_Cost& TripLeg_PathCost::_internal_transition_cost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::TripLeg_Cost* p = _impl_.transition_cost_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TripLeg_Cost&>(::valhalla::_TripLeg_Cost_default_instance_);
}
inline const ::valhalla::TripLeg_Cost& TripLeg_PathCost::transition_cost() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.PathCost.transition_cost)
  return _internal_transition_cost();
}
inline void TripLeg_PathCost::unsafe_arena_set_allocated_transition_cost(::valhalla::TripLeg_Cost* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transition_cost_);
  }
  _impl_.transition_cost_ = reinterpret_cast<::valhalla::TripLeg_Cost*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.PathCost.transition_cost)
}
inline ::valhalla::TripLeg_Cost* TripLeg_PathCost::release_transition_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::valhalla::TripLeg_Cost* released = _impl_.transition_cost_;
  _impl_.transition_cost_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::TripLeg_Cost* TripLeg_PathCost::unsafe_arena_release_transition_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.PathCost.transition_cost)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::valhalla::TripLeg_Cost* temp = _impl_.transition_cost_;
  _impl_.transition_cost_ = nullptr;
  return temp;
}
inline ::valhalla::TripLeg_Cost* TripLeg_PathCost::_internal_mutable_transition_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.transition_cost_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TripLeg_Cost>(GetArena());
    _impl_.transition_cost_ = reinterpret_cast<::valhalla::TripLeg_Cost*>(p);
  }
  return _impl_.transition_cost_;
}
inline ::valhalla::TripLeg_Cost* TripLeg_PathCost::mutable_transition_cost() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::TripLeg_Cost* _msg = _internal_mutable_transition_cost();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.PathCost.transition_cost)
  return _msg;
}
inline void TripLeg_PathCost::set_allocated_transition_cost(::valhalla::TripLeg_Cost* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::valhalla::TripLeg_Cost*>(_impl_.transition_cost_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::valhalla::TripLeg_Cost*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.transition_cost_ = reinterpret_cast<::valhalla::TripLeg_Cost*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.PathCost.transition_cost)
}

// -------------------------------------------------------------------

// TripLeg_Node

// .valhalla.TripLeg.Edge edge = 1;
inline bool TripLeg_Node::has_edge() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.edge_ != nullptr);
  return value;
}
inline void TripLeg_Node::clear_edge() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.edge_ != nullptr) _impl_.edge_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::valhalla::TripLeg_Edge& TripLeg_Node::_internal_edge() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::TripLeg_Edge* p = _impl_.edge_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TripLeg_Edge&>(::valhalla::_TripLeg_Edge_default_instance_);
}
inline const ::valhalla::TripLeg_Edge& TripLeg_Node::edge() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.edge)
  return _internal_edge();
}
inline void TripLeg_Node::unsafe_arena_set_allocated_edge(::valhalla::TripLeg_Edge* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.edge_);
  }
  _impl_.edge_ = reinterpret_cast<::valhalla::TripLeg_Edge*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.Node.edge)
}
inline ::valhalla::TripLeg_Edge* TripLeg_Node::release_edge() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::TripLeg_Edge* released = _impl_.edge_;
  _impl_.edge_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::TripLeg_Edge* TripLeg_Node::unsafe_arena_release_edge() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.edge)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::TripLeg_Edge* temp = _impl_.edge_;
  _impl_.edge_ = nullptr;
  return temp;
}
inline ::valhalla::TripLeg_Edge* TripLeg_Node::_internal_mutable_edge() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.edge_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TripLeg_Edge>(GetArena());
    _impl_.edge_ = reinterpret_cast<::valhalla::TripLeg_Edge*>(p);
  }
  return _impl_.edge_;
}
inline ::valhalla::TripLeg_Edge* TripLeg_Node::mutable_edge() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::TripLeg_Edge* _msg = _internal_mutable_edge();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.edge)
  return _msg;
}
inline void TripLeg_Node::set_allocated_edge(::valhalla::TripLeg_Edge* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::valhalla::TripLeg_Edge*>(_impl_.edge_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::valhalla::TripLeg_Edge*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.edge_ = reinterpret_cast<::valhalla::TripLeg_Edge*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.edge)
}

// repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
inline int TripLeg_Node::_internal_intersecting_edge_size() const {
  return _internal_intersecting_edge().size();
}
inline int TripLeg_Node::intersecting_edge_size() const {
  return _internal_intersecting_edge_size();
}
inline void TripLeg_Node::clear_intersecting_edge() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.intersecting_edge_.Clear();
}
inline ::valhalla::TripLeg_IntersectingEdge* TripLeg_Node::mutable_intersecting_edge(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.intersecting_edge)
  return _internal_mutable_intersecting_edge()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_IntersectingEdge>* TripLeg_Node::mutable_intersecting_edge()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Node.intersecting_edge)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_intersecting_edge();
}
inline const ::valhalla::TripLeg_IntersectingEdge& TripLeg_Node::intersecting_edge(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.intersecting_edge)
  return _internal_intersecting_edge().Get(index);
}
inline ::valhalla::TripLeg_IntersectingEdge* TripLeg_Node::add_intersecting_edge() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::TripLeg_IntersectingEdge* _add = _internal_mutable_intersecting_edge()->Add();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Node.intersecting_edge)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_IntersectingEdge>& TripLeg_Node::intersecting_edge() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Node.intersecting_edge)
  return _internal_intersecting_edge();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_IntersectingEdge>&
TripLeg_Node::_internal_intersecting_edge() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.intersecting_edge_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_IntersectingEdge>*
TripLeg_Node::_internal_mutable_intersecting_edge() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.intersecting_edge_;
}

// uint32 admin_index = 3;
inline void TripLeg_Node::clear_admin_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.admin_index_ = 0u;
}
inline ::uint32_t TripLeg_Node::admin_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.admin_index)
  return _internal_admin_index();
}
inline void TripLeg_Node::set_admin_index(::uint32_t value) {
  _internal_set_admin_index(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Node.admin_index)
}
inline ::uint32_t TripLeg_Node::_internal_admin_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.admin_index_;
}
inline void TripLeg_Node::_internal_set_admin_index(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.admin_index_ = value;
}

// .valhalla.TripLeg.Node.Type type = 4;
inline void TripLeg_Node::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::valhalla::TripLeg_Node_Type TripLeg_Node::type() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.type)
  return _internal_type();
}
inline void TripLeg_Node::set_type(::valhalla::TripLeg_Node_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Node.type)
}
inline ::valhalla::TripLeg_Node_Type TripLeg_Node::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::valhalla::TripLeg_Node_Type>(_impl_.type_);
}
inline void TripLeg_Node::_internal_set_type(::valhalla::TripLeg_Node_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// bool fork = 5;
inline void TripLeg_Node::clear_fork() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fork_ = false;
}
inline bool TripLeg_Node::fork() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.fork)
  return _internal_fork();
}
inline void TripLeg_Node::set_fork(bool value) {
  _internal_set_fork(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Node.fork)
}
inline bool TripLeg_Node::_internal_fork() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fork_;
}
inline void TripLeg_Node::_internal_set_fork(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fork_ = value;
}

// .valhalla.TransitPlatformInfo transit_platform_info = 6;
inline bool TripLeg_Node::has_transit_platform_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transit_platform_info_ != nullptr);
  return value;
}
inline const ::valhalla::TransitPlatformInfo& TripLeg_Node::_internal_transit_platform_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::TransitPlatformInfo* p = _impl_.transit_platform_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TransitPlatformInfo&>(::valhalla::_TransitPlatformInfo_default_instance_);
}
inline const ::valhalla::TransitPlatformInfo& TripLeg_Node::transit_platform_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.transit_platform_info)
  return _internal_transit_platform_info();
}
inline void TripLeg_Node::unsafe_arena_set_allocated_transit_platform_info(::valhalla::TransitPlatformInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transit_platform_info_);
  }
  _impl_.transit_platform_info_ = reinterpret_cast<::valhalla::TransitPlatformInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.Node.transit_platform_info)
}
inline ::valhalla::TransitPlatformInfo* TripLeg_Node::release_transit_platform_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::valhalla::TransitPlatformInfo* released = _impl_.transit_platform_info_;
  _impl_.transit_platform_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::TransitPlatformInfo* TripLeg_Node::unsafe_arena_release_transit_platform_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.transit_platform_info)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::valhalla::TransitPlatformInfo* temp = _impl_.transit_platform_info_;
  _impl_.transit_platform_info_ = nullptr;
  return temp;
}
inline ::valhalla::TransitPlatformInfo* TripLeg_Node::_internal_mutable_transit_platform_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.transit_platform_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TransitPlatformInfo>(GetArena());
    _impl_.transit_platform_info_ = reinterpret_cast<::valhalla::TransitPlatformInfo*>(p);
  }
  return _impl_.transit_platform_info_;
}
inline ::valhalla::TransitPlatformInfo* TripLeg_Node::mutable_transit_platform_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::TransitPlatformInfo* _msg = _internal_mutable_transit_platform_info();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.transit_platform_info)
  return _msg;
}
inline void TripLeg_Node::set_allocated_transit_platform_info(::valhalla::TransitPlatformInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transit_platform_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.transit_platform_info_ = reinterpret_cast<::valhalla::TransitPlatformInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.transit_platform_info)
}

// .valhalla.TransitStationInfo transit_station_info = 7;
inline bool TripLeg_Node::has_transit_station_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transit_station_info_ != nullptr);
  return value;
}
inline const ::valhalla::TransitStationInfo& TripLeg_Node::_internal_transit_station_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::TransitStationInfo* p = _impl_.transit_station_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TransitStationInfo&>(::valhalla::_TransitStationInfo_default_instance_);
}
inline const ::valhalla::TransitStationInfo& TripLeg_Node::transit_station_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.transit_station_info)
  return _internal_transit_station_info();
}
inline void TripLeg_Node::unsafe_arena_set_allocated_transit_station_info(::valhalla::TransitStationInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transit_station_info_);
  }
  _impl_.transit_station_info_ = reinterpret_cast<::valhalla::TransitStationInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.Node.transit_station_info)
}
inline ::valhalla::TransitStationInfo* TripLeg_Node::release_transit_station_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::valhalla::TransitStationInfo* released = _impl_.transit_station_info_;
  _impl_.transit_station_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::TransitStationInfo* TripLeg_Node::unsafe_arena_release_transit_station_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.transit_station_info)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::valhalla::TransitStationInfo* temp = _impl_.transit_station_info_;
  _impl_.transit_station_info_ = nullptr;
  return temp;
}
inline ::valhalla::TransitStationInfo* TripLeg_Node::_internal_mutable_transit_station_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.transit_station_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TransitStationInfo>(GetArena());
    _impl_.transit_station_info_ = reinterpret_cast<::valhalla::TransitStationInfo*>(p);
  }
  return _impl_.transit_station_info_;
}
inline ::valhalla::TransitStationInfo* TripLeg_Node::mutable_transit_station_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::TransitStationInfo* _msg = _internal_mutable_transit_station_info();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.transit_station_info)
  return _msg;
}
inline void TripLeg_Node::set_allocated_transit_station_info(::valhalla::TransitStationInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transit_station_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.transit_station_info_ = reinterpret_cast<::valhalla::TransitStationInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.transit_station_info)
}

// .valhalla.TransitEgressInfo transit_egress_info = 10;
inline bool TripLeg_Node::has_transit_egress_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transit_egress_info_ != nullptr);
  return value;
}
inline const ::valhalla::TransitEgressInfo& TripLeg_Node::_internal_transit_egress_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::TransitEgressInfo* p = _impl_.transit_egress_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TransitEgressInfo&>(::valhalla::_TransitEgressInfo_default_instance_);
}
inline const ::valhalla::TransitEgressInfo& TripLeg_Node::transit_egress_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.transit_egress_info)
  return _internal_transit_egress_info();
}
inline void TripLeg_Node::unsafe_arena_set_allocated_transit_egress_info(::valhalla::TransitEgressInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transit_egress_info_);
  }
  _impl_.transit_egress_info_ = reinterpret_cast<::valhalla::TransitEgressInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.Node.transit_egress_info)
}
inline ::valhalla::TransitEgressInfo* TripLeg_Node::release_transit_egress_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::valhalla::TransitEgressInfo* released = _impl_.transit_egress_info_;
  _impl_.transit_egress_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::TransitEgressInfo* TripLeg_Node::unsafe_arena_release_transit_egress_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.transit_egress_info)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::valhalla::TransitEgressInfo* temp = _impl_.transit_egress_info_;
  _impl_.transit_egress_info_ = nullptr;
  return temp;
}
inline ::valhalla::TransitEgressInfo* TripLeg_Node::_internal_mutable_transit_egress_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.transit_egress_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TransitEgressInfo>(GetArena());
    _impl_.transit_egress_info_ = reinterpret_cast<::valhalla::TransitEgressInfo*>(p);
  }
  return _impl_.transit_egress_info_;
}
inline ::valhalla::TransitEgressInfo* TripLeg_Node::mutable_transit_egress_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::TransitEgressInfo* _msg = _internal_mutable_transit_egress_info();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.transit_egress_info)
  return _msg;
}
inline void TripLeg_Node::set_allocated_transit_egress_info(::valhalla::TransitEgressInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transit_egress_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.transit_egress_info_ = reinterpret_cast<::valhalla::TransitEgressInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.transit_egress_info)
}

// string time_zone = 11;
inline void TripLeg_Node::clear_time_zone() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.time_zone_.ClearToEmpty();
}
inline const std::string& TripLeg_Node::time_zone() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.time_zone)
  return _internal_time_zone();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TripLeg_Node::set_time_zone(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.time_zone_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Node.time_zone)
}
inline std::string* TripLeg_Node::mutable_time_zone() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_time_zone();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.time_zone)
  return _s;
}
inline const std::string& TripLeg_Node::_internal_time_zone() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.time_zone_.Get();
}
inline void TripLeg_Node::_internal_set_time_zone(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.time_zone_.Set(value, GetArena());
}
inline std::string* TripLeg_Node::_internal_mutable_time_zone() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.time_zone_.Mutable( GetArena());
}
inline std::string* TripLeg_Node::release_time_zone() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.time_zone)
  return _impl_.time_zone_.Release();
}
inline void TripLeg_Node::set_allocated_time_zone(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.time_zone_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.time_zone_.IsDefault()) {
          _impl_.time_zone_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.time_zone)
}

// .valhalla.TripLeg.PathCost cost = 12;
inline bool TripLeg_Node::has_cost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cost_ != nullptr);
  return value;
}
inline void TripLeg_Node::clear_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.cost_ != nullptr) _impl_.cost_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::valhalla::TripLeg_PathCost& TripLeg_Node::_internal_cost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::TripLeg_PathCost* p = _impl_.cost_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TripLeg_PathCost&>(::valhalla::_TripLeg_PathCost_default_instance_);
}
inline const ::valhalla::TripLeg_PathCost& TripLeg_Node::cost() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.cost)
  return _internal_cost();
}
inline void TripLeg_Node::unsafe_arena_set_allocated_cost(::valhalla::TripLeg_PathCost* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cost_);
  }
  _impl_.cost_ = reinterpret_cast<::valhalla::TripLeg_PathCost*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.Node.cost)
}
inline ::valhalla::TripLeg_PathCost* TripLeg_Node::release_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::valhalla::TripLeg_PathCost* released = _impl_.cost_;
  _impl_.cost_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::TripLeg_PathCost* TripLeg_Node::unsafe_arena_release_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.cost)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::valhalla::TripLeg_PathCost* temp = _impl_.cost_;
  _impl_.cost_ = nullptr;
  return temp;
}
inline ::valhalla::TripLeg_PathCost* TripLeg_Node::_internal_mutable_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.cost_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TripLeg_PathCost>(GetArena());
    _impl_.cost_ = reinterpret_cast<::valhalla::TripLeg_PathCost*>(p);
  }
  return _impl_.cost_;
}
inline ::valhalla::TripLeg_PathCost* TripLeg_Node::mutable_cost() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::TripLeg_PathCost* _msg = _internal_mutable_cost();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.cost)
  return _msg;
}
inline void TripLeg_Node::set_allocated_cost(::valhalla::TripLeg_PathCost* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::valhalla::TripLeg_PathCost*>(_impl_.cost_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::valhalla::TripLeg_PathCost*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.cost_ = reinterpret_cast<::valhalla::TripLeg_PathCost*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.cost)
}

// repeated .valhalla.TripLeg.PathCost recosts = 13;
inline int TripLeg_Node::_internal_recosts_size() const {
  return _internal_recosts().size();
}
inline int TripLeg_Node::recosts_size() const {
  return _internal_recosts_size();
}
inline void TripLeg_Node::clear_recosts() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.recosts_.Clear();
}
inline ::valhalla::TripLeg_PathCost* TripLeg_Node::mutable_recosts(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.recosts)
  return _internal_mutable_recosts()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_PathCost>* TripLeg_Node::mutable_recosts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.Node.recosts)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_recosts();
}
inline const ::valhalla::TripLeg_PathCost& TripLeg_Node::recosts(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.recosts)
  return _internal_recosts().Get(index);
}
inline ::valhalla::TripLeg_PathCost* TripLeg_Node::add_recosts() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::TripLeg_PathCost* _add = _internal_mutable_recosts()->Add();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.Node.recosts)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_PathCost>& TripLeg_Node::recosts() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.Node.recosts)
  return _internal_recosts();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_PathCost>&
TripLeg_Node::_internal_recosts() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.recosts_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_PathCost>*
TripLeg_Node::_internal_mutable_recosts() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.recosts_;
}

// .valhalla.BikeShareStationInfo bss_info = 14;
inline bool TripLeg_Node::has_bss_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bss_info_ != nullptr);
  return value;
}
inline const ::valhalla::BikeShareStationInfo& TripLeg_Node::_internal_bss_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::BikeShareStationInfo* p = _impl_.bss_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::BikeShareStationInfo&>(::valhalla::_BikeShareStationInfo_default_instance_);
}
inline const ::valhalla::BikeShareStationInfo& TripLeg_Node::bss_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.bss_info)
  return _internal_bss_info();
}
inline void TripLeg_Node::unsafe_arena_set_allocated_bss_info(::valhalla::BikeShareStationInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bss_info_);
  }
  _impl_.bss_info_ = reinterpret_cast<::valhalla::BikeShareStationInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.Node.bss_info)
}
inline ::valhalla::BikeShareStationInfo* TripLeg_Node::release_bss_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::valhalla::BikeShareStationInfo* released = _impl_.bss_info_;
  _impl_.bss_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::BikeShareStationInfo* TripLeg_Node::unsafe_arena_release_bss_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Node.bss_info)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::valhalla::BikeShareStationInfo* temp = _impl_.bss_info_;
  _impl_.bss_info_ = nullptr;
  return temp;
}
inline ::valhalla::BikeShareStationInfo* TripLeg_Node::_internal_mutable_bss_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.bss_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::BikeShareStationInfo>(GetArena());
    _impl_.bss_info_ = reinterpret_cast<::valhalla::BikeShareStationInfo*>(p);
  }
  return _impl_.bss_info_;
}
inline ::valhalla::BikeShareStationInfo* TripLeg_Node::mutable_bss_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::BikeShareStationInfo* _msg = _internal_mutable_bss_info();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Node.bss_info)
  return _msg;
}
inline void TripLeg_Node::set_allocated_bss_info(::valhalla::BikeShareStationInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bss_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.bss_info_ = reinterpret_cast<::valhalla::BikeShareStationInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Node.bss_info)
}

// bool traffic_signal = 21;
inline void TripLeg_Node::clear_traffic_signal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.traffic_signal_ = false;
}
inline bool TripLeg_Node::traffic_signal() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Node.traffic_signal)
  return _internal_traffic_signal();
}
inline void TripLeg_Node::set_traffic_signal(bool value) {
  _internal_set_traffic_signal(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Node.traffic_signal)
}
inline bool TripLeg_Node::_internal_traffic_signal() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.traffic_signal_;
}
inline void TripLeg_Node::_internal_set_traffic_signal(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.traffic_signal_ = value;
}

// -------------------------------------------------------------------

// TripLeg_Admin

// string country_code = 1;
inline void TripLeg_Admin::clear_country_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.country_code_.ClearToEmpty();
}
inline const std::string& TripLeg_Admin::country_code() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Admin.country_code)
  return _internal_country_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TripLeg_Admin::set_country_code(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.country_code_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Admin.country_code)
}
inline std::string* TripLeg_Admin::mutable_country_code() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_country_code();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Admin.country_code)
  return _s;
}
inline const std::string& TripLeg_Admin::_internal_country_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.country_code_.Get();
}
inline void TripLeg_Admin::_internal_set_country_code(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.country_code_.Set(value, GetArena());
}
inline std::string* TripLeg_Admin::_internal_mutable_country_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.country_code_.Mutable( GetArena());
}
inline std::string* TripLeg_Admin::release_country_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Admin.country_code)
  return _impl_.country_code_.Release();
}
inline void TripLeg_Admin::set_allocated_country_code(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.country_code_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.country_code_.IsDefault()) {
          _impl_.country_code_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Admin.country_code)
}

// string country_text = 2;
inline void TripLeg_Admin::clear_country_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.country_text_.ClearToEmpty();
}
inline const std::string& TripLeg_Admin::country_text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Admin.country_text)
  return _internal_country_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TripLeg_Admin::set_country_text(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.country_text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Admin.country_text)
}
inline std::string* TripLeg_Admin::mutable_country_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_country_text();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Admin.country_text)
  return _s;
}
inline const std::string& TripLeg_Admin::_internal_country_text() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.country_text_.Get();
}
inline void TripLeg_Admin::_internal_set_country_text(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.country_text_.Set(value, GetArena());
}
inline std::string* TripLeg_Admin::_internal_mutable_country_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.country_text_.Mutable( GetArena());
}
inline std::string* TripLeg_Admin::release_country_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Admin.country_text)
  return _impl_.country_text_.Release();
}
inline void TripLeg_Admin::set_allocated_country_text(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.country_text_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.country_text_.IsDefault()) {
          _impl_.country_text_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Admin.country_text)
}

// string state_code = 3;
inline void TripLeg_Admin::clear_state_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_code_.ClearToEmpty();
}
inline const std::string& TripLeg_Admin::state_code() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Admin.state_code)
  return _internal_state_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TripLeg_Admin::set_state_code(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.state_code_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Admin.state_code)
}
inline std::string* TripLeg_Admin::mutable_state_code() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_state_code();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Admin.state_code)
  return _s;
}
inline const std::string& TripLeg_Admin::_internal_state_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.state_code_.Get();
}
inline void TripLeg_Admin::_internal_set_state_code(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.state_code_.Set(value, GetArena());
}
inline std::string* TripLeg_Admin::_internal_mutable_state_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.state_code_.Mutable( GetArena());
}
inline std::string* TripLeg_Admin::release_state_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Admin.state_code)
  return _impl_.state_code_.Release();
}
inline void TripLeg_Admin::set_allocated_state_code(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_code_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.state_code_.IsDefault()) {
          _impl_.state_code_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Admin.state_code)
}

// string state_text = 4;
inline void TripLeg_Admin::clear_state_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_text_.ClearToEmpty();
}
inline const std::string& TripLeg_Admin::state_text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Admin.state_text)
  return _internal_state_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TripLeg_Admin::set_state_text(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.state_text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Admin.state_text)
}
inline std::string* TripLeg_Admin::mutable_state_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_state_text();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Admin.state_text)
  return _s;
}
inline const std::string& TripLeg_Admin::_internal_state_text() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.state_text_.Get();
}
inline void TripLeg_Admin::_internal_set_state_text(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.state_text_.Set(value, GetArena());
}
inline std::string* TripLeg_Admin::_internal_mutable_state_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.state_text_.Mutable( GetArena());
}
inline std::string* TripLeg_Admin::release_state_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Admin.state_text)
  return _impl_.state_text_.Release();
}
inline void TripLeg_Admin::set_allocated_state_text(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_text_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.state_text_.IsDefault()) {
          _impl_.state_text_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Admin.state_text)
}

// -------------------------------------------------------------------

// TripLeg_ShapeAttributes

// repeated uint32 time = 1 [packed = true];
inline int TripLeg_ShapeAttributes::_internal_time_size() const {
  return _internal_time().size();
}
inline int TripLeg_ShapeAttributes::time_size() const {
  return _internal_time_size();
}
inline void TripLeg_ShapeAttributes::clear_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.time_.Clear();
}
inline ::uint32_t TripLeg_ShapeAttributes::time(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.ShapeAttributes.time)
  return _internal_time().Get(index);
}
inline void TripLeg_ShapeAttributes::set_time(int index, ::uint32_t value) {
  _internal_mutable_time()->Set(index, value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.ShapeAttributes.time)
}
inline void TripLeg_ShapeAttributes::add_time(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_time()->Add(value);
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.ShapeAttributes.time)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& TripLeg_ShapeAttributes::time() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.ShapeAttributes.time)
  return _internal_time();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* TripLeg_ShapeAttributes::mutable_time()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.ShapeAttributes.time)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_time();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& TripLeg_ShapeAttributes::_internal_time()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.time_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* TripLeg_ShapeAttributes::_internal_mutable_time() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.time_;
}

// repeated uint32 length = 2 [packed = true];
inline int TripLeg_ShapeAttributes::_internal_length_size() const {
  return _internal_length().size();
}
inline int TripLeg_ShapeAttributes::length_size() const {
  return _internal_length_size();
}
inline void TripLeg_ShapeAttributes::clear_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.length_.Clear();
}
inline ::uint32_t TripLeg_ShapeAttributes::length(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.ShapeAttributes.length)
  return _internal_length().Get(index);
}
inline void TripLeg_ShapeAttributes::set_length(int index, ::uint32_t value) {
  _internal_mutable_length()->Set(index, value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.ShapeAttributes.length)
}
inline void TripLeg_ShapeAttributes::add_length(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_length()->Add(value);
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.ShapeAttributes.length)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& TripLeg_ShapeAttributes::length() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.ShapeAttributes.length)
  return _internal_length();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* TripLeg_ShapeAttributes::mutable_length()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.ShapeAttributes.length)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_length();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& TripLeg_ShapeAttributes::_internal_length()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.length_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* TripLeg_ShapeAttributes::_internal_mutable_length() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.length_;
}

// repeated uint32 speed = 3 [packed = true];
inline int TripLeg_ShapeAttributes::_internal_speed_size() const {
  return _internal_speed().size();
}
inline int TripLeg_ShapeAttributes::speed_size() const {
  return _internal_speed_size();
}
inline void TripLeg_ShapeAttributes::clear_speed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.speed_.Clear();
}
inline ::uint32_t TripLeg_ShapeAttributes::speed(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.ShapeAttributes.speed)
  return _internal_speed().Get(index);
}
inline void TripLeg_ShapeAttributes::set_speed(int index, ::uint32_t value) {
  _internal_mutable_speed()->Set(index, value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.ShapeAttributes.speed)
}
inline void TripLeg_ShapeAttributes::add_speed(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_speed()->Add(value);
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.ShapeAttributes.speed)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& TripLeg_ShapeAttributes::speed() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.ShapeAttributes.speed)
  return _internal_speed();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* TripLeg_ShapeAttributes::mutable_speed()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.ShapeAttributes.speed)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_speed();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& TripLeg_ShapeAttributes::_internal_speed()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.speed_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* TripLeg_ShapeAttributes::_internal_mutable_speed() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.speed_;
}

// repeated uint32 speed_limit = 5 [packed = true];
inline int TripLeg_ShapeAttributes::_internal_speed_limit_size() const {
  return _internal_speed_limit().size();
}
inline int TripLeg_ShapeAttributes::speed_limit_size() const {
  return _internal_speed_limit_size();
}
inline void TripLeg_ShapeAttributes::clear_speed_limit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.speed_limit_.Clear();
}
inline ::uint32_t TripLeg_ShapeAttributes::speed_limit(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.ShapeAttributes.speed_limit)
  return _internal_speed_limit().Get(index);
}
inline void TripLeg_ShapeAttributes::set_speed_limit(int index, ::uint32_t value) {
  _internal_mutable_speed_limit()->Set(index, value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.ShapeAttributes.speed_limit)
}
inline void TripLeg_ShapeAttributes::add_speed_limit(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_speed_limit()->Add(value);
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.ShapeAttributes.speed_limit)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& TripLeg_ShapeAttributes::speed_limit() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.ShapeAttributes.speed_limit)
  return _internal_speed_limit();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* TripLeg_ShapeAttributes::mutable_speed_limit()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.ShapeAttributes.speed_limit)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_speed_limit();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& TripLeg_ShapeAttributes::_internal_speed_limit()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.speed_limit_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* TripLeg_ShapeAttributes::_internal_mutable_speed_limit() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.speed_limit_;
}

// -------------------------------------------------------------------

// TripLeg_Incident

// .valhalla.IncidentsTile.Metadata metadata = 1;
inline bool TripLeg_Incident::has_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.metadata_ != nullptr);
  return value;
}
inline const ::valhalla::IncidentsTile_Metadata& TripLeg_Incident::_internal_metadata() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::IncidentsTile_Metadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::IncidentsTile_Metadata&>(::valhalla::_IncidentsTile_Metadata_default_instance_);
}
inline const ::valhalla::IncidentsTile_Metadata& TripLeg_Incident::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Incident.metadata)
  return _internal_metadata();
}
inline void TripLeg_Incident::unsafe_arena_set_allocated_metadata(::valhalla::IncidentsTile_Metadata* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = reinterpret_cast<::valhalla::IncidentsTile_Metadata*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.Incident.metadata)
}
inline ::valhalla::IncidentsTile_Metadata* TripLeg_Incident::release_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::IncidentsTile_Metadata* released = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::IncidentsTile_Metadata* TripLeg_Incident::unsafe_arena_release_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.Incident.metadata)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::IncidentsTile_Metadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::valhalla::IncidentsTile_Metadata* TripLeg_Incident::_internal_mutable_metadata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::IncidentsTile_Metadata>(GetArena());
    _impl_.metadata_ = reinterpret_cast<::valhalla::IncidentsTile_Metadata*>(p);
  }
  return _impl_.metadata_;
}
inline ::valhalla::IncidentsTile_Metadata* TripLeg_Incident::mutable_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::IncidentsTile_Metadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.Incident.metadata)
  return _msg;
}
inline void TripLeg_Incident::set_allocated_metadata(::valhalla::IncidentsTile_Metadata* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.metadata_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.metadata_ = reinterpret_cast<::valhalla::IncidentsTile_Metadata*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.Incident.metadata)
}

// uint32 begin_shape_index = 3;
inline void TripLeg_Incident::clear_begin_shape_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.begin_shape_index_ = 0u;
}
inline ::uint32_t TripLeg_Incident::begin_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Incident.begin_shape_index)
  return _internal_begin_shape_index();
}
inline void TripLeg_Incident::set_begin_shape_index(::uint32_t value) {
  _internal_set_begin_shape_index(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Incident.begin_shape_index)
}
inline ::uint32_t TripLeg_Incident::_internal_begin_shape_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.begin_shape_index_;
}
inline void TripLeg_Incident::_internal_set_begin_shape_index(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.begin_shape_index_ = value;
}

// uint32 end_shape_index = 4;
inline void TripLeg_Incident::clear_end_shape_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_shape_index_ = 0u;
}
inline ::uint32_t TripLeg_Incident::end_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Incident.end_shape_index)
  return _internal_end_shape_index();
}
inline void TripLeg_Incident::set_end_shape_index(::uint32_t value) {
  _internal_set_end_shape_index(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Incident.end_shape_index)
}
inline ::uint32_t TripLeg_Incident::_internal_end_shape_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_shape_index_;
}
inline void TripLeg_Incident::_internal_set_end_shape_index(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.end_shape_index_ = value;
}

// -------------------------------------------------------------------

// TripLeg_Closure

// uint32 begin_shape_index = 1;
inline bool TripLeg_Closure::has_begin_shape_index() const {
  return has_begin_shape_index_case() == kBeginShapeIndex;
}
inline void TripLeg_Closure::set_has_begin_shape_index() {
  _impl_._oneof_case_[0] = kBeginShapeIndex;
}
inline void TripLeg_Closure::clear_begin_shape_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_begin_shape_index_case() == kBeginShapeIndex) {
    _impl_.has_begin_shape_index_.begin_shape_index_ = 0u;
    clear_has_has_begin_shape_index();
  }
}
inline ::uint32_t TripLeg_Closure::begin_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Closure.begin_shape_index)
  return _internal_begin_shape_index();
}
inline void TripLeg_Closure::set_begin_shape_index(::uint32_t value) {
  _internal_set_begin_shape_index(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Closure.begin_shape_index)
}
inline ::uint32_t TripLeg_Closure::_internal_begin_shape_index() const {
  if (has_begin_shape_index_case() == kBeginShapeIndex) {
    return _impl_.has_begin_shape_index_.begin_shape_index_;
  }
  return 0u;
}
inline void TripLeg_Closure::_internal_set_begin_shape_index(::uint32_t value) {
  if (has_begin_shape_index_case() != kBeginShapeIndex) {
    clear_has_begin_shape_index();
    set_has_begin_shape_index();
  }
  _impl_.has_begin_shape_index_.begin_shape_index_ = value;
}

// uint32 end_shape_index = 2;
inline bool TripLeg_Closure::has_end_shape_index() const {
  return has_end_shape_index_case() == kEndShapeIndex;
}
inline void TripLeg_Closure::set_has_end_shape_index() {
  _impl_._oneof_case_[1] = kEndShapeIndex;
}
inline void TripLeg_Closure::clear_end_shape_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_end_shape_index_case() == kEndShapeIndex) {
    _impl_.has_end_shape_index_.end_shape_index_ = 0u;
    clear_has_has_end_shape_index();
  }
}
inline ::uint32_t TripLeg_Closure::end_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.Closure.end_shape_index)
  return _internal_end_shape_index();
}
inline void TripLeg_Closure::set_end_shape_index(::uint32_t value) {
  _internal_set_end_shape_index(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.Closure.end_shape_index)
}
inline ::uint32_t TripLeg_Closure::_internal_end_shape_index() const {
  if (has_end_shape_index_case() == kEndShapeIndex) {
    return _impl_.has_end_shape_index_.end_shape_index_;
  }
  return 0u;
}
inline void TripLeg_Closure::_internal_set_end_shape_index(::uint32_t value) {
  if (has_end_shape_index_case() != kEndShapeIndex) {
    clear_has_end_shape_index();
    set_has_end_shape_index();
  }
  _impl_.has_end_shape_index_.end_shape_index_ = value;
}

inline bool TripLeg_Closure::has_has_begin_shape_index() const {
  return has_begin_shape_index_case() != HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}
inline void TripLeg_Closure::clear_has_has_begin_shape_index() {
  _impl_._oneof_case_[0] = HAS_BEGIN_SHAPE_INDEX_NOT_SET;
}
inline bool TripLeg_Closure::has_has_end_shape_index() const {
  return has_end_shape_index_case() != HAS_END_SHAPE_INDEX_NOT_SET;
}
inline void TripLeg_Closure::clear_has_has_end_shape_index() {
  _impl_._oneof_case_[1] = HAS_END_SHAPE_INDEX_NOT_SET;
}
inline TripLeg_Closure::HasBeginShapeIndexCase TripLeg_Closure::has_begin_shape_index_case() const {
  return TripLeg_Closure::HasBeginShapeIndexCase(_impl_._oneof_case_[0]);
}
inline TripLeg_Closure::HasEndShapeIndexCase TripLeg_Closure::has_end_shape_index_case() const {
  return TripLeg_Closure::HasEndShapeIndexCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// TripLeg

// uint64 osm_changeset = 1;
inline void TripLeg::clear_osm_changeset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.osm_changeset_ = ::uint64_t{0u};
}
inline ::uint64_t TripLeg::osm_changeset() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.osm_changeset)
  return _internal_osm_changeset();
}
inline void TripLeg::set_osm_changeset(::uint64_t value) {
  _internal_set_osm_changeset(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.osm_changeset)
}
inline ::uint64_t TripLeg::_internal_osm_changeset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.osm_changeset_;
}
inline void TripLeg::_internal_set_osm_changeset(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.osm_changeset_ = value;
}

// uint64 trip_id = 2;
inline void TripLeg::clear_trip_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.trip_id_ = ::uint64_t{0u};
}
inline ::uint64_t TripLeg::trip_id() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.trip_id)
  return _internal_trip_id();
}
inline void TripLeg::set_trip_id(::uint64_t value) {
  _internal_set_trip_id(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.trip_id)
}
inline ::uint64_t TripLeg::_internal_trip_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.trip_id_;
}
inline void TripLeg::_internal_set_trip_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.trip_id_ = value;
}

// uint32 leg_id = 3;
inline void TripLeg::clear_leg_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.leg_id_ = 0u;
}
inline ::uint32_t TripLeg::leg_id() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.leg_id)
  return _internal_leg_id();
}
inline void TripLeg::set_leg_id(::uint32_t value) {
  _internal_set_leg_id(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.leg_id)
}
inline ::uint32_t TripLeg::_internal_leg_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.leg_id_;
}
inline void TripLeg::_internal_set_leg_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.leg_id_ = value;
}

// uint32 leg_count = 4;
inline void TripLeg::clear_leg_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.leg_count_ = 0u;
}
inline ::uint32_t TripLeg::leg_count() const {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.leg_count)
  return _internal_leg_count();
}
inline void TripLeg::set_leg_count(::uint32_t value) {
  _internal_set_leg_count(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.leg_count)
}
inline ::uint32_t TripLeg::_internal_leg_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.leg_count_;
}
inline void TripLeg::_internal_set_leg_count(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.leg_count_ = value;
}

// repeated .valhalla.Location location = 5;
inline int TripLeg::_internal_location_size() const {
  return _internal_location().size();
}
inline int TripLeg::location_size() const {
  return _internal_location_size();
}
inline ::valhalla::Location* TripLeg::mutable_location(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.location)
  return _internal_mutable_location()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::Location>* TripLeg::mutable_location()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.location)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_location();
}
inline const ::valhalla::Location& TripLeg::location(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.location)
  return _internal_location().Get(index);
}
inline ::valhalla::Location* TripLeg::add_location() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::Location* _add = _internal_mutable_location()->Add();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.location)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::Location>& TripLeg::location() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.location)
  return _internal_location();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::Location>&
TripLeg::_internal_location() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.location_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::Location>*
TripLeg::_internal_mutable_location() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.location_;
}

// repeated .valhalla.TripLeg.Node node = 6;
inline int TripLeg::_internal_node_size() const {
  return _internal_node().size();
}
inline int TripLeg::node_size() const {
  return _internal_node_size();
}
inline void TripLeg::clear_node() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_.Clear();
}
inline ::valhalla::TripLeg_Node* TripLeg::mutable_node(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.node)
  return _internal_mutable_node()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_Node>* TripLeg::mutable_node()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.node)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_node();
}
inline const ::valhalla::TripLeg_Node& TripLeg::node(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.node)
  return _internal_node().Get(index);
}
inline ::valhalla::TripLeg_Node* TripLeg::add_node() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::TripLeg_Node* _add = _internal_mutable_node()->Add();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.node)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_Node>& TripLeg::node() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.node)
  return _internal_node();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_Node>&
TripLeg::_internal_node() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_Node>*
TripLeg::_internal_mutable_node() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.node_;
}

// repeated .valhalla.TripLeg.Admin admin = 7;
inline int TripLeg::_internal_admin_size() const {
  return _internal_admin().size();
}
inline int TripLeg::admin_size() const {
  return _internal_admin_size();
}
inline void TripLeg::clear_admin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.admin_.Clear();
}
inline ::valhalla::TripLeg_Admin* TripLeg::mutable_admin(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.admin)
  return _internal_mutable_admin()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_Admin>* TripLeg::mutable_admin()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.admin)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_admin();
}
inline const ::valhalla::TripLeg_Admin& TripLeg::admin(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.admin)
  return _internal_admin().Get(index);
}
inline ::valhalla::TripLeg_Admin* TripLeg::add_admin() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::TripLeg_Admin* _add = _internal_mutable_admin()->Add();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.admin)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_Admin>& TripLeg::admin() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.admin)
  return _internal_admin();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_Admin>&
TripLeg::_internal_admin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.admin_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_Admin>*
TripLeg::_internal_mutable_admin() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.admin_;
}

// string shape = 8;
inline void TripLeg::clear_shape() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.shape_.ClearToEmpty();
}
inline const std::string& TripLeg::shape() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.shape)
  return _internal_shape();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TripLeg::set_shape(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.shape_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.shape)
}
inline std::string* TripLeg::mutable_shape() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_shape();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.shape)
  return _s;
}
inline const std::string& TripLeg::_internal_shape() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.shape_.Get();
}
inline void TripLeg::_internal_set_shape(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.shape_.Set(value, GetArena());
}
inline std::string* TripLeg::_internal_mutable_shape() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.shape_.Mutable( GetArena());
}
inline std::string* TripLeg::release_shape() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.shape)
  return _impl_.shape_.Release();
}
inline void TripLeg::set_allocated_shape(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.shape_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.shape_.IsDefault()) {
          _impl_.shape_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.shape)
}

// .valhalla.BoundingBox bbox = 9;
inline bool TripLeg::has_bbox() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bbox_ != nullptr);
  return value;
}
inline const ::valhalla::BoundingBox& TripLeg::_internal_bbox() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::BoundingBox* p = _impl_.bbox_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::BoundingBox&>(::valhalla::_BoundingBox_default_instance_);
}
inline const ::valhalla::BoundingBox& TripLeg::bbox() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.bbox)
  return _internal_bbox();
}
inline void TripLeg::unsafe_arena_set_allocated_bbox(::valhalla::BoundingBox* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bbox_);
  }
  _impl_.bbox_ = reinterpret_cast<::valhalla::BoundingBox*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.bbox)
}
inline ::valhalla::BoundingBox* TripLeg::release_bbox() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::BoundingBox* released = _impl_.bbox_;
  _impl_.bbox_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::BoundingBox* TripLeg::unsafe_arena_release_bbox() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.bbox)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::valhalla::BoundingBox* temp = _impl_.bbox_;
  _impl_.bbox_ = nullptr;
  return temp;
}
inline ::valhalla::BoundingBox* TripLeg::_internal_mutable_bbox() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.bbox_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::BoundingBox>(GetArena());
    _impl_.bbox_ = reinterpret_cast<::valhalla::BoundingBox*>(p);
  }
  return _impl_.bbox_;
}
inline ::valhalla::BoundingBox* TripLeg::mutable_bbox() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::BoundingBox* _msg = _internal_mutable_bbox();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.bbox)
  return _msg;
}
inline void TripLeg::set_allocated_bbox(::valhalla::BoundingBox* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bbox_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.bbox_ = reinterpret_cast<::valhalla::BoundingBox*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.bbox)
}

// .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
inline bool TripLeg::has_shape_attributes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.shape_attributes_ != nullptr);
  return value;
}
inline void TripLeg::clear_shape_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.shape_attributes_ != nullptr) _impl_.shape_attributes_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::valhalla::TripLeg_ShapeAttributes& TripLeg::_internal_shape_attributes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::TripLeg_ShapeAttributes* p = _impl_.shape_attributes_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::TripLeg_ShapeAttributes&>(::valhalla::_TripLeg_ShapeAttributes_default_instance_);
}
inline const ::valhalla::TripLeg_ShapeAttributes& TripLeg::shape_attributes() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.shape_attributes)
  return _internal_shape_attributes();
}
inline void TripLeg::unsafe_arena_set_allocated_shape_attributes(::valhalla::TripLeg_ShapeAttributes* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shape_attributes_);
  }
  _impl_.shape_attributes_ = reinterpret_cast<::valhalla::TripLeg_ShapeAttributes*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.shape_attributes)
}
inline ::valhalla::TripLeg_ShapeAttributes* TripLeg::release_shape_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::valhalla::TripLeg_ShapeAttributes* released = _impl_.shape_attributes_;
  _impl_.shape_attributes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::TripLeg_ShapeAttributes* TripLeg::unsafe_arena_release_shape_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.shape_attributes)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::valhalla::TripLeg_ShapeAttributes* temp = _impl_.shape_attributes_;
  _impl_.shape_attributes_ = nullptr;
  return temp;
}
inline ::valhalla::TripLeg_ShapeAttributes* TripLeg::_internal_mutable_shape_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.shape_attributes_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::TripLeg_ShapeAttributes>(GetArena());
    _impl_.shape_attributes_ = reinterpret_cast<::valhalla::TripLeg_ShapeAttributes*>(p);
  }
  return _impl_.shape_attributes_;
}
inline ::valhalla::TripLeg_ShapeAttributes* TripLeg::mutable_shape_attributes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::TripLeg_ShapeAttributes* _msg = _internal_mutable_shape_attributes();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.shape_attributes)
  return _msg;
}
inline void TripLeg::set_allocated_shape_attributes(::valhalla::TripLeg_ShapeAttributes* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::valhalla::TripLeg_ShapeAttributes*>(_impl_.shape_attributes_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::valhalla::TripLeg_ShapeAttributes*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.shape_attributes_ = reinterpret_cast<::valhalla::TripLeg_ShapeAttributes*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.shape_attributes)
}

// repeated .valhalla.TripLeg.Incident incidents = 11;
inline int TripLeg::_internal_incidents_size() const {
  return _internal_incidents().size();
}
inline int TripLeg::incidents_size() const {
  return _internal_incidents_size();
}
inline void TripLeg::clear_incidents() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.incidents_.Clear();
}
inline ::valhalla::TripLeg_Incident* TripLeg::mutable_incidents(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.incidents)
  return _internal_mutable_incidents()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_Incident>* TripLeg::mutable_incidents()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.incidents)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_incidents();
}
inline const ::valhalla::TripLeg_Incident& TripLeg::incidents(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.incidents)
  return _internal_incidents().Get(index);
}
inline ::valhalla::TripLeg_Incident* TripLeg::add_incidents() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::TripLeg_Incident* _add = _internal_mutable_incidents()->Add();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.incidents)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_Incident>& TripLeg::incidents() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.incidents)
  return _internal_incidents();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_Incident>&
TripLeg::_internal_incidents() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.incidents_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_Incident>*
TripLeg::_internal_mutable_incidents() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.incidents_;
}

// repeated string algorithms = 12;
inline int TripLeg::_internal_algorithms_size() const {
  return _internal_algorithms().size();
}
inline int TripLeg::algorithms_size() const {
  return _internal_algorithms_size();
}
inline void TripLeg::clear_algorithms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.algorithms_.Clear();
}
inline std::string* TripLeg::add_algorithms()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_algorithms()->Add();
  // @@protoc_insertion_point(field_add_mutable:valhalla.TripLeg.algorithms)
  return _s;
}
inline const std::string& TripLeg::algorithms(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.algorithms)
  return _internal_algorithms().Get(index);
}
inline std::string* TripLeg::mutable_algorithms(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.algorithms)
  return _internal_mutable_algorithms()->Mutable(index);
}
inline void TripLeg::set_algorithms(int index, const std::string& value) {
  _internal_mutable_algorithms()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.algorithms)
}
inline void TripLeg::set_algorithms(int index, std::string&& value) {
  _internal_mutable_algorithms()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:valhalla.TripLeg.algorithms)
}
inline void TripLeg::set_algorithms(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_algorithms()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.TripLeg.algorithms)
}
inline void TripLeg::set_algorithms(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_algorithms()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.TripLeg.algorithms)
}
inline void TripLeg::set_algorithms(int index, absl::string_view value) {
  _internal_mutable_algorithms()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:valhalla.TripLeg.algorithms)
}
inline void TripLeg::add_algorithms(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_algorithms()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.algorithms)
}
inline void TripLeg::add_algorithms(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_algorithms()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.algorithms)
}
inline void TripLeg::add_algorithms(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_algorithms()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:valhalla.TripLeg.algorithms)
}
inline void TripLeg::add_algorithms(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_algorithms()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:valhalla.TripLeg.algorithms)
}
inline void TripLeg::add_algorithms(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_algorithms()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:valhalla.TripLeg.algorithms)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TripLeg::algorithms() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.algorithms)
  return _internal_algorithms();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TripLeg::mutable_algorithms() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.algorithms)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_algorithms();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TripLeg::_internal_algorithms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.algorithms_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TripLeg::_internal_mutable_algorithms() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.algorithms_;
}

// repeated .valhalla.TripLeg.Closure closures = 13;
inline int TripLeg::_internal_closures_size() const {
  return _internal_closures().size();
}
inline int TripLeg::closures_size() const {
  return _internal_closures_size();
}
inline void TripLeg::clear_closures() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.closures_.Clear();
}
inline ::valhalla::TripLeg_Closure* TripLeg::mutable_closures(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.closures)
  return _internal_mutable_closures()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_Closure>* TripLeg::mutable_closures()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripLeg.closures)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_closures();
}
inline const ::valhalla::TripLeg_Closure& TripLeg::closures(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.closures)
  return _internal_closures().Get(index);
}
inline ::valhalla::TripLeg_Closure* TripLeg::add_closures() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::TripLeg_Closure* _add = _internal_mutable_closures()->Add();
  // @@protoc_insertion_point(field_add:valhalla.TripLeg.closures)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_Closure>& TripLeg::closures() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.TripLeg.closures)
  return _internal_closures();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_Closure>&
TripLeg::_internal_closures() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.closures_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg_Closure>*
TripLeg::_internal_mutable_closures() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.closures_;
}

// .valhalla.Summary summary = 14;
inline bool TripLeg::has_summary() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.summary_ != nullptr);
  return value;
}
inline const ::valhalla::Summary& TripLeg::_internal_summary() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::valhalla::Summary* p = _impl_.summary_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::Summary&>(::valhalla::_Summary_default_instance_);
}
inline const ::valhalla::Summary& TripLeg::summary() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripLeg.summary)
  return _internal_summary();
}
inline void TripLeg::unsafe_arena_set_allocated_summary(::valhalla::Summary* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.summary_);
  }
  _impl_.summary_ = reinterpret_cast<::valhalla::Summary*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TripLeg.summary)
}
inline ::valhalla::Summary* TripLeg::release_summary() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::valhalla::Summary* released = _impl_.summary_;
  _impl_.summary_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::valhalla::Summary* TripLeg::unsafe_arena_release_summary() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:valhalla.TripLeg.summary)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::valhalla::Summary* temp = _impl_.summary_;
  _impl_.summary_ = nullptr;
  return temp;
}
inline ::valhalla::Summary* TripLeg::_internal_mutable_summary() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.summary_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::Summary>(GetArena());
    _impl_.summary_ = reinterpret_cast<::valhalla::Summary*>(p);
  }
  return _impl_.summary_;
}
inline ::valhalla::Summary* TripLeg::mutable_summary() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::valhalla::Summary* _msg = _internal_mutable_summary();
  // @@protoc_insertion_point(field_mutable:valhalla.TripLeg.summary)
  return _msg;
}
inline void TripLeg::set_allocated_summary(::valhalla::Summary* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.summary_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.summary_ = reinterpret_cast<::valhalla::Summary*>(value);
  // @@protoc_insertion_point(field_set_allocated:valhalla.TripLeg.summary)
}

// -------------------------------------------------------------------

// TripRoute

// repeated .valhalla.TripLeg legs = 1;
inline int TripRoute::_internal_legs_size() const {
  return _internal_legs().size();
}
inline int TripRoute::legs_size() const {
  return _internal_legs_size();
}
inline void TripRoute::clear_legs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.legs_.Clear();
}
inline ::valhalla::TripLeg* TripRoute::mutable_legs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.TripRoute.legs)
  return _internal_mutable_legs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg>* TripRoute::mutable_legs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.TripRoute.legs)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_legs();
}
inline const ::valhalla::TripLeg& TripRoute::legs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.TripRoute.legs)
  return _internal_legs().Get(index);
}
inline ::valhalla::TripLeg* TripRoute::add_legs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::TripLeg* _add = _internal_mutable_legs()->Add();
  // @@protoc_insertion_point(field_add:valhalla.TripRoute.legs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg>& TripRoute::legs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.TripRoute.legs)
  return _internal_legs();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg>&
TripRoute::_internal_legs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.legs_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::TripLeg>*
TripRoute::_internal_mutable_legs() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.legs_;
}

// -------------------------------------------------------------------

// Trip

// repeated .valhalla.TripRoute routes = 1;
inline int Trip::_internal_routes_size() const {
  return _internal_routes().size();
}
inline int Trip::routes_size() const {
  return _internal_routes_size();
}
inline void Trip::clear_routes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.routes_.Clear();
}
inline ::valhalla::TripRoute* Trip::mutable_routes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:valhalla.Trip.routes)
  return _internal_mutable_routes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::TripRoute>* Trip::mutable_routes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Trip.routes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_routes();
}
inline const ::valhalla::TripRoute& Trip::routes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:valhalla.Trip.routes)
  return _internal_routes().Get(index);
}
inline ::valhalla::TripRoute* Trip::add_routes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::valhalla::TripRoute* _add = _internal_mutable_routes()->Add();
  // @@protoc_insertion_point(field_add:valhalla.Trip.routes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::TripRoute>& Trip::routes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:valhalla.Trip.routes)
  return _internal_routes();
}
inline const ::google::protobuf::RepeatedPtrField<::valhalla::TripRoute>&
Trip::_internal_routes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.routes_;
}
inline ::google::protobuf::RepeatedPtrField<::valhalla::TripRoute>*
Trip::_internal_mutable_routes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.routes_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace valhalla


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::valhalla::TripLeg_TimeDomain_DayDowType> : std::true_type {};
template <>
struct is_proto_enum<::valhalla::TripLeg_Node_Type> : std::true_type {};
template <>
struct is_proto_enum<::valhalla::TripLeg_Traversability> : std::true_type {};
template <>
struct is_proto_enum<::valhalla::TripLeg_Use> : std::true_type {};
template <>
struct is_proto_enum<::valhalla::TripLeg_Surface> : std::true_type {};
template <>
struct is_proto_enum<::valhalla::TripLeg_CycleLane> : std::true_type {};
template <>
struct is_proto_enum<::valhalla::TripLeg_SacScale> : std::true_type {};
template <>
struct is_proto_enum<::valhalla::TripLeg_Sidewalk> : std::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_trip_2eproto_2epb_2eh
